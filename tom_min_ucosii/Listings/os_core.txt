; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\os_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\UCOSII\CORE -I.\UCOSII\PORTS -I.\UCOSII\CONFIG -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\os_core.crf UCOSII\CORE\os_core.c]
                          THUMB

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=1

                  OSInit PROC
;;;574    
;;;575    void  OSInit (void)
000000  b510              PUSH     {r4,lr}
;;;576    {
;;;577        OSInitHookBegin();                                           /* Call port specific initialization code   */
000002  f7fffffe          BL       OSInitHookBegin
;;;578    
;;;579        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
000006  f7fffffe          BL       OS_InitMisc
;;;580    
;;;581        OS_InitRdyList();                                            /* Initialize the Ready List                */
00000a  f7fffffe          BL       OS_InitRdyList
;;;582    
;;;583        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000e  f7fffffe          BL       OS_InitTCBList
;;;584    
;;;585        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
000012  f7fffffe          BL       OS_InitEventList
;;;586    
;;;587    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;588        OS_FlagInit();                                               /* Initialize the event flag structures     */
000016  f7fffffe          BL       OS_FlagInit
;;;589    #endif
;;;590    
;;;591    #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
;;;592        OS_MemInit();                                                /* Initialize the memory manager            */
;;;593    #endif
;;;594    
;;;595    #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
;;;596        OS_QInit();                                                  /* Initialize the message queue structures  */
00001a  f7fffffe          BL       OS_QInit
;;;597    #endif
;;;598    
;;;599        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00001e  f7fffffe          BL       OS_InitTaskIdle
;;;600    #if OS_TASK_STAT_EN > 0u
;;;601        OS_InitTaskStat();                                           /* Create the Statistic Task                */
000022  f7fffffe          BL       OS_InitTaskStat
;;;602    #endif
;;;603    
;;;604    #if OS_TMR_EN > 0u
;;;605        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;606    #endif
;;;607    
;;;608        OSInitHookEnd();                                             /* Call port specific init. code            */
000026  f7fffffe          BL       OSInitHookEnd
;;;609    
;;;610    #if OS_DEBUG_EN > 0u
;;;611        OSDebugInit();
;;;612    #endif
;;;613    }
00002a  bd10              POP      {r4,pc}
;;;614    /*$PAGE*/
                          ENDP


                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;639    
;;;640    void  OSIntEnter (void)
000000  4806              LDR      r0,|L2.28|
;;;641    {
;;;642        if (OSRunning == OS_TRUE) {
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d108              BNE      |L2.26|
;;;643            if (OSIntNesting < 255u) {
000008  4805              LDR      r0,|L2.32|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  28ff              CMP      r0,#0xff
00000e  d204              BCS      |L2.26|
;;;644                OSIntNesting++;                      /* Increment ISR nesting level                        */
000010  4803              LDR      r0,|L2.32|
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L2.32|
000018  7008              STRB     r0,[r1,#0]
                  |L2.26|
;;;645            }
;;;646        }
;;;647    }
00001a  4770              BX       lr
;;;648    /*$PAGE*/
                          ENDP

                  |L2.28|
                          DCD      OSRunning
                  |L2.32|
                          DCD      OSIntNesting

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;667    
;;;668    void  OSIntExit (void)
000000  b510              PUSH     {r4,lr}
;;;669    {
;;;670    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;671        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;672    #endif
;;;673    
;;;674    
;;;675    
;;;676        if (OSRunning == OS_TRUE) {
000004  481a              LDR      r0,|L3.112|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d130              BNE      |L3.110|
;;;677            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;678            if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
000012  4818              LDR      r0,|L3.116|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b120              CBZ      r0,|L3.34|
;;;679                OSIntNesting--;
000018  4816              LDR      r0,|L3.116|
00001a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001c  1e40              SUBS     r0,r0,#1
00001e  4915              LDR      r1,|L3.116|
000020  7008              STRB     r0,[r1,#0]
                  |L3.34|
;;;680            }
;;;681            if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
000022  4814              LDR      r0,|L3.116|
000024  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000026  b9f8              CBNZ     r0,|L3.104|
;;;682                if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
000028  4813              LDR      r0,|L3.120|
00002a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002c  b9e0              CBNZ     r0,|L3.104|
;;;683                    OS_SchedNew();
00002e  f7fffffe          BL       OS_SchedNew
;;;684                    OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000032  4812              LDR      r0,|L3.124|
000034  4912              LDR      r1,|L3.128|
000036  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000038  f8500021          LDR      r0,[r0,r1,LSL #2]
00003c  4911              LDR      r1,|L3.132|
00003e  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;685                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
000040  480f              LDR      r0,|L3.128|
000042  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000044  4910              LDR      r1,|L3.136|
000046  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000048  4288              CMP      r0,r1
00004a  d00d              BEQ      |L3.104|
;;;686    #if OS_TASK_PROFILE_EN > 0u
;;;687                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00004c  480d              LDR      r0,|L3.132|
00004e  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000050  6b80              LDR      r0,[r0,#0x38]
000052  1c40              ADDS     r0,r0,#1
000054  490b              LDR      r1,|L3.132|
000056  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000058  6388              STR      r0,[r1,#0x38]
;;;688    #endif
;;;689                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00005a  480c              LDR      r0,|L3.140|
00005c  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
00005e  1c40              ADDS     r0,r0,#1
000060  490a              LDR      r1,|L3.140|
000062  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;690                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000064  f7fffffe          BL       OSIntCtxSw
                  |L3.104|
;;;691                    }
;;;692                }
;;;693            }
;;;694            OS_EXIT_CRITICAL();
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       OS_CPU_SR_Restore
                  |L3.110|
;;;695        }
;;;696    }
00006e  bd10              POP      {r4,pc}
;;;697    /*$PAGE*/
                          ENDP

                  |L3.112|
                          DCD      OSRunning
                  |L3.116|
                          DCD      OSIntNesting
                  |L3.120|
                          DCD      OSLockNesting
                  |L3.124|
                          DCD      OSTCBPrioTbl
                  |L3.128|
                          DCD      OSPrioHighRdy
                  |L3.132|
                          DCD      OSTCBHighRdy
                  |L3.136|
                          DCD      OSPrioCur
                  |L3.140|
                          DCD      OSCtxSwCtr

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;740    #if OS_SCHED_LOCK_EN > 0u
;;;741    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;742    {
;;;743    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;744        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;745    #endif
;;;746    
;;;747    
;;;748    
;;;749        if (OSRunning == OS_TRUE) 
000004  480b              LDR      r0,|L4.52|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d111              BNE      |L4.48|
;;;750    	{                  /* Make sure multitasking is running                  */
;;;751            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;752            if (OSIntNesting == 0u) 
000012  4809              LDR      r0,|L4.56|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b940              CBNZ     r0,|L4.42|
;;;753    		{                /* Can't call from an ISR                             */
;;;754                	if (OSLockNesting < 255u) 
000018  4808              LDR      r0,|L4.60|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  28ff              CMP      r0,#0xff
00001e  d204              BCS      |L4.42|
;;;755    			{          /* Prevent OSLockNesting from wrapping back to 0      */
;;;756                    OSLockNesting++;                 /* Increment lock nesting level                       */
000020  4806              LDR      r0,|L4.60|
000022  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000024  1c40              ADDS     r0,r0,#1
000026  4905              LDR      r1,|L4.60|
000028  7008              STRB     r0,[r1,#0]
                  |L4.42|
;;;757                	}
;;;758            	}
;;;759           	OS_EXIT_CRITICAL();
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L4.48|
;;;760        }
;;;761    }
000030  bd10              POP      {r4,pc}
;;;762    #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      OSRunning
                  |L4.56|
                          DCD      OSIntNesting
                  |L4.60|
                          DCD      OSLockNesting

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;780    #if OS_SCHED_LOCK_EN > 0u
;;;781    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;782    {
;;;783    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;784        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;785    #endif
;;;786    
;;;787    
;;;788    
;;;789        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000004  4813              LDR      r0,|L5.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  2801              CMP      r0,#1
00000a  d121              BNE      |L5.80|
;;;790            OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  4604              MOV      r4,r0
;;;791            if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
000012  4811              LDR      r0,|L5.88|
000014  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000016  b9c0              CBNZ     r0,|L5.74|
;;;792                if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
000018  4810              LDR      r0,|L5.92|
00001a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00001c  b188              CBZ      r0,|L5.66|
;;;793                    OSLockNesting--;                           /* Decrement lock nesting level             */
00001e  480f              LDR      r0,|L5.92|
000020  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000022  1e40              SUBS     r0,r0,#1
000024  490d              LDR      r1,|L5.92|
000026  7008              STRB     r0,[r1,#0]
;;;794                    if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
000028  4608              MOV      r0,r1
00002a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00002c  b928              CBNZ     r0,|L5.58|
;;;795                        OS_EXIT_CRITICAL();
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;796                        OS_Sched();                            /* See if a HPT is ready                    */
000034  f7fffffe          BL       OS_Sched
000038  e00a              B        |L5.80|
                  |L5.58|
;;;797                    } else {
;;;798                        OS_EXIT_CRITICAL();
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  e006              B        |L5.80|
                  |L5.66|
;;;799                    }
;;;800                } else {
;;;801                    OS_EXIT_CRITICAL();
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  e002              B        |L5.80|
                  |L5.74|
;;;802                }
;;;803            } else {
;;;804                OS_EXIT_CRITICAL();
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L5.80|
;;;805            }
;;;806        }
;;;807    }
000050  bd10              POP      {r4,pc}
;;;808    #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      OSRunning
                  |L5.88|
                          DCD      OSIntNesting
                  |L5.92|
                          DCD      OSLockNesting

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;830    
;;;831    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;832    {
;;;833        if (OSRunning == OS_FALSE) {
000002  480b              LDR      r0,|L6.48|
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  b990              CBNZ     r0,|L6.46|
;;;834            OS_SchedNew();                               /* Find highest priority's task priority number   */
000008  f7fffffe          BL       OS_SchedNew
;;;835            OSPrioCur     = OSPrioHighRdy;
00000c  4809              LDR      r0,|L6.52|
00000e  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000010  4909              LDR      r1,|L6.56|
000012  7008              STRB     r0,[r1,#0]
;;;836            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000014  4809              LDR      r0,|L6.60|
000016  4907              LDR      r1,|L6.52|
000018  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
00001a  f8500021          LDR      r0,[r0,r1,LSL #2]
00001e  4908              LDR      r1,|L6.64|
000020  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;837            OSTCBCur      = OSTCBHighRdy;
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000026  4907              LDR      r1,|L6.68|
000028  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;838            OSStartHighRdy();                            /* Execute target specific code to start task     */
00002a  f7fffffe          BL       OSStartHighRdy
                  |L6.46|
;;;839        }
;;;840    }
00002e  bd10              POP      {r4,pc}
;;;841    /*$PAGE*/
                          ENDP

                  |L6.48|
                          DCD      OSRunning
                  |L6.52|
                          DCD      OSPrioHighRdy
                  |L6.56|
                          DCD      OSPrioCur
                  |L6.60|
                          DCD      OSTCBPrioTbl
                  |L6.64|
                          DCD      OSTCBHighRdy
                  |L6.68|
                          DCD      OSTCBCur

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;862    #if OS_TASK_STAT_EN > 0u
;;;863    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;864    {
;;;865    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;866        OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;867    #endif
;;;868    
;;;869    
;;;870    
;;;871        OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       OSTimeDly
;;;872        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4604              MOV      r4,r0
;;;873        OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
000010  2000              MOVS     r0,#0
000012  490b              LDR      r1,|L7.64|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;874        OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;875        OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00001c  2014              MOVS     r0,#0x14
00001e  f7fffffe          BL       OSTimeDly
;;;876        OS_ENTER_CRITICAL();
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4604              MOV      r4,r0
;;;877        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000028  4805              LDR      r0,|L7.64|
00002a  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
00002c  4905              LDR      r1,|L7.68|
00002e  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;878        OSStatRdy    = OS_TRUE;
000030  2001              MOVS     r0,#1
000032  4905              LDR      r1,|L7.72|
000034  7008              STRB     r0,[r1,#0]
;;;879        OS_EXIT_CRITICAL();
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       OS_CPU_SR_Restore
;;;880    }
00003c  bd10              POP      {r4,pc}
;;;881    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      OSIdleCtr
                  |L7.68|
                          DCD      OSIdleCtrMax
                  |L7.72|
                          DCD      OSStatRdy

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;898    
;;;899    void  OSTimeTick (void)
000000  b570              PUSH     {r4-r6,lr}
;;;900    {
;;;901        OS_TCB    *ptcb;
;;;902    #if OS_TICK_STEP_EN > 0u
;;;903        BOOLEAN    step;
;;;904    #endif
;;;905    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
;;;906        OS_CPU_SR  cpu_sr = 0u;
000002  2600              MOVS     r6,#0
;;;907    #endif
;;;908    
;;;909    	T5ms += 5;
000004  4835              LDR      r0,|L8.220|
000006  6800              LDR      r0,[r0,#0]  ; T5ms
000008  1d40              ADDS     r0,r0,#5
00000a  4934              LDR      r1,|L8.220|
00000c  6008              STR      r0,[r1,#0]  ; T5ms
;;;910    
;;;911    #if OS_TIME_TICK_HOOK_EN > 0u
;;;912        OSTimeTickHook();                                      /* Call user definable hook                     */
00000e  f7fffffe          BL       OSTimeTickHook
;;;913    #endif
;;;914    #if OS_TIME_GET_SET_EN > 0u
;;;915        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4606              MOV      r6,r0
;;;916        OSTime++;
000018  4831              LDR      r0,|L8.224|
00001a  6800              LDR      r0,[r0,#0]  ; OSTime
00001c  1c40              ADDS     r0,r0,#1
00001e  4930              LDR      r1,|L8.224|
000020  6008              STR      r0,[r1,#0]  ; OSTime
;;;917        OS_EXIT_CRITICAL();
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       OS_CPU_SR_Restore
;;;918    #endif
;;;919        if (OSRunning == OS_TRUE) {
000028  482e              LDR      r0,|L8.228|
00002a  7800              LDRB     r0,[r0,#0]  ; OSRunning
00002c  2801              CMP      r0,#1
00002e  d153              BNE      |L8.216|
;;;920    #if OS_TICK_STEP_EN > 0u
;;;921            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000030  482d              LDR      r0,|L8.232|
000032  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
000034  b120              CBZ      r0,|L8.64|
000036  2801              CMP      r0,#1
000038  d004              BEQ      |L8.68|
00003a  2802              CMP      r0,#2
00003c  d109              BNE      |L8.82|
00003e  e003              B        |L8.72|
                  |L8.64|
;;;922                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;923                     step = OS_TRUE;
000040  2501              MOVS     r5,#1
;;;924                     break;
000042  e00b              B        |L8.92|
                  |L8.68|
;;;925    
;;;926                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;927                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
000044  2500              MOVS     r5,#0
;;;928                     break;
000046  e009              B        |L8.92|
                  |L8.72|
;;;929    
;;;930                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;931                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
000048  2501              MOVS     r5,#1
;;;932                     OSTickStepState = OS_TICK_STEP_WAIT;
00004a  2001              MOVS     r0,#1
00004c  4926              LDR      r1,|L8.232|
00004e  7008              STRB     r0,[r1,#0]
;;;933                     break;
000050  e004              B        |L8.92|
                  |L8.82|
;;;934    
;;;935                default:                                       /* Invalid case, correct situation              */
;;;936                     step            = OS_TRUE;
000052  2501              MOVS     r5,#1
;;;937                     OSTickStepState = OS_TICK_STEP_DIS;
000054  2000              MOVS     r0,#0
000056  4924              LDR      r1,|L8.232|
000058  7008              STRB     r0,[r1,#0]
;;;938                     break;
00005a  bf00              NOP      
                  |L8.92|
00005c  bf00              NOP                            ;924
;;;939            }
;;;940            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
00005e  b905              CBNZ     r5,|L8.98|
                  |L8.96|
;;;941                return;
;;;942            }
;;;943    #endif
;;;944            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;945            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;946                OS_ENTER_CRITICAL();
;;;947                if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
;;;948                    ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
;;;949                    if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
;;;950    
;;;951                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;952                            ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;953                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;954                        } else {
;;;955                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;956                        }
;;;957    
;;;958                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;959                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;960                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;961                        }
;;;962                    }
;;;963                }
;;;964                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;965                OS_EXIT_CRITICAL();
;;;966            }
;;;967        }
;;;968    }
000060  bd70              POP      {r4-r6,pc}
                  |L8.98|
000062  4822              LDR      r0,|L8.236|
000064  6804              LDR      r4,[r0,#0]            ;944  ; OSTCBList
000066  e033              B        |L8.208|
                  |L8.104|
000068  f7fffffe          BL       OS_CPU_SR_Save
00006c  4606              MOV      r6,r0                 ;946
00006e  6ae0              LDR      r0,[r4,#0x2c]         ;947
000070  b350              CBZ      r0,|L8.200|
000072  6ae0              LDR      r0,[r4,#0x2c]         ;948
000074  1e40              SUBS     r0,r0,#1              ;948
000076  62e0              STR      r0,[r4,#0x2c]         ;948
000078  6ae0              LDR      r0,[r4,#0x2c]         ;949
00007a  bb28              CBNZ     r0,|L8.200|
00007c  f8940030          LDRB     r0,[r4,#0x30]         ;951
000080  f0000037          AND      r0,r0,#0x37           ;951
000084  b140              CBZ      r0,|L8.152|
000086  f8140f30          LDRB     r0,[r4,#0x30]!        ;952
00008a  f00000c8          AND      r0,r0,#0xc8           ;952
00008e  7020              STRB     r0,[r4,#0]            ;952
000090  2001              MOVS     r0,#1                 ;953
000092  7060              STRB     r0,[r4,#1]            ;953
000094  3c30              SUBS     r4,r4,#0x30           ;953
000096  e002              B        |L8.158|
                  |L8.152|
000098  2000              MOVS     r0,#0                 ;955
00009a  f8840031          STRB     r0,[r4,#0x31]         ;955
                  |L8.158|
00009e  f8940030          LDRB     r0,[r4,#0x30]         ;958
0000a2  f0000008          AND      r0,r0,#8              ;958
0000a6  b978              CBNZ     r0,|L8.200|
0000a8  3434              ADDS     r4,r4,#0x34           ;959
0000aa  78a0              LDRB     r0,[r4,#2]            ;959
0000ac  4910              LDR      r1,|L8.240|
0000ae  7809              LDRB     r1,[r1,#0]            ;959  ; OSRdyGrp
0000b0  4308              ORRS     r0,r0,r1              ;959
0000b2  490f              LDR      r1,|L8.240|
0000b4  7008              STRB     r0,[r1,#0]            ;959
0000b6  7820              LDRB     r0,[r4,#0]            ;960
0000b8  490e              LDR      r1,|L8.244|
0000ba  5c08              LDRB     r0,[r1,r0]            ;960
0000bc  7861              LDRB     r1,[r4,#1]            ;960
0000be  4308              ORRS     r0,r0,r1              ;960
0000c0  f8141934          LDRB     r1,[r4],#-0x34        ;960
0000c4  4a0b              LDR      r2,|L8.244|
0000c6  5450              STRB     r0,[r2,r1]            ;960
                  |L8.200|
0000c8  6964              LDR      r4,[r4,#0x14]         ;964
0000ca  4630              MOV      r0,r6                 ;965
0000cc  f7fffffe          BL       OS_CPU_SR_Restore
                  |L8.208|
0000d0  f8940032          LDRB     r0,[r4,#0x32]         ;945
0000d4  283f              CMP      r0,#0x3f              ;945
0000d6  d1c7              BNE      |L8.104|
                  |L8.216|
0000d8  bf00              NOP      
0000da  e7c1              B        |L8.96|
;;;969    
                          ENDP

                  |L8.220|
                          DCD      T5ms
                  |L8.224|
                          DCD      OSTime
                  |L8.228|
                          DCD      OSRunning
                  |L8.232|
                          DCD      OSTickStepState
                  |L8.236|
                          DCD      OSTCBList
                  |L8.240|
                          DCD      OSRdyGrp
                  |L8.244|
                          DCD      OSRdyTbl

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;984    
;;;985    INT16U  OSVersion (void)
000000  f2472017          MOV      r0,#0x7217
;;;986    {
;;;987        return (OS_VERSION);
;;;988    }
000004  4770              BX       lr
;;;989    
                          ENDP


                          AREA ||i.OS_Dummy||, CODE, READONLY, ALIGN=1

                  OS_Dummy PROC
;;;1003   #if OS_TASK_DEL_EN > 0u
;;;1004   void  OS_Dummy (void)
000000  4770              BX       lr
;;;1005   {
;;;1006   }
;;;1007   #endif
                          ENDP


                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;1037   #if (OS_EVENT_EN)
;;;1038   INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1039                           void      *pmsg,
;;;1040                           INT8U      msk,
;;;1041                           INT8U      pend_stat)
;;;1042   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;1043       OS_TCB   *ptcb;
;;;1044       INT8U     y;
;;;1045       INT8U     x;
;;;1046       INT8U     prio;
;;;1047   #if OS_LOWEST_PRIO > 63u
;;;1048       OS_PRIO  *ptbl;
;;;1049   #endif
;;;1050   
;;;1051   
;;;1052   #if OS_LOWEST_PRIO <= 63u
;;;1053       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00000c  7aa8              LDRB     r0,[r5,#0xa]
00000e  4919              LDR      r1,|L11.116|
000010  5c0e              LDRB     r6,[r1,r0]
;;;1054       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000012  f105000b          ADD      r0,r5,#0xb
000016  5d80              LDRB     r0,[r0,r6]
000018  f811b000          LDRB     r11,[r1,r0]
;;;1055       prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00001c  eb0b00c6          ADD      r0,r11,r6,LSL #3
000020  f0000aff          AND      r10,r0,#0xff
;;;1056   #else
;;;1057       if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
;;;1058           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
;;;1059       } else {
;;;1060           y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
;;;1061       }
;;;1062       ptbl = &pevent->OSEventTbl[y];
;;;1063       if ((*ptbl & 0xFFu) != 0u) {
;;;1064           x = OSUnMapTbl[*ptbl & 0xFFu];
;;;1065       } else {
;;;1066           x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
;;;1067       }
;;;1068       prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
;;;1069   #endif
;;;1070   
;;;1071       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000024  4814              LDR      r0,|L11.120|
000026  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1072       ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00002a  2000              MOVS     r0,#0
00002c  3420              ADDS     r4,r4,#0x20
00002e  60e0              STR      r0,[r4,#0xc]
;;;1073   #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
;;;1074       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000030  6027              STR      r7,[r4,#0]
;;;1075   #else
;;;1076       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1077   #endif
;;;1078       ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
000032  7c20              LDRB     r0,[r4,#0x10]
000034  ea200008          BIC      r0,r0,r8
000038  7420              STRB     r0,[r4,#0x10]
;;;1079       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00003a  f8849011          STRB     r9,[r4,#0x11]
;;;1080                                                           /* See if task is ready (could be susp'd)      */
;;;1081       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00003e  7c20              LDRB     r0,[r4,#0x10]
000040  3c20              SUBS     r4,r4,#0x20
000042  f0000008          AND      r0,r0,#8
000046  b968              CBNZ     r0,|L11.100|
;;;1082           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000048  f8940036          LDRB     r0,[r4,#0x36]
00004c  490b              LDR      r1,|L11.124|
00004e  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000050  4308              ORRS     r0,r0,r1
000052  490a              LDR      r1,|L11.124|
000054  7008              STRB     r0,[r1,#0]
;;;1083           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000056  480a              LDR      r0,|L11.128|
000058  5d80              LDRB     r0,[r0,r6]
00005a  f8941035          LDRB     r1,[r4,#0x35]
00005e  4308              ORRS     r0,r0,r1
000060  4907              LDR      r1,|L11.128|
000062  5588              STRB     r0,[r1,r6]
                  |L11.100|
;;;1084       }
;;;1085   
;;;1086       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_EventTaskRemove
;;;1087   #if (OS_EVENT_MULTI_EN > 0u)
;;;1088       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
;;;1089           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;1090           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
;;;1091       }
;;;1092   #endif
;;;1093   
;;;1094       return (prio);
00006c  4650              MOV      r0,r10
;;;1095   }
00006e  e8bd8ff0          POP      {r4-r11,pc}
;;;1096   #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L11.116|
                          DCD      OSUnMapTbl
                  |L11.120|
                          DCD      OSTCBPrioTbl
                  |L11.124|
                          DCD      OSRdyGrp
                  |L11.128|
                          DCD      OSRdyTbl

                          AREA ||i.OS_EventTaskRemove||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemove PROC
;;;1189   #if (OS_EVENT_EN)
;;;1190   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000000  b510              PUSH     {r4,lr}
;;;1191                             OS_EVENT *pevent)
;;;1192   {
;;;1193       INT8U  y;
;;;1194   
;;;1195   
;;;1196       y                       =  ptcb->OSTCBY;
000002  f8902034          LDRB     r2,[r0,#0x34]
;;;1197       pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000006  f101030b          ADD      r3,r1,#0xb
00000a  5c9b              LDRB     r3,[r3,r2]
00000c  f8904035          LDRB     r4,[r0,#0x35]
000010  43a3              BICS     r3,r3,r4
000012  f101040b          ADD      r4,r1,#0xb
000016  54a3              STRB     r3,[r4,r2]
;;;1198       if (pevent->OSEventTbl[y] == 0u) {
000018  4623              MOV      r3,r4
00001a  5c9b              LDRB     r3,[r3,r2]
00001c  b923              CBNZ     r3,|L12.40|
;;;1199           pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00001e  7a8b              LDRB     r3,[r1,#0xa]
000020  f8904036          LDRB     r4,[r0,#0x36]
000024  43a3              BICS     r3,r3,r4
000026  728b              STRB     r3,[r1,#0xa]
                  |L12.40|
;;;1200       }
;;;1201   }
000028  bd10              POP      {r4,pc}
;;;1202   #endif
                          ENDP


                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;1112   #if (OS_EVENT_EN)
;;;1113   void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b510              PUSH     {r4,lr}
;;;1114   {
;;;1115       INT8U  y;
;;;1116   
;;;1117   
;;;1118       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000002  4a1b              LDR      r2,|L13.112|
000004  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000006  61d0              STR      r0,[r2,#0x1c]
;;;1119   
;;;1120       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000008  4a19              LDR      r2,|L13.112|
00000a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
00000c  f8923034          LDRB     r3,[r2,#0x34]
000010  f100020b          ADD      r2,r0,#0xb
000014  5cd2              LDRB     r2,[r2,r3]
000016  4b16              LDR      r3,|L13.112|
000018  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00001a  f8933035          LDRB     r3,[r3,#0x35]
00001e  431a              ORRS     r2,r2,r3
000020  4b13              LDR      r3,|L13.112|
000022  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000024  f8934034          LDRB     r4,[r3,#0x34]
000028  f100030b          ADD      r3,r0,#0xb
00002c  551a              STRB     r2,[r3,r4]
;;;1121       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00002e  7a82              LDRB     r2,[r0,#0xa]
000030  4b0f              LDR      r3,|L13.112|
000032  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000034  f8933036          LDRB     r3,[r3,#0x36]
000038  431a              ORRS     r2,r2,r3
00003a  7282              STRB     r2,[r0,#0xa]
;;;1122   
;;;1123       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00003c  4a0c              LDR      r2,|L13.112|
00003e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000040  f8921034          LDRB     r1,[r2,#0x34]
;;;1124       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000044  4a0b              LDR      r2,|L13.116|
000046  5c52              LDRB     r2,[r2,r1]
000048  4b09              LDR      r3,|L13.112|
00004a  681b              LDR      r3,[r3,#0]  ; OSTCBCur
00004c  f8933035          LDRB     r3,[r3,#0x35]
000050  439a              BICS     r2,r2,r3
000052  4b08              LDR      r3,|L13.116|
000054  545a              STRB     r2,[r3,r1]
;;;1125       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000056  461a              MOV      r2,r3
000058  5c52              LDRB     r2,[r2,r1]
00005a  b942              CBNZ     r2,|L13.110|
;;;1126           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00005c  4a04              LDR      r2,|L13.112|
00005e  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000060  f8923036          LDRB     r3,[r2,#0x36]
000064  4a04              LDR      r2,|L13.120|
000066  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000068  439a              BICS     r2,r2,r3
00006a  4b03              LDR      r3,|L13.120|
00006c  701a              STRB     r2,[r3,#0]
                  |L13.110|
;;;1127       }
;;;1128   }
00006e  bd10              POP      {r4,pc}
;;;1129   #endif
                          ENDP

                  |L13.112|
                          DCD      OSTCBCur
                  |L13.116|
                          DCD      OSRdyTbl
                  |L13.120|
                          DCD      OSRdyGrp

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;1259   #if (OS_EVENT_EN)
;;;1260   void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  4601              MOV      r1,r0
;;;1261   {
;;;1262       INT8U  i;
;;;1263   
;;;1264   
;;;1265       pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000002  2200              MOVS     r2,#0
000004  728a              STRB     r2,[r1,#0xa]
;;;1266       for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e005              B        |L14.22|
                  |L14.10|
;;;1267           pevent->OSEventTbl[i] = 0u;
00000a  2300              MOVS     r3,#0
00000c  f101020b          ADD      r2,r1,#0xb
000010  5413              STRB     r3,[r2,r0]
000012  1c42              ADDS     r2,r0,#1              ;1266
000014  b2d0              UXTB     r0,r2                 ;1266
                  |L14.22|
000016  2808              CMP      r0,#8                 ;1266
000018  d3f7              BCC      |L14.10|
;;;1268       }
;;;1269   }
00001a  4770              BX       lr
;;;1270   #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;1284   
;;;1285   static  void  OS_InitEventList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1286   {
;;;1287   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
;;;1288   #if (OS_MAX_EVENTS > 1u)
;;;1289       INT16U     ix;
;;;1290       INT16U     ix_next;
;;;1291       OS_EVENT  *pevent1;
;;;1292       OS_EVENT  *pevent2;
;;;1293   
;;;1294   
;;;1295       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  21c8              MOVS     r1,#0xc8
000004  4811              LDR      r0,|L15.76|
000006  f7fffffe          BL       OS_MemClr
;;;1296       for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00000a  2300              MOVS     r3,#0
00000c  e00f              B        |L15.46|
                  |L15.14|
;;;1297           ix_next = ix + 1u;
00000e  1c58              ADDS     r0,r3,#1
000010  b285              UXTH     r5,r0
;;;1298           pevent1 = &OSEventTbl[ix];
000012  eb030083          ADD      r0,r3,r3,LSL #2
000016  490d              LDR      r1,|L15.76|
000018  eb010480          ADD      r4,r1,r0,LSL #2
;;;1299           pevent2 = &OSEventTbl[ix_next];
00001c  eb050085          ADD      r0,r5,r5,LSL #2
000020  eb010680          ADD      r6,r1,r0,LSL #2
;;;1300           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000024  2000              MOVS     r0,#0
000026  7020              STRB     r0,[r4,#0]
;;;1301           pevent1->OSEventPtr     = pevent2;
000028  6066              STR      r6,[r4,#4]
00002a  1c58              ADDS     r0,r3,#1              ;1296
00002c  b283              UXTH     r3,r0                 ;1296
                  |L15.46|
00002e  2b09              CMP      r3,#9                 ;1296
000030  d3ed              BCC      |L15.14|
;;;1302   #if OS_EVENT_NAME_EN > 0u
;;;1303           pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
;;;1304   #endif
;;;1305       }
;;;1306       pevent1                         = &OSEventTbl[ix];
000032  eb030083          ADD      r0,r3,r3,LSL #2
000036  4905              LDR      r1,|L15.76|
000038  eb010480          ADD      r4,r1,r0,LSL #2
;;;1307       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00003c  2000              MOVS     r0,#0
00003e  7020              STRB     r0,[r4,#0]
;;;1308       pevent1->OSEventPtr             = (OS_EVENT *)0;
000040  6060              STR      r0,[r4,#4]
;;;1309   #if OS_EVENT_NAME_EN > 0u
;;;1310       pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
;;;1311   #endif
;;;1312       OSEventFreeList                 = &OSEventTbl[0];
000042  4608              MOV      r0,r1
000044  4902              LDR      r1,|L15.80|
000046  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1313   #else
;;;1314       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1315       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1316       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1317   #if OS_EVENT_NAME_EN > 0u
;;;1318       OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
;;;1319   #endif
;;;1320   #endif
;;;1321   #endif
;;;1322   }
000048  bd70              POP      {r4-r6,pc}
;;;1323   /*$PAGE*/
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      OSEventTbl
                  |L15.80|
                          DCD      OSEventFreeList

                          AREA ||i.OS_InitMisc||, CODE, READONLY, ALIGN=2

                  OS_InitMisc PROC
;;;1336   
;;;1337   static  void  OS_InitMisc (void)
000000  2000              MOVS     r0,#0
;;;1338   {
;;;1339   #if OS_TIME_GET_SET_EN > 0u
;;;1340       OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000002  490b              LDR      r1,|L16.48|
000004  6008              STR      r0,[r1,#0]  ; OSTime
;;;1341   #endif
;;;1342   
;;;1343       OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000006  490b              LDR      r1,|L16.52|
000008  7008              STRB     r0,[r1,#0]
;;;1344       OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
00000a  490b              LDR      r1,|L16.56|
00000c  7008              STRB     r0,[r1,#0]
;;;1345   
;;;1346       OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
00000e  490b              LDR      r1,|L16.60|
000010  7008              STRB     r0,[r1,#0]
;;;1347   
;;;1348       OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000012  490b              LDR      r1,|L16.64|
000014  7008              STRB     r0,[r1,#0]
;;;1349   
;;;1350       OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000016  490b              LDR      r1,|L16.68|
000018  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1351       OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
00001a  490b              LDR      r1,|L16.72|
00001c  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1352   
;;;1353   #if OS_TASK_STAT_EN > 0u
;;;1354       OSIdleCtrRun              = 0uL;
00001e  490b              LDR      r1,|L16.76|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1355       OSIdleCtrMax              = 0uL;
000022  490b              LDR      r1,|L16.80|
000024  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1356       OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000026  490b              LDR      r1,|L16.84|
000028  7008              STRB     r0,[r1,#0]
;;;1357   #endif
;;;1358   
;;;1359   #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;1360       OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
;;;1361   #endif
;;;1362   
;;;1363   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1364       OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
00002a  490b              LDR      r1,|L16.88|
00002c  7008              STRB     r0,[r1,#0]
;;;1365   #endif
;;;1366   }
00002e  4770              BX       lr
;;;1367   /*$PAGE*/
                          ENDP

                  |L16.48|
                          DCD      OSTime
                  |L16.52|
                          DCD      OSIntNesting
                  |L16.56|
                          DCD      OSLockNesting
                  |L16.60|
                          DCD      OSTaskCtr
                  |L16.64|
                          DCD      OSRunning
                  |L16.68|
                          DCD      OSCtxSwCtr
                  |L16.72|
                          DCD      OSIdleCtr
                  |L16.76|
                          DCD      OSIdleCtrRun
                  |L16.80|
                          DCD      OSIdleCtrMax
                  |L16.84|
                          DCD      OSStatRdy
                  |L16.88|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OS_InitRdyList||, CODE, READONLY, ALIGN=2

                  OS_InitRdyList PROC
;;;1380   
;;;1381   static  void  OS_InitRdyList (void)
000000  2100              MOVS     r1,#0
;;;1382   {
;;;1383       INT8U  i;
;;;1384   
;;;1385   
;;;1386       OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000002  4a0a              LDR      r2,|L17.44|
000004  7011              STRB     r1,[r2,#0]
;;;1387       for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
000006  2000              MOVS     r0,#0
000008  e004              B        |L17.20|
                  |L17.10|
;;;1388           OSRdyTbl[i] = 0u;
00000a  2100              MOVS     r1,#0
00000c  4a08              LDR      r2,|L17.48|
00000e  5411              STRB     r1,[r2,r0]
000010  1c41              ADDS     r1,r0,#1              ;1387
000012  b2c8              UXTB     r0,r1                 ;1387
                  |L17.20|
000014  2808              CMP      r0,#8                 ;1387
000016  d3f8              BCC      |L17.10|
;;;1389       }
;;;1390   
;;;1391       OSPrioCur     = 0u;
000018  2100              MOVS     r1,#0
00001a  4a06              LDR      r2,|L17.52|
00001c  7011              STRB     r1,[r2,#0]
;;;1392       OSPrioHighRdy = 0u;
00001e  4a06              LDR      r2,|L17.56|
000020  7011              STRB     r1,[r2,#0]
;;;1393   
;;;1394       OSTCBHighRdy  = (OS_TCB *)0;
000022  4a06              LDR      r2,|L17.60|
000024  6011              STR      r1,[r2,#0]  ; OSTCBHighRdy
;;;1395       OSTCBCur      = (OS_TCB *)0;
000026  4a06              LDR      r2,|L17.64|
000028  6011              STR      r1,[r2,#0]  ; OSTCBCur
;;;1396   }
00002a  4770              BX       lr
;;;1397   
                          ENDP

                  |L17.44|
                          DCD      OSRdyGrp
                  |L17.48|
                          DCD      OSRdyTbl
                  |L17.52|
                          DCD      OSPrioCur
                  |L17.56|
                          DCD      OSPrioHighRdy
                  |L17.60|
                          DCD      OSTCBHighRdy
                  |L17.64|
                          DCD      OSTCBCur

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1535   
;;;1536   static  void  OS_InitTCBList (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1537   {
;;;1538       INT8U    ix;
;;;1539       INT8U    ix_next;
;;;1540       OS_TCB  *ptcb1;
;;;1541       OS_TCB  *ptcb2;
;;;1542   
;;;1543   
;;;1544       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f7113          MOV      r1,#0x24c
000006  4819              LDR      r0,|L18.108|
000008  f7fffffe          BL       OS_MemClr
;;;1545       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  f44f7180          MOV      r1,#0x100
000010  4817              LDR      r0,|L18.112|
000012  f7fffffe          BL       OS_MemClr
;;;1546       for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000016  2400              MOVS     r4,#0
000018  e013              B        |L18.66|
                  |L18.26|
;;;1547           ix_next =  ix + 1u;
00001a  1c60              ADDS     r0,r4,#1
00001c  b2c5              UXTB     r5,r0
;;;1548           ptcb1   = &OSTCBTbl[ix];
00001e  ebc400c4          RSB      r0,r4,r4,LSL #3
000022  eb000040          ADD      r0,r0,r0,LSL #1
000026  4911              LDR      r1,|L18.108|
000028  eb010380          ADD      r3,r1,r0,LSL #2
;;;1549           ptcb2   = &OSTCBTbl[ix_next];
00002c  ebc500c5          RSB      r0,r5,r5,LSL #3
000030  eb000040          ADD      r0,r0,r0,LSL #1
000034  eb010680          ADD      r6,r1,r0,LSL #2
;;;1550           ptcb1->OSTCBNext = ptcb2;
000038  615e              STR      r6,[r3,#0x14]
;;;1551   #if OS_TASK_NAME_EN > 0u
;;;1552           ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00003a  a00e              ADR      r0,|L18.116|
00003c  64d8              STR      r0,[r3,#0x4c]
00003e  1c60              ADDS     r0,r4,#1              ;1546
000040  b2c4              UXTB     r4,r0                 ;1546
                  |L18.66|
000042  2c06              CMP      r4,#6                 ;1546
000044  d3e9              BCC      |L18.26|
;;;1553   #endif
;;;1554       }
;;;1555       ptcb1                   = &OSTCBTbl[ix];
000046  ebc400c4          RSB      r0,r4,r4,LSL #3
00004a  eb000040          ADD      r0,r0,r0,LSL #1
00004e  4907              LDR      r1,|L18.108|
000050  eb010380          ADD      r3,r1,r0,LSL #2
;;;1556       ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000054  2000              MOVS     r0,#0
000056  6158              STR      r0,[r3,#0x14]
;;;1557   #if OS_TASK_NAME_EN > 0u
;;;1558       ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
000058  a006              ADR      r0,|L18.116|
00005a  64d8              STR      r0,[r3,#0x4c]
;;;1559   #endif
;;;1560       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00005c  2000              MOVS     r0,#0
00005e  4906              LDR      r1,|L18.120|
000060  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1561       OSTCBFreeList           = &OSTCBTbl[0];
000062  4802              LDR      r0,|L18.108|
000064  4905              LDR      r1,|L18.124|
000066  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1562   }
000068  bd70              POP      {r4-r6,pc}
;;;1563   /*$PAGE*/
                          ENDP

00006a  0000              DCW      0x0000
                  |L18.108|
                          DCD      OSTCBTbl
                  |L18.112|
                          DCD      OSTCBPrioTbl
                  |L18.116|
000074  3f00              DCB      "?",0
000076  00                DCB      0
000077  00                DCB      0
                  |L18.120|
                          DCD      OSTCBList
                  |L18.124|
                          DCD      OSTCBFreeList

                          AREA ||i.OS_InitTaskIdle||, CODE, READONLY, ALIGN=2

                  OS_InitTaskIdle PROC
;;;1411   
;;;1412   static  void  OS_InitTaskIdle (void)
000000  b500              PUSH     {lr}
;;;1413   {
000002  b087              SUB      sp,sp,#0x1c
;;;1414   #if OS_TASK_NAME_EN > 0u
;;;1415       INT8U  err;
;;;1416   #endif
;;;1417   
;;;1418   
;;;1419   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1420       #if OS_STK_GROWTH == 1u
;;;1421       (void)OSTaskCreateExt(OS_TaskIdle,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L19.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70ff          MOV      r0,#0xffff
000018  233f              MOVS     r3,#0x3f
00001a  4a07              LDR      r2,|L19.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L19.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1422                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1423                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
;;;1424                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1425                             OS_TASK_IDLE_ID,
;;;1426                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1427                             OS_TASK_IDLE_STK_SIZE,
;;;1428                             (void *)0,                                 /* No TCB extension                     */
;;;1429                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1430       #else
;;;1431       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1432                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1433                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1434                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1435                             OS_TASK_IDLE_ID,
;;;1436                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
;;;1437                             OS_TASK_IDLE_STK_SIZE,
;;;1438                             (void *)0,                                 /* No TCB extension                     */
;;;1439                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1440       #endif
;;;1441   #else
;;;1442       #if OS_STK_GROWTH == 1u
;;;1443       (void)OSTaskCreate(OS_TaskIdle,
;;;1444                          (void *)0,
;;;1445                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
;;;1446                          OS_TASK_IDLE_PRIO);
;;;1447       #else
;;;1448       (void)OSTaskCreate(OS_TaskIdle,
;;;1449                          (void *)0,
;;;1450                          &OSTaskIdleStk[0],
;;;1451                          OS_TASK_IDLE_PRIO);
;;;1452       #endif
;;;1453   #endif
;;;1454   
;;;1455   #if OS_TASK_NAME_EN > 0u
;;;1456       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L19.64|
000028  203f              MOVS     r0,#0x3f
00002a  f7fffffe          BL       OSTaskNameSet
;;;1457   #endif
;;;1458   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1459   /*$PAGE*/
                          ENDP

000032  0000              DCW      0x0000
                  |L19.52|
                          DCD      OSTaskIdleStk
                  |L19.56|
                          DCD      OSTaskIdleStk+0x1fc
                  |L19.60|
                          DCD      OS_TaskIdle
                  |L19.64|
000040  75432f4f          DCB      "uC/OS-II Idle",0
000044  532d4949
000048  2049646c
00004c  6500    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_InitTaskStat||, CODE, READONLY, ALIGN=2

                  OS_InitTaskStat PROC
;;;1473   #if OS_TASK_STAT_EN > 0u
;;;1474   static  void  OS_InitTaskStat (void)
000000  b500              PUSH     {lr}
;;;1475   {
000002  b087              SUB      sp,sp,#0x1c
;;;1476   #if OS_TASK_NAME_EN > 0u
;;;1477       INT8U  err;
;;;1478   #endif
;;;1479   
;;;1480   
;;;1481   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1482       #if OS_STK_GROWTH == 1u
;;;1483       (void)OSTaskCreateExt(OS_TaskStat,
000004  2003              MOVS     r0,#3
000006  2100              MOVS     r1,#0
000008  2280              MOVS     r2,#0x80
00000a  4b0a              LDR      r3,|L20.52|
00000c  e9cd3201          STRD     r3,r2,[sp,#4]
000010  e9cd1003          STRD     r1,r0,[sp,#0xc]
000014  f64f70fe          MOV      r0,#0xfffe
000018  233e              MOVS     r3,#0x3e
00001a  4a07              LDR      r2,|L20.56|
00001c  9000              STR      r0,[sp,#0]
00001e  4807              LDR      r0,|L20.60|
000020  f7fffffe          BL       OSTaskCreateExt
;;;1484                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1485                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
;;;1486                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1487                             OS_TASK_STAT_ID,
;;;1488                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1489                             OS_TASK_STAT_STK_SIZE,
;;;1490                             (void *)0,                                   /* No TCB extension               */
;;;1491                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1492       #else
;;;1493       (void)OSTaskCreateExt(OS_TaskStat,
;;;1494                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1495                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1496                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1497                             OS_TASK_STAT_ID,
;;;1498                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
;;;1499                             OS_TASK_STAT_STK_SIZE,
;;;1500                             (void *)0,                                   /* No TCB extension               */
;;;1501                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1502       #endif
;;;1503   #else
;;;1504       #if OS_STK_GROWTH == 1u
;;;1505       (void)OSTaskCreate(OS_TaskStat,
;;;1506                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1507                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
;;;1508                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1509       #else
;;;1510       (void)OSTaskCreate(OS_TaskStat,
;;;1511                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1512                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1513                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1514       #endif
;;;1515   #endif
;;;1516   
;;;1517   #if OS_TASK_NAME_EN > 0u
;;;1518       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000024  aa06              ADD      r2,sp,#0x18
000026  a106              ADR      r1,|L20.64|
000028  203e              MOVS     r0,#0x3e
00002a  f7fffffe          BL       OSTaskNameSet
;;;1519   #endif
;;;1520   }
00002e  b007              ADD      sp,sp,#0x1c
000030  bd00              POP      {pc}
;;;1521   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L20.52|
                          DCD      OSTaskStatStk
                  |L20.56|
                          DCD      OSTaskStatStk+0x1fc
                  |L20.60|
                          DCD      OS_TaskStat
                  |L20.64|
000040  75432f4f          DCB      "uC/OS-II Stat",0
000044  532d4949
000048  20537461
00004c  7400    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1583   
;;;1584   void  OS_MemClr (INT8U  *pdest,
000000  e004              B        |L21.12|
                  |L21.2|
;;;1585                    INT16U  size)
;;;1586   {
;;;1587       while (size > 0u) {
;;;1588           *pdest++ = (INT8U)0;
000002  2200              MOVS     r2,#0
000004  f8002b01          STRB     r2,[r0],#1
;;;1589           size--;
000008  1e4a              SUBS     r2,r1,#1
00000a  b291              UXTH     r1,r2
                  |L21.12|
00000c  2900              CMP      r1,#0                 ;1587
00000e  d1f8              BNE      |L21.2|
;;;1590       }
;;;1591   }
000010  4770              BX       lr
;;;1592   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1616   
;;;1617   void  OS_MemCopy (INT8U  *pdest,
000000  e005              B        |L22.14|
                  |L22.2|
;;;1618                     INT8U  *psrc,
;;;1619                     INT16U  size)
;;;1620   {
;;;1621       while (size > 0u) {
;;;1622           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
;;;1623           size--;
00000a  1e53              SUBS     r3,r2,#1
00000c  b29a              UXTH     r2,r3
                  |L22.14|
00000e  2a00              CMP      r2,#0                 ;1621
000010  d1f7              BNE      |L22.2|
;;;1624       }
;;;1625   }
000012  4770              BX       lr
;;;1626   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1643   
;;;1644   void  OS_Sched (void)
000000  b510              PUSH     {r4,lr}
;;;1645   {
;;;1646   #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;1647       OS_CPU_SR  cpu_sr = 0u;
000002  2400              MOVS     r4,#0
;;;1648   #endif
;;;1649   
;;;1650   
;;;1651   
;;;1652       OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4604              MOV      r4,r0
;;;1653       if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
00000a  4813              LDR      r0,|L23.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b9f8              CBNZ     r0,|L23.80|
;;;1654           if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
000010  4812              LDR      r0,|L23.92|
000012  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000014  b9e0              CBNZ     r0,|L23.80|
;;;1655               OS_SchedNew();
000016  f7fffffe          BL       OS_SchedNew
;;;1656               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001a  4811              LDR      r0,|L23.96|
00001c  4911              LDR      r1,|L23.100|
00001e  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000020  f8500021          LDR      r0,[r0,r1,LSL #2]
000024  4910              LDR      r1,|L23.104|
000026  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1657               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
000028  480e              LDR      r0,|L23.100|
00002a  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00002c  490f              LDR      r1,|L23.108|
00002e  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000030  4288              CMP      r0,r1
000032  d00d              BEQ      |L23.80|
;;;1658   #if OS_TASK_PROFILE_EN > 0u
;;;1659                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000034  480c              LDR      r0,|L23.104|
000036  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
000038  6b80              LDR      r0,[r0,#0x38]
00003a  1c40              ADDS     r0,r0,#1
00003c  490a              LDR      r1,|L23.104|
00003e  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000040  6388              STR      r0,[r1,#0x38]
;;;1660   #endif
;;;1661                   OSCtxSwCtr++;                          /* Increment context switch counter             */
000042  480b              LDR      r0,|L23.112|
000044  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000046  1c40              ADDS     r0,r0,#1
000048  4909              LDR      r1,|L23.112|
00004a  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1662                   OS_TASK_SW();                          /* Perform a context switch                     */
00004c  f7fffffe          BL       OSCtxSw
                  |L23.80|
;;;1663               }
;;;1664           }
;;;1665       }
;;;1666       OS_EXIT_CRITICAL();
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       OS_CPU_SR_Restore
;;;1667   }
000056  bd10              POP      {r4,pc}
;;;1668   
                          ENDP

                  |L23.88|
                          DCD      OSIntNesting
                  |L23.92|
                          DCD      OSLockNesting
                  |L23.96|
                          DCD      OSTCBPrioTbl
                  |L23.100|
                          DCD      OSPrioHighRdy
                  |L23.104|
                          DCD      OSTCBHighRdy
                  |L23.108|
                          DCD      OSPrioCur
                  |L23.112|
                          DCD      OSCtxSwCtr

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1685   
;;;1686   static  void  OS_SchedNew (void)
000000  4906              LDR      r1,|L24.28|
;;;1687   {
;;;1688   #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
;;;1689       INT8U   y;
;;;1690   
;;;1691   
;;;1692       y             = OSUnMapTbl[OSRdyGrp];
000002  4a07              LDR      r2,|L24.32|
000004  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000006  5c88              LDRB     r0,[r1,r2]
;;;1693       OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
000008  4906              LDR      r1,|L24.36|
00000a  5c09              LDRB     r1,[r1,r0]
00000c  4a03              LDR      r2,|L24.28|
00000e  5c51              LDRB     r1,[r2,r1]
000010  eb0101c0          ADD      r1,r1,r0,LSL #3
000014  4a04              LDR      r2,|L24.40|
000016  7011              STRB     r1,[r2,#0]
;;;1694   #else                                            /* We support up to 256 tasks                         */
;;;1695       INT8U     y;
;;;1696       OS_PRIO  *ptbl;
;;;1697   
;;;1698   
;;;1699       if ((OSRdyGrp & 0xFFu) != 0u) {
;;;1700           y = OSUnMapTbl[OSRdyGrp & 0xFFu];
;;;1701       } else {
;;;1702           y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
;;;1703       }
;;;1704       ptbl = &OSRdyTbl[y];
;;;1705       if ((*ptbl & 0xFFu) != 0u) {
;;;1706           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
;;;1707       } else {
;;;1708           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
;;;1709       }
;;;1710   #endif
;;;1711   }
000018  4770              BX       lr
;;;1712   
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      OSUnMapTbl
                  |L24.32|
                          DCD      OSRdyGrp
                  |L24.36|
                          DCD      OSRdyTbl
                  |L24.40|
                          DCD      OSPrioHighRdy

                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1730   #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
;;;1731   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1732   {
;;;1733       INT8U  len;
;;;1734   
;;;1735   
;;;1736   #if OS_ARG_CHK_EN > 0u
;;;1737       if (psrc == (INT8U *)0) {
;;;1738           return (0u);
;;;1739       }
;;;1740   #endif
;;;1741   
;;;1742       len = 0u;
000002  2000              MOVS     r0,#0
;;;1743       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L25.12|
                  |L25.6|
;;;1744           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1745           len++;
000008  1c42              ADDS     r2,r0,#1
00000a  b2d0              UXTB     r0,r2
                  |L25.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1743
00000e  2a00              CMP      r2,#0                 ;1743
000010  d1f9              BNE      |L25.6|
;;;1746       }
;;;1747       return (len);
;;;1748   }
000012  4770              BX       lr
;;;1749   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1939   
;;;1940   INT8U  OS_TCBInit (INT8U    prio,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1941                      OS_STK  *ptos,
;;;1942                      OS_STK  *pbos,
;;;1943                      INT16U   id,
;;;1944                      INT32U   stk_size,
;;;1945                      void    *pext,
;;;1946                      INT16U   opt)
;;;1947   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
;;;1948       OS_TCB    *ptcb;
;;;1949   #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;1950       OS_CPU_SR  cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;1951   #endif
;;;1952   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1953       INT8U      i;
;;;1954   #endif
;;;1955   
;;;1956   
;;;1957       OS_ENTER_CRITICAL();
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  9000              STR      r0,[sp,#0]
;;;1958       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001a  4842              LDR      r0,|L26.292|
00001c  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1959       if (ptcb != (OS_TCB *)0) {
00001e  2c00              CMP      r4,#0
000020  d07a              BEQ      |L26.280|
;;;1960           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000022  3418              ADDS     r4,r4,#0x18
000024  f8540c04          LDR      r0,[r4,#-4]
000028  493e              LDR      r1,|L26.292|
00002a  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1961           OS_EXIT_CRITICAL();
00002c  9800              LDR      r0,[sp,#0]
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1962           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000032  f8447c18          STR      r7,[r4,#-0x18]
;;;1963           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
000036  76a5              STRB     r5,[r4,#0x1a]
;;;1964           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000038  2000              MOVS     r0,#0
00003a  7620              STRB     r0,[r4,#0x18]
;;;1965           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
00003c  7660              STRB     r0,[r4,#0x19]
;;;1966           ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00003e  6160              STR      r0,[r4,#0x14]
;;;1967   
;;;1968   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1969           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000040  f844bc14          STR      r11,[r4,#-0x14]
;;;1970           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000044  f844ac0c          STR      r10,[r4,#-0xc]
;;;1971           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000048  f8448c10          STR      r8,[r4,#-0x10]
;;;1972           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
00004c  980c              LDR      r0,[sp,#0x30]
00004e  f8240c08          STRH     r0,[r4,#-8]
;;;1973           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000052  f8249c06          STRH     r9,[r4,#-6]
;;;1974   #else
;;;1975           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1976           stk_size                 = stk_size;
;;;1977           pbos                     = pbos;
;;;1978           opt                      = opt;
;;;1979           id                       = id;
;;;1980   #endif
;;;1981   
;;;1982   #if OS_TASK_DEL_EN > 0u
;;;1983           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000056  2000              MOVS     r0,#0
000058  77e0              STRB     r0,[r4,#0x1f]
;;;1984   #endif
;;;1985   
;;;1986   #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
;;;1987           ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00005a  10e8              ASRS     r0,r5,#3
00005c  7720              STRB     r0,[r4,#0x1c]
;;;1988           ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00005e  f0050007          AND      r0,r5,#7
000062  76e0              STRB     r0,[r4,#0x1b]
;;;1989   #else                                                             /* Pre-compute X, Y                  */
;;;1990           ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
;;;1991           ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
;;;1992   #endif
;;;1993                                                                     /* Pre-compute BitX and BitY         */
;;;1994           ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000064  7f21              LDRB     r1,[r4,#0x1c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  77a0              STRB     r0,[r4,#0x1e]
;;;1995           ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
00006c  7ee1              LDRB     r1,[r4,#0x1b]
00006e  2001              MOVS     r0,#1
000070  4088              LSLS     r0,r0,r1
000072  7760              STRB     r0,[r4,#0x1d]
;;;1996   
;;;1997   #if (OS_EVENT_EN)
;;;1998           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000074  2000              MOVS     r0,#0
000076  6060              STR      r0,[r4,#4]
;;;1999   #if (OS_EVENT_MULTI_EN > 0u)
;;;2000           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
;;;2001   #endif
;;;2002   #endif
;;;2003   
;;;2004   #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
;;;2005           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000078  60e0              STR      r0,[r4,#0xc]
;;;2006   #endif
;;;2007   
;;;2008   #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;2009           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00007a  60a0              STR      r0,[r4,#8]
;;;2010   #endif
;;;2011   
;;;2012   #if OS_TASK_PROFILE_EN > 0u
;;;2013           ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
00007c  6220              STR      r0,[r4,#0x20]
;;;2014           ptcb->OSTCBCyclesStart = 0uL;
00007e  62a0              STR      r0,[r4,#0x28]
;;;2015           ptcb->OSTCBCyclesTot   = 0uL;
000080  6260              STR      r0,[r4,#0x24]
;;;2016           ptcb->OSTCBStkBase     = (OS_STK *)0;
000082  62e0              STR      r0,[r4,#0x2c]
;;;2017           ptcb->OSTCBStkUsed     = 0uL;
000084  6320              STR      r0,[r4,#0x30]
;;;2018   #endif
;;;2019   
;;;2020   #if OS_TASK_NAME_EN > 0u
;;;2021           ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
000086  a028              ADR      r0,|L26.296|
000088  6360              STR      r0,[r4,#0x34]
00008a  3c18              SUBS     r4,r4,#0x18
;;;2022   #endif
;;;2023   
;;;2024   #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
;;;2025           for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00008c  2600              MOVS     r6,#0
00008e  e006              B        |L26.158|
                  |L26.144|
;;;2026               ptcb->OSTCBRegTbl[i] = 0u;
000090  2100              MOVS     r1,#0
000092  f1040050          ADD      r0,r4,#0x50
000096  f8401026          STR      r1,[r0,r6,LSL #2]
00009a  1c70              ADDS     r0,r6,#1              ;2025
00009c  b2c6              UXTB     r6,r0                 ;2025
                  |L26.158|
00009e  2e01              CMP      r6,#1                 ;2025
0000a0  dbf6              BLT      |L26.144|
;;;2027           }
;;;2028   #endif
;;;2029   
;;;2030           OSTCBInitHook(ptcb);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       OSTCBInitHook
;;;2031   
;;;2032           OS_ENTER_CRITICAL();
0000a8  f7fffffe          BL       OS_CPU_SR_Save
0000ac  9000              STR      r0,[sp,#0]
;;;2033           OSTCBPrioTbl[prio] = ptcb;
0000ae  481f              LDR      r0,|L26.300|
0000b0  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2034           OS_EXIT_CRITICAL();
0000b4  9800              LDR      r0,[sp,#0]
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
;;;2035   
;;;2036           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       OSTaskCreateHook
;;;2037   
;;;2038           OS_ENTER_CRITICAL();
0000c0  f7fffffe          BL       OS_CPU_SR_Save
0000c4  9000              STR      r0,[sp,#0]
;;;2039           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
0000c6  481a              LDR      r0,|L26.304|
0000c8  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000ca  6160              STR      r0,[r4,#0x14]
;;;2040           ptcb->OSTCBPrev    = (OS_TCB *)0;
0000cc  2000              MOVS     r0,#0
0000ce  61a0              STR      r0,[r4,#0x18]
;;;2041           if (OSTCBList != (OS_TCB *)0) {
0000d0  4817              LDR      r0,|L26.304|
0000d2  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000d4  b110              CBZ      r0,|L26.220|
;;;2042               OSTCBList->OSTCBPrev = ptcb;
0000d6  4816              LDR      r0,|L26.304|
0000d8  6800              LDR      r0,[r0,#0]  ; OSTCBList
0000da  6184              STR      r4,[r0,#0x18]
                  |L26.220|
;;;2043           }
;;;2044           OSTCBList               = ptcb;
0000dc  4814              LDR      r0,|L26.304|
0000de  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2045           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000e0  3434              ADDS     r4,r4,#0x34
0000e2  78a0              LDRB     r0,[r4,#2]
0000e4  4913              LDR      r1,|L26.308|
0000e6  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
0000e8  4308              ORRS     r0,r0,r1
0000ea  4912              LDR      r1,|L26.308|
0000ec  7008              STRB     r0,[r1,#0]
;;;2046           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000ee  7820              LDRB     r0,[r4,#0]
0000f0  4911              LDR      r1,|L26.312|
0000f2  5c08              LDRB     r0,[r1,r0]
0000f4  7861              LDRB     r1,[r4,#1]
0000f6  4308              ORRS     r0,r0,r1
0000f8  f8141934          LDRB     r1,[r4],#-0x34
0000fc  4a0e              LDR      r2,|L26.312|
0000fe  5450              STRB     r0,[r2,r1]
;;;2047           OSTaskCtr++;                                       /* Increment the #tasks counter             */
000100  480e              LDR      r0,|L26.316|
000102  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
000104  1c40              ADDS     r0,r0,#1
000106  490d              LDR      r1,|L26.316|
000108  7008              STRB     r0,[r1,#0]
;;;2048           OS_EXIT_CRITICAL();
00010a  9800              LDR      r0,[sp,#0]
00010c  f7fffffe          BL       OS_CPU_SR_Restore
;;;2049           return (OS_ERR_NONE);
000110  2000              MOVS     r0,#0
                  |L26.274|
;;;2050       }
;;;2051       OS_EXIT_CRITICAL();
;;;2052       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2053   }
000112  e8bd8ff8          POP      {r3-r11,pc}
000116  e7ff              B        |L26.280|
                  |L26.280|
000118  9800              LDR      r0,[sp,#0]            ;2051
00011a  f7fffffe          BL       OS_CPU_SR_Restore
00011e  2042              MOVS     r0,#0x42              ;2052
000120  e7f7              B        |L26.274|
                          ENDP

000122  0000              DCW      0x0000
                  |L26.292|
                          DCD      OSTCBFreeList
                  |L26.296|
000128  3f00              DCB      "?",0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L26.300|
                          DCD      OSTCBPrioTbl
                  |L26.304|
                          DCD      OSTCBList
                  |L26.308|
                          DCD      OSRdyGrp
                  |L26.312|
                          DCD      OSRdyTbl
                  |L26.316|
                          DCD      OSTaskCtr

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1771   
;;;1772   void  OS_TaskIdle (void *p_arg)
000000  2400              MOVS     r4,#0
;;;1773   {
;;;1774   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1775       OS_CPU_SR  cpu_sr = 0u;
;;;1776   #endif
;;;1777   
;;;1778   
;;;1779   
;;;1780       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1781       for (;;) {
000004  bf00              NOP      
                  |L27.6|
;;;1782           OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4604              MOV      r4,r0
;;;1783           OSIdleCtr++;
00000c  4805              LDR      r0,|L27.36|
00000e  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000010  1c40              ADDS     r0,r0,#1
000012  4904              LDR      r1,|L27.36|
000014  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1784           OS_EXIT_CRITICAL();
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       OS_CPU_SR_Restore
;;;1785           OSTaskIdleHook();                        /* Call user definable HOOK                           */
00001c  f7fffffe          BL       OSTaskIdleHook
000020  e7f1              B        |L27.6|
;;;1786       }
;;;1787   }
;;;1788   /*$PAGE*/
                          ENDP

000022  0000              DCW      0x0000
                  |L27.36|
                          DCD      OSIdleCtr

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1813   #if OS_TASK_STAT_EN > 0u
;;;1814   void  OS_TaskStat (void *p_arg)
000000  bf00              NOP      
;;;1815   {
;;;1816   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1817       OS_CPU_SR  cpu_sr = 0u;
;;;1818   #endif
;;;1819   
;;;1820   
;;;1821   
;;;1822       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
000002  bf00              NOP      
;;;1823       while (OSStatRdy == OS_FALSE) {
000004  e002              B        |L28.12|
                  |L28.6|
;;;1824           OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000006  2028              MOVS     r0,#0x28
000008  f7fffffe          BL       OSTimeDly
                  |L28.12|
00000c  481f              LDR      r0,|L28.140|
00000e  7800              LDRB     r0,[r0,#0]            ;1823  ; OSStatRdy
000010  2800              CMP      r0,#0                 ;1823
000012  d0f8              BEQ      |L28.6|
;;;1825       }
;;;1826       OSIdleCtrMax /= 100uL;
000014  481e              LDR      r0,|L28.144|
000016  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000018  2164              MOVS     r1,#0x64
00001a  fbb0f0f1          UDIV     r0,r0,r1
00001e  491c              LDR      r1,|L28.144|
000020  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1827       if (OSIdleCtrMax == 0uL) {
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
000026  b928              CBNZ     r0,|L28.52|
;;;1828           OSCPUUsage = 0u;
000028  2000              MOVS     r0,#0
00002a  491a              LDR      r1,|L28.148|
00002c  7008              STRB     r0,[r1,#0]
;;;1829   #if OS_TASK_SUSPEND_EN > 0u
;;;1830           (void)OSTaskSuspend(OS_PRIO_SELF);
00002e  20ff              MOVS     r0,#0xff
000030  f7fffffe          BL       OSTaskSuspend
                  |L28.52|
;;;1831   #else
;;;1832           for (;;) {
;;;1833               OSTimeDly(OS_TICKS_PER_SEC);
;;;1834           }
;;;1835   #endif
;;;1836       }
;;;1837       OS_ENTER_CRITICAL();
000034  f7fffffe          BL       OS_CPU_SR_Save
000038  4604              MOV      r4,r0
;;;1838       OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
00003a  4815              LDR      r0,|L28.144|
00003c  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
00003e  2164              MOVS     r1,#0x64
000040  4348              MULS     r0,r1,r0
000042  4915              LDR      r1,|L28.152|
000044  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1839       OS_EXIT_CRITICAL();
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OS_CPU_SR_Restore
;;;1840       for (;;) {
00004c  bf00              NOP      
                  |L28.78|
;;;1841           OS_ENTER_CRITICAL();
00004e  f7fffffe          BL       OS_CPU_SR_Save
000052  4604              MOV      r4,r0
;;;1842           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
000054  4810              LDR      r0,|L28.152|
000056  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000058  4910              LDR      r1,|L28.156|
00005a  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1843           OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00005c  2000              MOVS     r0,#0
00005e  490e              LDR      r1,|L28.152|
000060  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1844           OS_EXIT_CRITICAL();
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       OS_CPU_SR_Restore
;;;1845           OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
000068  480c              LDR      r0,|L28.156|
00006a  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
00006c  4908              LDR      r1,|L28.144|
00006e  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
000070  fbb0f0f1          UDIV     r0,r0,r1
000074  f1c00064          RSB      r0,r0,#0x64
000078  4906              LDR      r1,|L28.148|
00007a  7008              STRB     r0,[r1,#0]
;;;1846           OSTaskStatHook();                        /* Invoke user definable hook                         */
00007c  f7fffffe          BL       OSTaskStatHook
;;;1847   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1848           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000080  f7fffffe          BL       OS_TaskStatStkChk
;;;1849   #endif
;;;1850           OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
000084  2014              MOVS     r0,#0x14
000086  f7fffffe          BL       OSTimeDly
00008a  e7e0              B        |L28.78|
;;;1851       }
;;;1852   }
;;;1853   #endif
                          ENDP

                  |L28.140|
                          DCD      OSStatRdy
                  |L28.144|
                          DCD      OSIdleCtrMax
                  |L28.148|
                          DCD      OSCPUUsage
                  |L28.152|
                          DCD      OSIdleCtr
                  |L28.156|
                          DCD      OSIdleCtrRun

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1867   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1868   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1869   {
;;;1870       OS_TCB      *ptcb;
;;;1871       OS_STK_DATA  stk_data;
;;;1872       INT8U        err;
;;;1873       INT8U        prio;
;;;1874   
;;;1875   
;;;1876       for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
000002  2500              MOVS     r5,#0
000004  e014              B        |L29.48|
                  |L29.6|
;;;1877           err = OSTaskStkChk(prio, &stk_data);
000006  4669              MOV      r1,sp
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       OSTaskStkChk
00000e  4606              MOV      r6,r0
;;;1878           if (err == OS_ERR_NONE) {
000010  b966              CBNZ     r6,|L29.44|
;;;1879               ptcb = OSTCBPrioTbl[prio];
000012  4809              LDR      r0,|L29.56|
000014  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1880               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000018  b144              CBZ      r4,|L29.44|
;;;1881                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
00001a  2c01              CMP      r4,#1
00001c  d006              BEQ      |L29.44|
;;;1882   #if OS_TASK_PROFILE_EN > 0u
;;;1883                       #if OS_STK_GROWTH == 1u
;;;1884                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  e9d40102          LDRD     r0,r1,[r4,#8]
000022  eb000081          ADD      r0,r0,r1,LSL #2
000026  6460              STR      r0,[r4,#0x44]
;;;1885                       #else
;;;1886                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1887                       #endif
;;;1888                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
000028  9801              LDR      r0,[sp,#4]
00002a  64a0              STR      r0,[r4,#0x48]
                  |L29.44|
00002c  1c68              ADDS     r0,r5,#1              ;1876
00002e  b2c5              UXTB     r5,r0                 ;1876
                  |L29.48|
000030  2d3f              CMP      r5,#0x3f              ;1876
000032  dde8              BLE      |L29.6|
;;;1889   #endif
;;;1890                   }
;;;1891               }
;;;1892           }
;;;1893       }
;;;1894   }
000034  bd7c              POP      {r2-r6,pc}
;;;1895   #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
                          DCD      OSTCBPrioTbl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        200
                  OSFlagTbl
                          %        80
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        256
                  OSTCBTbl
                          %        588
                  OSQTbl
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000000
000024  0000              DCB      0x00,0x00
                  OSRunning
000026  00                DCB      0x00
                  OSTaskCtr
000027  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
00003c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSQFreeList
                          DCD      0x00000000
                  OSTaskRegNextAvailID
000044  00000000          DCB      0x00,0x00,0x00,0x00
                  OSTime
                          DCD      0x00000000
                  T5ms
                          DCD      0x00000000
