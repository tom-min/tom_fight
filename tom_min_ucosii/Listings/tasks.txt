; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\tasks.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tasks.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\FreeRTOS\include -I.\FreeRTOS\portable\RVDS\ARM_CM3 -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\tasks.crf FreeRTOS\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1377   
;;;1378   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1379   	{
000004  4607              MOV      r7,r0
;;;1380   	eTaskState eReturn;
;;;1381   	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
;;;1382   	const TCB_t * const pxTCB = xTask;
000006  463e              MOV      r6,r7
;;;1383   
;;;1384   		configASSERT( pxTCB );
;;;1385   
;;;1386   		if( pxTCB == pxCurrentTCB )
000008  4817              LDR      r0,|L1.104|
00000a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000c  4286              CMP      r6,r0
00000e  d101              BNE      |L1.20|
;;;1387   		{
;;;1388   			/* The task calling this function is querying its own state. */
;;;1389   			eReturn = eRunning;
000010  2400              MOVS     r4,#0
000012  e026              B        |L1.98|
                  |L1.20|
;;;1390   		}
;;;1391   		else
;;;1392   		{
;;;1393   			taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;1394   			{
;;;1395   				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
000018  6975              LDR      r5,[r6,#0x14]
;;;1396   				pxDelayedList = pxDelayedTaskList;
00001a  4814              LDR      r0,|L1.108|
00001c  f8d09000          LDR      r9,[r0,#0]  ; pxDelayedTaskList
;;;1397   				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
000020  4813              LDR      r0,|L1.112|
000022  f8d08000          LDR      r8,[r0,#0]  ; pxOverflowDelayedTaskList
;;;1398   			}
;;;1399   			taskEXIT_CRITICAL();
000026  f7fffffe          BL       vPortExitCritical
;;;1400   
;;;1401   			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
00002a  454d              CMP      r5,r9
00002c  d001              BEQ      |L1.50|
00002e  4545              CMP      r5,r8
000030  d101              BNE      |L1.54|
                  |L1.50|
;;;1402   			{
;;;1403   				/* The task being queried is referenced from one of the Blocked
;;;1404   				lists. */
;;;1405   				eReturn = eBlocked;
000032  2402              MOVS     r4,#2
000034  e015              B        |L1.98|
                  |L1.54|
;;;1406   			}
;;;1407   
;;;1408   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1409   				else if( pxStateList == &xSuspendedTaskList )
000036  480f              LDR      r0,|L1.116|
000038  4285              CMP      r5,r0
00003a  d10b              BNE      |L1.84|
;;;1410   				{
;;;1411   					/* The task being queried is referenced from the suspended
;;;1412   					list.  Is it genuinely suspended or is it blocked
;;;1413   					indefinitely? */
;;;1414   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
00003c  6ab0              LDR      r0,[r6,#0x28]
00003e  b938              CBNZ     r0,|L1.80|
;;;1415   					{
;;;1416   						#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1417   						{
;;;1418   							/* The task does not appear on the event list item of
;;;1419   							and of the RTOS objects, but could still be in the
;;;1420   							blocked state if it is waiting on its notification
;;;1421   							rather than waiting on an object. */
;;;1422   							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000040  f8960048          LDRB     r0,[r6,#0x48]
000044  2801              CMP      r0,#1
000046  d101              BNE      |L1.76|
;;;1423   							{
;;;1424   								eReturn = eBlocked;
000048  2402              MOVS     r4,#2
00004a  e00a              B        |L1.98|
                  |L1.76|
;;;1425   							}
;;;1426   							else
;;;1427   							{
;;;1428   								eReturn = eSuspended;
00004c  2403              MOVS     r4,#3
00004e  e008              B        |L1.98|
                  |L1.80|
;;;1429   							}
;;;1430   						}
;;;1431   						#else
;;;1432   						{
;;;1433   							eReturn = eSuspended;
;;;1434   						}
;;;1435   						#endif
;;;1436   					}
;;;1437   					else
;;;1438   					{
;;;1439   						eReturn = eBlocked;
000050  2402              MOVS     r4,#2
000052  e006              B        |L1.98|
                  |L1.84|
;;;1440   					}
;;;1441   				}
;;;1442   			#endif
;;;1443   
;;;1444   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1445   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
000054  4808              LDR      r0,|L1.120|
000056  4285              CMP      r5,r0
000058  d000              BEQ      |L1.92|
00005a  b90d              CBNZ     r5,|L1.96|
                  |L1.92|
;;;1446   				{
;;;1447   					/* The task being queried is referenced from the deleted
;;;1448   					tasks list, or it is not referenced from any lists at
;;;1449   					all. */
;;;1450   					eReturn = eDeleted;
00005c  2404              MOVS     r4,#4
00005e  e000              B        |L1.98|
                  |L1.96|
;;;1451   				}
;;;1452   			#endif
;;;1453   
;;;1454   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1455   			{
;;;1456   				/* If the task is not in any other state, it must be in the
;;;1457   				Ready (including pending ready) state. */
;;;1458   				eReturn = eReady;
000060  2401              MOVS     r4,#1
                  |L1.98|
;;;1459   			}
;;;1460   		}
;;;1461   
;;;1462   		return eReturn;
000062  4620              MOV      r0,r4
;;;1463   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000064  e8bd87f0          POP      {r4-r10,pc}
;;;1464   
                          ENDP

                  |L1.104|
                          DCD      pxCurrentTCB
                  |L1.108|
                          DCD      pxDelayedTaskList
                  |L1.112|
                          DCD      pxOverflowDelayedTaskList
                  |L1.116|
                          DCD      xSuspendedTaskList
                  |L1.120|
                          DCD      xTasksWaitingTermination

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2336   
;;;2337   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;2338   {
;;;2339   TCB_t *pxTCB;
;;;2340   
;;;2341   	/* If null is passed in here then the name of the calling task is being
;;;2342   	queried. */
;;;2343   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000002  b911              CBNZ     r1,|L2.10|
000004  4803              LDR      r0,|L2.20|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000008  e000              B        |L2.12|
                  |L2.10|
00000a  4608              MOV      r0,r1
                  |L2.12|
00000c  4602              MOV      r2,r0
;;;2344   	configASSERT( pxTCB );
;;;2345   	return &( pxTCB->pcTaskName[ 0 ] );
00000e  f1020034          ADD      r0,r2,#0x34
;;;2346   }
000012  4770              BX       lr
;;;2347   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.20|
                          DCD      pxCurrentTCB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;5080   
;;;5081   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5082   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;5083   TickType_t xTimeToWake;
;;;5084   const TickType_t xConstTickCount = xTickCount;
000008  481c              LDR      r0,|L3.124|
00000a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;5085   
;;;5086   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;5087   	{
;;;5088   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;5089   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;5090   		when the task leaves the Blocked state. */
;;;5091   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;5092   	}
;;;5093   	#endif
;;;5094   
;;;5095   	/* Remove the task from the ready list before adding it to the blocked list
;;;5096   	as the same list item is used for both lists. */
;;;5097   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  481c              LDR      r0,|L3.128|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
000016  b950              CBNZ     r0,|L3.46|
;;;5098   	{
;;;5099   		/* The current task must be in a ready list, so there is no need to
;;;5100   		check, and the port reset macro can be called directly. */
;;;5101   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
000018  4819              LDR      r0,|L3.128|
00001a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  f890102c          LDRB     r1,[r0,#0x2c]
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  4917              LDR      r1,|L3.132|
000026  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000028  4381              BICS     r1,r1,r0
00002a  4816              LDR      r0,|L3.132|
00002c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L3.46|
;;;5102   	}
;;;5103   	else
;;;5104   	{
;;;5105   		mtCOVERAGE_TEST_MARKER();
;;;5106   	}
;;;5107   
;;;5108   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;5109   	{
;;;5110   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
00002e  1c68              ADDS     r0,r5,#1
000030  b938              CBNZ     r0,|L3.66|
000032  b136              CBZ      r6,|L3.66|
;;;5111   		{
;;;5112   			/* Add the task to the suspended task list instead of a delayed task
;;;5113   			list to ensure it is not woken by a timing event.  It will block
;;;5114   			indefinitely. */
;;;5115   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
000034  4812              LDR      r0,|L3.128|
000036  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000038  1d09              ADDS     r1,r1,#4
00003a  4813              LDR      r0,|L3.136|
00003c  f7fffffe          BL       vListInsertEnd
000040  e01a              B        |L3.120|
                  |L3.66|
;;;5116   		}
;;;5117   		else
;;;5118   		{
;;;5119   			/* Calculate the time at which the task should be woken if the event
;;;5120   			does not occur.  This may overflow but this doesn't matter, the
;;;5121   			kernel will manage it correctly. */
;;;5122   			xTimeToWake = xConstTickCount + xTicksToWait;
000042  197c              ADDS     r4,r7,r5
;;;5123   
;;;5124   			/* The list item will be inserted in wake time order. */
;;;5125   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
000044  480e              LDR      r0,|L3.128|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  6044              STR      r4,[r0,#4]
;;;5126   
;;;5127   			if( xTimeToWake < xConstTickCount )
00004a  42bc              CMP      r4,r7
00004c  d207              BCS      |L3.94|
;;;5128   			{
;;;5129   				/* Wake time has overflowed.  Place this item in the overflow
;;;5130   				list. */
;;;5131   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00004e  480c              LDR      r0,|L3.128|
000050  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000052  1d09              ADDS     r1,r1,#4
000054  480d              LDR      r0,|L3.140|
000056  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000058  f7fffffe          BL       vListInsert
00005c  e00c              B        |L3.120|
                  |L3.94|
;;;5132   			}
;;;5133   			else
;;;5134   			{
;;;5135   				/* The wake time has not overflowed, so the current block list
;;;5136   				is used. */
;;;5137   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
00005e  4808              LDR      r0,|L3.128|
000060  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000062  1d09              ADDS     r1,r1,#4
000064  480a              LDR      r0,|L3.144|
000066  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000068  f7fffffe          BL       vListInsert
;;;5138   
;;;5139   				/* If the task entering the blocked state was placed at the
;;;5140   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;5141   				needs to be updated too. */
;;;5142   				if( xTimeToWake < xNextTaskUnblockTime )
00006c  4809              LDR      r0,|L3.148|
00006e  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000070  4284              CMP      r4,r0
000072  d201              BCS      |L3.120|
;;;5143   				{
;;;5144   					xNextTaskUnblockTime = xTimeToWake;
000074  4807              LDR      r0,|L3.148|
000076  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L3.120|
;;;5145   				}
;;;5146   				else
;;;5147   				{
;;;5148   					mtCOVERAGE_TEST_MARKER();
;;;5149   				}
;;;5150   			}
;;;5151   		}
;;;5152   	}
;;;5153   	#else /* INCLUDE_vTaskSuspend */
;;;5154   	{
;;;5155   		/* Calculate the time at which the task should be woken if the event
;;;5156   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;5157   		will manage it correctly. */
;;;5158   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;5159   
;;;5160   		/* The list item will be inserted in wake time order. */
;;;5161   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;5162   
;;;5163   		if( xTimeToWake < xConstTickCount )
;;;5164   		{
;;;5165   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;5166   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5167   		}
;;;5168   		else
;;;5169   		{
;;;5170   			/* The wake time has not overflowed, so the current block list is used. */
;;;5171   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5172   
;;;5173   			/* If the task entering the blocked state was placed at the head of the
;;;5174   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;5175   			too. */
;;;5176   			if( xTimeToWake < xNextTaskUnblockTime )
;;;5177   			{
;;;5178   				xNextTaskUnblockTime = xTimeToWake;
;;;5179   			}
;;;5180   			else
;;;5181   			{
;;;5182   				mtCOVERAGE_TEST_MARKER();
;;;5183   			}
;;;5184   		}
;;;5185   
;;;5186   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;5187   		( void ) xCanBlockIndefinitely;
;;;5188   	}
;;;5189   	#endif /* INCLUDE_vTaskSuspend */
;;;5190   }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;5191   
                          ENDP

                  |L3.124|
                          DCD      xTickCount
                  |L3.128|
                          DCD      pxCurrentTCB
                  |L3.132|
                          DCD      uxTopReadyPriority
                  |L3.136|
                          DCD      xSuspendedTaskList
                  |L3.140|
                          DCD      pxOverflowDelayedTaskList
                  |L3.144|
                          DCD      pxDelayedTaskList
                  |L3.148|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;1071   
;;;1072   static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b510              PUSH     {r4,lr}
;;;1073   {
000002  4604              MOV      r4,r0
;;;1074   	/* Ensure interrupts don't access the task lists while the lists are being
;;;1075   	updated. */
;;;1076   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1077   	{
;;;1078   		uxCurrentNumberOfTasks++;
000008  4823              LDR      r0,|L4.152|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  4922              LDR      r1,|L4.152|
000010  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1079   		if( pxCurrentTCB == NULL )
000012  4822              LDR      r0,|L4.156|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  b940              CBNZ     r0,|L4.42|
;;;1080   		{
;;;1081   			/* There are no other tasks, or all the other tasks are in
;;;1082   			the suspended state - make this the current task. */
;;;1083   			pxCurrentTCB = pxNewTCB;
000018  4820              LDR      r0,|L4.156|
00001a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;1084   
;;;1085   			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L4.64|
;;;1086   			{
;;;1087   				/* This is the first task to be created so do the preliminary
;;;1088   				initialisation required.  We will not recover if this call
;;;1089   				fails, but we will report the failure. */
;;;1090   				prvInitialiseTaskLists();
000024  f7fffffe          BL       prvInitialiseTaskLists
000028  e00a              B        |L4.64|
                  |L4.42|
;;;1091   			}
;;;1092   			else
;;;1093   			{
;;;1094   				mtCOVERAGE_TEST_MARKER();
;;;1095   			}
;;;1096   		}
;;;1097   		else
;;;1098   		{
;;;1099   			/* If the scheduler is not already running, make this task the
;;;1100   			current task if it is the highest priority task to be created
;;;1101   			so far. */
;;;1102   			if( xSchedulerRunning == pdFALSE )
00002a  481d              LDR      r0,|L4.160|
00002c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00002e  b938              CBNZ     r0,|L4.64|
;;;1103   			{
;;;1104   				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000030  481a              LDR      r0,|L4.156|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  6ac0              LDR      r0,[r0,#0x2c]
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  4288              CMP      r0,r1
00003a  d801              BHI      |L4.64|
;;;1105   				{
;;;1106   					pxCurrentTCB = pxNewTCB;
00003c  4817              LDR      r0,|L4.156|
00003e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L4.64|
;;;1107   				}
;;;1108   				else
;;;1109   				{
;;;1110   					mtCOVERAGE_TEST_MARKER();
;;;1111   				}
;;;1112   			}
;;;1113   			else
;;;1114   			{
;;;1115   				mtCOVERAGE_TEST_MARKER();
;;;1116   			}
;;;1117   		}
;;;1118   
;;;1119   		uxTaskNumber++;
000040  4818              LDR      r0,|L4.164|
000042  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000044  1c40              ADDS     r0,r0,#1
000046  4917              LDR      r1,|L4.164|
000048  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1120   
;;;1121   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1122   		{
;;;1123   			/* Add a counter into the TCB for tracing only. */
;;;1124   			pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;1125   		}
;;;1126   		#endif /* configUSE_TRACE_FACILITY */
;;;1127   		traceTASK_CREATE( pxNewTCB );
;;;1128   
;;;1129   		prvAddTaskToReadyList( pxNewTCB );
00004a  f894102c          LDRB     r1,[r4,#0x2c]
00004e  2001              MOVS     r0,#1
000050  4088              LSLS     r0,r0,r1
000052  4915              LDR      r1,|L4.168|
000054  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000056  4308              ORRS     r0,r0,r1
000058  4913              LDR      r1,|L4.168|
00005a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00005c  6ae1              LDR      r1,[r4,#0x2c]
00005e  eb010181          ADD      r1,r1,r1,LSL #2
000062  4a12              LDR      r2,|L4.172|
000064  eb020081          ADD      r0,r2,r1,LSL #2
000068  1d21              ADDS     r1,r4,#4
00006a  f7fffffe          BL       vListInsertEnd
;;;1130   
;;;1131   		portSETUP_TCB( pxNewTCB );
;;;1132   	}
;;;1133   	taskEXIT_CRITICAL();
00006e  f7fffffe          BL       vPortExitCritical
;;;1134   
;;;1135   	if( xSchedulerRunning != pdFALSE )
000072  480b              LDR      r0,|L4.160|
000074  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000076  b168              CBZ      r0,|L4.148|
;;;1136   	{
;;;1137   		/* If the created task is of a higher priority than the current task
;;;1138   		then it should run now. */
;;;1139   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
000078  4808              LDR      r0,|L4.156|
00007a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00007c  6ac0              LDR      r0,[r0,#0x2c]
00007e  6ae1              LDR      r1,[r4,#0x2c]
000080  4288              CMP      r0,r1
000082  d207              BCS      |L4.148|
;;;1140   		{
;;;1141   			taskYIELD_IF_USING_PREEMPTION();
000084  f04f5080          MOV      r0,#0x10000000
000088  4909              LDR      r1,|L4.176|
00008a  6008              STR      r0,[r1,#0]
00008c  f3bf8f4f          DSB      
000090  f3bf8f6f          ISB      
                  |L4.148|
;;;1142   		}
;;;1143   		else
;;;1144   		{
;;;1145   			mtCOVERAGE_TEST_MARKER();
;;;1146   		}
;;;1147   	}
;;;1148   	else
;;;1149   	{
;;;1150   		mtCOVERAGE_TEST_MARKER();
;;;1151   	}
;;;1152   }
000094  bd10              POP      {r4,pc}
;;;1153   /*-----------------------------------------------------------*/
                          ENDP

000096  0000              DCW      0x0000
                  |L4.152|
                          DCD      uxCurrentNumberOfTasks
                  |L4.156|
                          DCD      pxCurrentTCB
                  |L4.160|
                          DCD      xSchedulerRunning
                  |L4.164|
                          DCD      uxTaskNumber
                  |L4.168|
                          DCD      uxTopReadyPriority
                  |L4.172|
                          DCD      pxReadyTasksLists
                  |L4.176|
                          DCD      0xe000ed04

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3577   
;;;3578   static void prvCheckTasksWaitingTermination( void )
000000  b510              PUSH     {r4,lr}
;;;3579   {
;;;3580   
;;;3581   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3582   
;;;3583   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3584   	{
;;;3585   		TCB_t *pxTCB;
;;;3586   
;;;3587   		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
;;;3588   		being called too often in the idle task. */
;;;3589   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000002  e016              B        |L5.50|
                  |L5.4|
;;;3590   		{
;;;3591   			taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;3592   			{
;;;3593   				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000008  480c              LDR      r0,|L5.60|
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;3594   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;3595   				--uxCurrentNumberOfTasks;
000014  480a              LDR      r0,|L5.64|
000016  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000018  1e40              SUBS     r0,r0,#1
00001a  4909              LDR      r1,|L5.64|
00001c  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3596   				--uxDeletedTasksWaitingCleanUp;
00001e  4809              LDR      r0,|L5.68|
000020  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000022  1e40              SUBS     r0,r0,#1
000024  4907              LDR      r1,|L5.68|
000026  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3597   			}
;;;3598   			taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;3599   
;;;3600   			prvDeleteTCB( pxTCB );
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvDeleteTCB
                  |L5.50|
000032  4804              LDR      r0,|L5.68|
000034  6800              LDR      r0,[r0,#0]            ;3589  ; uxDeletedTasksWaitingCleanUp
000036  2800              CMP      r0,#0                 ;3589
000038  d1e4              BNE      |L5.4|
;;;3601   		}
;;;3602   	}
;;;3603   	#endif /* INCLUDE_vTaskDelete */
;;;3604   }
00003a  bd10              POP      {r4,pc}
;;;3605   /*-----------------------------------------------------------*/
                          ENDP

                  |L5.60|
                          DCD      xTasksWaitingTermination
                  |L5.64|
                          DCD      uxCurrentNumberOfTasks
                  |L5.68|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3825   
;;;3826   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3827   	{
000002  4604              MOV      r4,r0
;;;3828   		/* This call is required specifically for the TriCore port.  It must be
;;;3829   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3830   		want to allocate and clean RAM statically. */
;;;3831   		portCLEAN_UP_TCB( pxTCB );
;;;3832   
;;;3833   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3834   		to the task to free any memory allocated at the application level. */
;;;3835   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3836   		{
;;;3837   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3838   		}
;;;3839   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3840   
;;;3841   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3842   		{
;;;3843   			/* The task can only have been allocated dynamically - free both
;;;3844   			the stack and TCB. */
;;;3845   			vPortFree( pxTCB->pxStack );
000004  6b20              LDR      r0,[r4,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3846   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3847   		}
;;;3848   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
;;;3849   		{
;;;3850   			/* The task could have been allocated statically or dynamically, so
;;;3851   			check what was statically allocated before trying to free the
;;;3852   			memory. */
;;;3853   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3854   			{
;;;3855   				/* Both the stack and TCB were allocated dynamically, so both
;;;3856   				must be freed. */
;;;3857   				vPortFree( pxTCB->pxStack );
;;;3858   				vPortFree( pxTCB );
;;;3859   			}
;;;3860   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3861   			{
;;;3862   				/* Only the stack was statically allocated, so the TCB is the
;;;3863   				only memory that must be freed. */
;;;3864   				vPortFree( pxTCB );
;;;3865   			}
;;;3866   			else
;;;3867   			{
;;;3868   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3869   				nothing needs to be freed. */
;;;3870   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
;;;3871   				mtCOVERAGE_TEST_MARKER();
;;;3872   			}
;;;3873   		}
;;;3874   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3875   	}
000010  bd10              POP      {r4,pc}
;;;3876   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3332    */
;;;3333   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L7.2|
;;;3334   {
;;;3335   	/* Stop warnings. */
;;;3336   	( void ) pvParameters;
;;;3337   
;;;3338   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3339   	SCHEDULER IS STARTED. **/
;;;3340   
;;;3341   	/* In case a task that has a secure context deletes itself, in which case
;;;3342   	the idle task is responsible for deleting the task's secure context, if
;;;3343   	any. */
;;;3344   	portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
;;;3345   
;;;3346   	for( ;; )
;;;3347   	{
;;;3348   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3349   		is responsible for freeing the deleted task's TCB and stack. */
;;;3350   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3351   
;;;3352   		#if ( configUSE_PREEMPTION == 0 )
;;;3353   		{
;;;3354   			/* If we are not using preemption we keep forcing a task switch to
;;;3355   			see if any other task has become available.  If we are using
;;;3356   			preemption we don't need to do this as any task becoming available
;;;3357   			will automatically get the processor anyway. */
;;;3358   			taskYIELD();
;;;3359   		}
;;;3360   		#endif /* configUSE_PREEMPTION */
;;;3361   
;;;3362   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3363   		{
;;;3364   			/* When using preemption tasks of equal priority will be
;;;3365   			timesliced.  If a task that is sharing the idle priority is ready
;;;3366   			to run then the idle task should yield before the end of the
;;;3367   			timeslice.
;;;3368   
;;;3369   			A critical region is not required here as we are just reading from
;;;3370   			the list, and an occasional incorrect value will not matter.  If
;;;3371   			the ready list at the idle priority contains more than one task
;;;3372   			then a task other than the idle task is ready to execute. */
;;;3373   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  4806              LDR      r0,|L7.32|
000008  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d9f9              BLS      |L7.2|
;;;3374   			{
;;;3375   				taskYIELD();
00000e  f04f5080          MOV      r0,#0x10000000
000012  4904              LDR      r1,|L7.36|
000014  6008              STR      r0,[r1,#0]
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  e7f0              B        |L7.2|
;;;3376   			}
;;;3377   			else
;;;3378   			{
;;;3379   				mtCOVERAGE_TEST_MARKER();
;;;3380   			}
;;;3381   		}
;;;3382   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3383   
;;;3384   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3385   		{
;;;3386   			extern void vApplicationIdleHook( void );
;;;3387   
;;;3388   			/* Call the user defined function from within the idle task.  This
;;;3389   			allows the application designer to add background functionality
;;;3390   			without the overhead of a separate task.
;;;3391   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3392   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3393   			vApplicationIdleHook();
;;;3394   		}
;;;3395   		#endif /* configUSE_IDLE_HOOK */
;;;3396   
;;;3397   		/* This conditional compilation should use inequality to 0, not equality
;;;3398   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3399   		user defined low power mode	implementations require
;;;3400   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3401   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3402   		{
;;;3403   		TickType_t xExpectedIdleTime;
;;;3404   
;;;3405   			/* It is not desirable to suspend then resume the scheduler on
;;;3406   			each iteration of the idle task.  Therefore, a preliminary
;;;3407   			test of the expected idle time is performed without the
;;;3408   			scheduler suspended.  The result here is not necessarily
;;;3409   			valid. */
;;;3410   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3411   
;;;3412   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3413   			{
;;;3414   				vTaskSuspendAll();
;;;3415   				{
;;;3416   					/* Now the scheduler is suspended, the expected idle
;;;3417   					time can be sampled again, and this time its value can
;;;3418   					be used. */
;;;3419   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3420   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3421   
;;;3422   					/* Define the following macro to set xExpectedIdleTime to 0
;;;3423   					if the application does not want
;;;3424   					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
;;;3425   					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
;;;3426   
;;;3427   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3428   					{
;;;3429   						traceLOW_POWER_IDLE_BEGIN();
;;;3430   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3431   						traceLOW_POWER_IDLE_END();
;;;3432   					}
;;;3433   					else
;;;3434   					{
;;;3435   						mtCOVERAGE_TEST_MARKER();
;;;3436   					}
;;;3437   				}
;;;3438   				( void ) xTaskResumeAll();
;;;3439   			}
;;;3440   			else
;;;3441   			{
;;;3442   				mtCOVERAGE_TEST_MARKER();
;;;3443   			}
;;;3444   		}
;;;3445   		#endif /* configUSE_TICKLESS_IDLE */
;;;3446   //		printf("welcome to [%s]\r\n",__func__);
;;;3447   	}
;;;3448   }
;;;3449   /*-----------------------------------------------------------*/
                          ENDP

                  |L7.32|
                          DCD      pxReadyTasksLists
                  |L7.36|
                          DCD      0xe000ed04

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;820    
;;;821    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;822    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;823    									const uint32_t ulStackDepth,
;;;824    									void * const pvParameters,
;;;825    									UBaseType_t uxPriority,
;;;826    									TaskHandle_t * const pxCreatedTask,
;;;827    									TCB_t *pxNewTCB,
;;;828    									const MemoryRegion_t * const xRegions )
;;;829    {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  469a              MOV      r10,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
000010  9c0c              LDR      r4,[sp,#0x30]
;;;830    StackType_t *pxTopOfStack;
;;;831    UBaseType_t x;
;;;832    
;;;833    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;834    		/* Should the task be created in privileged mode? */
;;;835    		BaseType_t xRunPrivileged;
;;;836    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;837    		{
;;;838    			xRunPrivileged = pdTRUE;
;;;839    		}
;;;840    		else
;;;841    		{
;;;842    			xRunPrivileged = pdFALSE;
;;;843    		}
;;;844    		uxPriority &= ~portPRIVILEGE_BIT;
;;;845    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;846    
;;;847    	/* Avoid dependency on memset() if it is not required. */
;;;848    	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;;;849    	{
;;;850    		/* Fill the stack with a known value to assist debugging. */
;;;851    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
000012  00b9              LSLS     r1,r7,#2
000014  22a5              MOVS     r2,#0xa5
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       __aeabi_memset
;;;852    	}
;;;853    	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;;;854    
;;;855    	/* Calculate the top of stack address.  This depends on whether the stack
;;;856    	grows from high memory to low (as per the 80x86) or vice versa.
;;;857    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;858    	by the port. */
;;;859    	#if( portSTACK_GROWTH < 0 )
;;;860    	{
;;;861    		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
00001c  1e78              SUBS     r0,r7,#1
00001e  6b21              LDR      r1,[r4,#0x30]
000020  eb010b80          ADD      r11,r1,r0,LSL #2
;;;862    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
000024  f02b0b07          BIC      r11,r11,#7
;;;863    
;;;864    		/* Check the alignment of the calculated top of stack is correct. */
;;;865    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;866    
;;;867    		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
;;;868    		{
;;;869    			/* Also record the stack's high address, which may assist
;;;870    			debugging. */
;;;871    			pxNewTCB->pxEndOfStack = pxTopOfStack;
;;;872    		}
;;;873    		#endif /* configRECORD_STACK_HIGH_ADDRESS */
;;;874    	}
;;;875    	#else /* portSTACK_GROWTH */
;;;876    	{
;;;877    		pxTopOfStack = pxNewTCB->pxStack;
;;;878    
;;;879    		/* Check the alignment of the stack buffer is correct. */
;;;880    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;881    
;;;882    		/* The other extreme of the stack space is required if stack checking is
;;;883    		performed. */
;;;884    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;885    	}
;;;886    	#endif /* portSTACK_GROWTH */
;;;887    
;;;888    	/* Store the task name in the TCB. */
;;;889    	if( pcName != NULL )
000028  b186              CBZ      r6,|L8.76|
;;;890    	{
;;;891    		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
00002a  2500              MOVS     r5,#0
00002c  e007              B        |L8.62|
                  |L8.46|
;;;892    		{
;;;893    			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
00002e  5d71              LDRB     r1,[r6,r5]
000030  f1040034          ADD      r0,r4,#0x34
000034  5541              STRB     r1,[r0,r5]
;;;894    
;;;895    			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;896    			configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;897    			string is not accessible (extremely unlikely). */
;;;898    			if( pcName[ x ] == ( char ) 0x00 )
000036  5d70              LDRB     r0,[r6,r5]
000038  b900              CBNZ     r0,|L8.60|
;;;899    			{
;;;900    				break;
00003a  e002              B        |L8.66|
                  |L8.60|
00003c  1c6d              ADDS     r5,r5,#1              ;891
                  |L8.62|
00003e  2d10              CMP      r5,#0x10              ;891
000040  d3f5              BCC      |L8.46|
                  |L8.66|
000042  bf00              NOP      
;;;901    			}
;;;902    			else
;;;903    			{
;;;904    				mtCOVERAGE_TEST_MARKER();
;;;905    			}
;;;906    		}
;;;907    
;;;908    		/* Ensure the name string is terminated in the case that the string length
;;;909    		was greater or equal to configMAX_TASK_NAME_LEN. */
;;;910    		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000044  2100              MOVS     r1,#0
000046  2043              MOVS     r0,#0x43
000048  5501              STRB     r1,[r0,r4]
00004a  e002              B        |L8.82|
                  |L8.76|
;;;911    	}
;;;912    	else
;;;913    	{
;;;914    		/* The task has not been given a name, so just ensure there is a NULL
;;;915    		terminator when it is read out. */
;;;916    		pxNewTCB->pcTaskName[ 0 ] = 0x00;
00004c  2000              MOVS     r0,#0
00004e  f8840034          STRB     r0,[r4,#0x34]
                  |L8.82|
;;;917    	}
;;;918    
;;;919    	/* This is used as an array index so must ensure it's not too large.  First
;;;920    	remove the privilege bit if one is present. */
;;;921    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000052  f1b80f05          CMP      r8,#5
000056  d301              BCC      |L8.92|
;;;922    	{
;;;923    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000058  f04f0804          MOV      r8,#4
                  |L8.92|
;;;924    	}
;;;925    	else
;;;926    	{
;;;927    		mtCOVERAGE_TEST_MARKER();
;;;928    	}
;;;929    
;;;930    	pxNewTCB->uxPriority = uxPriority;
00005c  f8c4802c          STR      r8,[r4,#0x2c]
;;;931    	#if ( configUSE_MUTEXES == 1 )
;;;932    	{
;;;933    		pxNewTCB->uxBasePriority = uxPriority;
;;;934    		pxNewTCB->uxMutexesHeld = 0;
;;;935    	}
;;;936    	#endif /* configUSE_MUTEXES */
;;;937    
;;;938    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000060  1d20              ADDS     r0,r4,#4
000062  f7fffffe          BL       vListInitialiseItem
;;;939    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000066  f1040018          ADD      r0,r4,#0x18
00006a  f7fffffe          BL       vListInitialiseItem
;;;940    
;;;941    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;942    	back to	the containing TCB from a generic item in a list. */
;;;943    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
00006e  6124              STR      r4,[r4,#0x10]
;;;944    
;;;945    	/* Event lists are always in priority order. */
;;;946    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000070  f1c80005          RSB      r0,r8,#5
000074  61a0              STR      r0,[r4,#0x18]
;;;947    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000076  6264              STR      r4,[r4,#0x24]
;;;948    
;;;949    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;950    	{
;;;951    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;952    	}
;;;953    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;954    
;;;955    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;956    	{
;;;957    		pxNewTCB->pxTaskTag = NULL;
;;;958    	}
;;;959    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;960    
;;;961    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;962    	{
;;;963    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;964    	}
;;;965    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;966    
;;;967    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;968    	{
;;;969    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;970    	}
;;;971    	#else
;;;972    	{
;;;973    		/* Avoid compiler warning about unreferenced parameter. */
;;;974    		( void ) xRegions;
;;;975    	}
;;;976    	#endif
;;;977    
;;;978    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;979    	{
;;;980    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;981    		{
;;;982    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;983    		}
;;;984    	}
;;;985    	#endif
;;;986    
;;;987    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;988    	{
;;;989    		pxNewTCB->ulNotifiedValue = 0;
000078  2000              MOVS     r0,#0
00007a  6460              STR      r0,[r4,#0x44]
;;;990    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00007c  f8840048          STRB     r0,[r4,#0x48]
;;;991    	}
;;;992    	#endif
;;;993    
;;;994    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;995    	{
;;;996    		/* Initialise this task's Newlib reent structure. */
;;;997    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;998    	}
;;;999    	#endif
;;;1000   
;;;1001   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;1002   	{
;;;1003   		pxNewTCB->ucDelayAborted = pdFALSE;
;;;1004   	}
;;;1005   	#endif
;;;1006   
;;;1007   	/* Initialize the TCB stack to look as if the task was already running,
;;;1008   	but had been interrupted by the scheduler.  The return address is set
;;;1009   	to the start of the task function. Once the stack has been initialised
;;;1010   	the top of stack variable is updated. */
;;;1011   	#if( portUSING_MPU_WRAPPERS == 1 )
;;;1012   	{
;;;1013   		/* If the port has capability to detect stack overflow,
;;;1014   		pass the stack end address to the stack initialization
;;;1015   		function as well. */
;;;1016   		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
;;;1017   		{
;;;1018   			#if( portSTACK_GROWTH < 0 )
;;;1019   			{
;;;1020   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1021   			}
;;;1022   			#else /* portSTACK_GROWTH */
;;;1023   			{
;;;1024   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1025   			}
;;;1026   			#endif /* portSTACK_GROWTH */
;;;1027   		}
;;;1028   		#else /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1029   		{
;;;1030   			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1031   		}
;;;1032   		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1033   	}
;;;1034   	#else /* portUSING_MPU_WRAPPERS */
;;;1035   	{
;;;1036   		/* If the port has capability to detect stack overflow,
;;;1037   		pass the stack end address to the stack initialization
;;;1038   		function as well. */
;;;1039   		#if( portHAS_STACK_OVERFLOW_CHECKING == 1 )
;;;1040   		{
;;;1041   			#if( portSTACK_GROWTH < 0 )
;;;1042   			{
;;;1043   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters );
;;;1044   			}
;;;1045   			#else /* portSTACK_GROWTH */
;;;1046   			{
;;;1047   				pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStack, pxTaskCode, pvParameters );
;;;1048   			}
;;;1049   			#endif /* portSTACK_GROWTH */
;;;1050   		}
;;;1051   		#else /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1052   		{
;;;1053   			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000080  4652              MOV      r2,r10
000082  4649              MOV      r1,r9
000084  4658              MOV      r0,r11
000086  f7fffffe          BL       pxPortInitialiseStack
00008a  6020              STR      r0,[r4,#0]
;;;1054   		}
;;;1055   		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
;;;1056   	}
;;;1057   	#endif /* portUSING_MPU_WRAPPERS */
;;;1058   
;;;1059   	if( pxCreatedTask != NULL )
00008c  980b              LDR      r0,[sp,#0x2c]
00008e  b108              CBZ      r0,|L8.148|
;;;1060   	{
;;;1061   		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;1062   		change the created task's priority, delete the created task, etc.*/
;;;1063   		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000090  980b              LDR      r0,[sp,#0x2c]
000092  6004              STR      r4,[r0,#0]
                  |L8.148|
;;;1064   	}
;;;1065   	else
;;;1066   	{
;;;1067   		mtCOVERAGE_TEST_MARKER();
;;;1068   	}
;;;1069   }
000094  e8bd9ff0          POP      {r4-r12,pc}
;;;1070   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3545   
;;;3546   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;3547   {
;;;3548   UBaseType_t uxPriority;
;;;3549   
;;;3550   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L9.22|
                  |L9.6|
;;;3551   	{
;;;3552   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L9.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3550
                  |L9.22|
000016  2c05              CMP      r4,#5                 ;3550
000018  d3f5              BCC      |L9.6|
;;;3553   	}
;;;3554   
;;;3555   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L9.76|
00001c  f7fffffe          BL       vListInitialise
;;;3556   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L9.80|
000022  f7fffffe          BL       vListInitialise
;;;3557   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L9.84|
000028  f7fffffe          BL       vListInitialise
;;;3558   
;;;3559   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3560   	{
;;;3561   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L9.88|
00002e  f7fffffe          BL       vListInitialise
;;;3562   	}
;;;3563   	#endif /* INCLUDE_vTaskDelete */
;;;3564   
;;;3565   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3566   	{
;;;3567   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L9.92|
000034  f7fffffe          BL       vListInitialise
;;;3568   	}
;;;3569   	#endif /* INCLUDE_vTaskSuspend */
;;;3570   
;;;3571   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3572   	using list2. */
;;;3573   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L9.76|
00003a  4909              LDR      r1,|L9.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3574   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L9.80|
000040  4908              LDR      r1,|L9.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3575   }
000044  bd10              POP      {r4,pc}
;;;3576   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      pxReadyTasksLists
                  |L9.76|
                          DCD      xDelayedTaskList1
                  |L9.80|
                          DCD      xDelayedTaskList2
                  |L9.84|
                          DCD      xPendingReadyList
                  |L9.88|
                          DCD      xTasksWaitingTermination
                  |L9.92|
                          DCD      xSuspendedTaskList
                  |L9.96|
                          DCD      pxDelayedTaskList
                  |L9.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3879   
;;;3880   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L10.44|
;;;3881   {
;;;3882   TCB_t *pxTCB;
;;;3883   
;;;3884   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L10.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  2100              MOVS     r1,#0
                  |L10.14|
00000e  b121              CBZ      r1,|L10.26|
;;;3885   	{
;;;3886   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3887   		the maximum possible value so it is	extremely unlikely that the
;;;3888   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3889   		there is an item in the delayed list. */
;;;3890   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L10.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L10.40|
                  |L10.26|
;;;3891   	}
;;;3892   	else
;;;3893   	{
;;;3894   		/* The new current delayed list is not empty, get the value of
;;;3895   		the item at the head of the delayed list.  This is the time at
;;;3896   		which the task at the head of the delayed list should be removed
;;;3897   		from the Blocked state. */
;;;3898   		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00001a  4904              LDR      r1,|L10.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3899   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000022  4a03              LDR      r2,|L10.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L10.40|
;;;3900   	}
;;;3901   }
000028  4770              BX       lr
;;;3902   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      pxDelayedTaskList
                  |L10.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=1

                  prvTaskCheckFreeStackSpace PROC
;;;3737   
;;;3738   	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  4602              MOV      r2,r0
;;;3739   	{
;;;3740   	uint32_t ulCount = 0U;
000002  2100              MOVS     r1,#0
;;;3741   
;;;3742   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
000004  e001              B        |L11.10|
                  |L11.6|
;;;3743   		{
;;;3744   			pucStackByte -= portSTACK_GROWTH;
000006  1c52              ADDS     r2,r2,#1
;;;3745   			ulCount++;
000008  1c49              ADDS     r1,r1,#1
                  |L11.10|
00000a  7810              LDRB     r0,[r2,#0]            ;3742
00000c  28a5              CMP      r0,#0xa5              ;3742
00000e  d0fa              BEQ      |L11.6|
;;;3746   		}
;;;3747   
;;;3748   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
000010  0889              LSRS     r1,r1,#2
;;;3749   
;;;3750   		return ( configSTACK_DEPTH_TYPE ) ulCount;
000012  b288              UXTH     r0,r1
;;;3751   	}
000014  4770              BX       lr
;;;3752   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1796   
;;;1797   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1798   	{
000002  4601              MOV      r1,r0
;;;1799   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1800   	const TCB_t * const pxTCB = xTask;
000006  460a              MOV      r2,r1
;;;1801   
;;;1802   		/* Accesses xPendingReadyList so must be called from a critical
;;;1803   		section. */
;;;1804   
;;;1805   		/* It does not make sense to check if the calling task is suspended. */
;;;1806   		configASSERT( xTask );
;;;1807   
;;;1808   		/* Is the task being resumed actually in the suspended list? */
;;;1809   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000008  4c0b              LDR      r4,|L12.56|
00000a  6953              LDR      r3,[r2,#0x14]
00000c  42a3              CMP      r3,r4
00000e  d101              BNE      |L12.20|
000010  2301              MOVS     r3,#1
000012  e000              B        |L12.22|
                  |L12.20|
000014  2300              MOVS     r3,#0
                  |L12.22|
000016  b173              CBZ      r3,|L12.54|
;;;1810   		{
;;;1811   			/* Has the task already been resumed from within an ISR? */
;;;1812   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000018  4c08              LDR      r4,|L12.60|
00001a  6a93              LDR      r3,[r2,#0x28]
00001c  42a3              CMP      r3,r4
00001e  d101              BNE      |L12.36|
000020  2301              MOVS     r3,#1
000022  e000              B        |L12.38|
                  |L12.36|
000024  2300              MOVS     r3,#0
                  |L12.38|
000026  b933              CBNZ     r3,|L12.54|
;;;1813   			{
;;;1814   				/* Is it in the suspended list because it is in the	Suspended
;;;1815   				state, or because is is blocked with no timeout? */
;;;1816   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
000028  6a93              LDR      r3,[r2,#0x28]
00002a  b90b              CBNZ     r3,|L12.48|
00002c  2301              MOVS     r3,#1
00002e  e000              B        |L12.50|
                  |L12.48|
000030  2300              MOVS     r3,#0
                  |L12.50|
000032  b103              CBZ      r3,|L12.54|
;;;1817   				{
;;;1818   					xReturn = pdTRUE;
000034  2001              MOVS     r0,#1
                  |L12.54|
;;;1819   				}
;;;1820   				else
;;;1821   				{
;;;1822   					mtCOVERAGE_TEST_MARKER();
;;;1823   				}
;;;1824   			}
;;;1825   			else
;;;1826   			{
;;;1827   				mtCOVERAGE_TEST_MARKER();
;;;1828   			}
;;;1829   		}
;;;1830   		else
;;;1831   		{
;;;1832   			mtCOVERAGE_TEST_MARKER();
;;;1833   		}
;;;1834   
;;;1835   		return xReturn;
;;;1836   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000036  bd10              POP      {r4,pc}
;;;1837   
                          ENDP

                  |L12.56|
                          DCD      xSuspendedTaskList
                  |L12.60|
                          DCD      xPendingReadyList

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4565   
;;;4566   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4567   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4568   	uint32_t ulReturn;
;;;4569   
;;;4570   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4571   		{
;;;4572   			/* Only block if the notification count is not already non-zero. */
;;;4573   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4818              LDR      r0,|L13.108|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  6c40              LDR      r0,[r0,#0x44]
000010  b988              CBNZ     r0,|L13.54|
;;;4574   			{
;;;4575   				/* Mark this task as waiting for a notification. */
;;;4576   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  2001              MOVS     r0,#1
000014  4915              LDR      r1,|L13.108|
000016  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000018  f8810048          STRB     r0,[r1,#0x48]
;;;4577   
;;;4578   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b15d              CBZ      r5,|L13.54|
;;;4579   				{
;;;4580   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4581   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4582   
;;;4583   					/* All ports are written to allow a yield in a critical
;;;4584   					section (some will yield immediately, others wait until the
;;;4585   					critical section exits) - but it is not something that
;;;4586   					application code should ever do. */
;;;4587   					portYIELD_WITHIN_API();
000026  f04f5080          MOV      r0,#0x10000000
00002a  4911              LDR      r1,|L13.112|
00002c  6008              STR      r0,[r1,#0]
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L13.54|
;;;4588   				}
;;;4589   				else
;;;4590   				{
;;;4591   					mtCOVERAGE_TEST_MARKER();
;;;4592   				}
;;;4593   			}
;;;4594   			else
;;;4595   			{
;;;4596   				mtCOVERAGE_TEST_MARKER();
;;;4597   			}
;;;4598   		}
;;;4599   		taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;4600   
;;;4601   		taskENTER_CRITICAL();
00003a  f7fffffe          BL       vPortEnterCritical
;;;4602   		{
;;;4603   			traceTASK_NOTIFY_TAKE();
;;;4604   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003e  480b              LDR      r0,|L13.108|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  6c44              LDR      r4,[r0,#0x44]
;;;4605   
;;;4606   			if( ulReturn != 0UL )
000044  b14c              CBZ      r4,|L13.90|
;;;4607   			{
;;;4608   				if( xClearCountOnExit != pdFALSE )
000046  b126              CBZ      r6,|L13.82|
;;;4609   				{
;;;4610   					pxCurrentTCB->ulNotifiedValue = 0UL;
000048  2000              MOVS     r0,#0
00004a  4908              LDR      r1,|L13.108|
00004c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004e  6448              STR      r0,[r1,#0x44]
000050  e003              B        |L13.90|
                  |L13.82|
;;;4611   				}
;;;4612   				else
;;;4613   				{
;;;4614   					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
000052  1e60              SUBS     r0,r4,#1
000054  4905              LDR      r1,|L13.108|
000056  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000058  6448              STR      r0,[r1,#0x44]
                  |L13.90|
;;;4615   				}
;;;4616   			}
;;;4617   			else
;;;4618   			{
;;;4619   				mtCOVERAGE_TEST_MARKER();
;;;4620   			}
;;;4621   
;;;4622   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00005a  2000              MOVS     r0,#0
00005c  4903              LDR      r1,|L13.108|
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  f8810048          STRB     r0,[r1,#0x48]
;;;4623   		}
;;;4624   		taskEXIT_CRITICAL();
000064  f7fffffe          BL       vPortExitCritical
;;;4625   
;;;4626   		return ulReturn;
000068  4620              MOV      r0,r4
;;;4627   	}
00006a  bd70              POP      {r4-r6,pc}
;;;4628   
                          ENDP

                  |L13.108|
                          DCD      pxCurrentTCB
                  |L13.112|
                          DCD      0xe000ed04

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2328   
;;;2329   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L14.8|
;;;2330   {
;;;2331   	/* A critical section is not required because the variables are of type
;;;2332   	BaseType_t. */
;;;2333   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2334   }
000004  4770              BX       lr
;;;2335   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskGetStackHighWaterMark||, CODE, READONLY, ALIGN=2

                  uxTaskGetStackHighWaterMark PROC
;;;3797   
;;;3798   	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3799   	{
000004  4604              MOV      r4,r0
;;;3800   	TCB_t *pxTCB;
;;;3801   	uint8_t *pucEndOfStack;
;;;3802   	UBaseType_t uxReturn;
;;;3803   
;;;3804   		pxTCB = prvGetTCBFromHandle( xTask );
000006  b914              CBNZ     r4,|L15.14|
000008  4806              LDR      r0,|L15.36|
00000a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000c  e000              B        |L15.16|
                  |L15.14|
00000e  4620              MOV      r0,r4
                  |L15.16|
000010  4607              MOV      r7,r0
;;;3805   
;;;3806   		#if portSTACK_GROWTH < 0
;;;3807   		{
;;;3808   			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
000012  6b3d              LDR      r5,[r7,#0x30]
;;;3809   		}
;;;3810   		#else
;;;3811   		{
;;;3812   			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
;;;3813   		}
;;;3814   		#endif
;;;3815   
;;;3816   		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       prvTaskCheckFreeStackSpace
00001a  4606              MOV      r6,r0
;;;3817   
;;;3818   		return uxReturn;
00001c  4630              MOV      r0,r6
;;;3819   	}
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;3820   
                          ENDP

000022  0000              DCW      0x0000
                  |L15.36|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1469   
;;;1470   	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1471   	{
000002  4604              MOV      r4,r0
;;;1472   	TCB_t const *pxTCB;
;;;1473   	UBaseType_t uxReturn;
;;;1474   
;;;1475   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1476   		{
;;;1477   			/* If null is passed in here then it is the priority of the task
;;;1478   			that called uxTaskPriorityGet() that is being queried. */
;;;1479   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L16.16|
00000a  4805              LDR      r0,|L16.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L16.18|
                  |L16.16|
000010  4620              MOV      r0,r4
                  |L16.18|
000012  4606              MOV      r6,r0
;;;1480   			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;1481   		}
;;;1482   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1483   
;;;1484   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1485   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1486   
                          ENDP

00001e  0000              DCW      0x0000
                  |L16.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1491   
;;;1492   	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1493   	{
000002  4602              MOV      r2,r0
;;;1494   	TCB_t const *pxTCB;
;;;1495   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1496   
;;;1497   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1498   		maximum	system call (or maximum API call) interrupt priority.
;;;1499   		Interrupts that are	above the maximum system call priority are keep
;;;1500   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1501   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1502   		is defined in FreeRTOSConfig.h then
;;;1503   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1504   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1505   		been assigned a priority above the configured maximum system call
;;;1506   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1507   		from interrupts	that have been assigned a priority at or (logically)
;;;1508   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1509   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1510   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1511   		provided on the following link:
;;;1512   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1513   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1514   
;;;1515   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000004  bf00              NOP      
000006  25bf              MOVS     r5,#0xbf
000008  f3ef8411          MRS      r4,BASEPRI
00000c  f3858811          MSR      BASEPRI,r5
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  4621              MOV      r1,r4
;;;1516   		{
;;;1517   			/* If null is passed in here then it is the priority of the calling
;;;1518   			task that is being queried. */
;;;1519   			pxTCB = prvGetTCBFromHandle( xTask );
00001c  b912              CBNZ     r2,|L17.36|
00001e  4c05              LDR      r4,|L17.52|
000020  6824              LDR      r4,[r4,#0]  ; pxCurrentTCB
000022  e000              B        |L17.38|
                  |L17.36|
000024  4614              MOV      r4,r2
                  |L17.38|
000026  4623              MOV      r3,r4
;;;1520   			uxReturn = pxTCB->uxPriority;
000028  6ad8              LDR      r0,[r3,#0x2c]
;;;1521   		}
;;;1522   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
00002a  bf00              NOP      
00002c  f3818811          MSR      BASEPRI,r1
000030  bf00              NOP      
;;;1523   
;;;1524   		return uxReturn;
;;;1525   	}
000032  bd70              POP      {r4-r6,pc}
;;;1526   
                          ENDP

                  |L17.52|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4532   
;;;4533   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L18.24|
;;;4534   {
;;;4535   TickType_t uxReturn;
;;;4536   
;;;4537   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;4538   
;;;4539   	/* Reset the event list item to its normal value - so it can be used with
;;;4540   	queues and semaphores. */
;;;4541   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L18.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10105          RSB      r1,r1,#5
000010  4a01              LDR      r2,|L18.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;4542   
;;;4543   	return uxReturn;
;;;4544   }
000016  4770              BX       lr
;;;4545   /*-----------------------------------------------------------*/
                          ENDP

                  |L18.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1332   
;;;1333   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;1334   	{
000002  4604              MOV      r4,r0
;;;1335   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1336   
;;;1337   		/* A delay time of zero just forces a reschedule. */
;;;1338   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b144              CBZ      r4,|L19.26|
;;;1339   		{
;;;1340   			configASSERT( uxSchedulerSuspended == 0 );
;;;1341   			vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;1342   			{
;;;1343   				traceTASK_DELAY();
;;;1344   
;;;1345   				/* A task that is removed from the event list while the
;;;1346   				scheduler is suspended will not get placed in the ready
;;;1347   				list or removed from the blocked list until the scheduler
;;;1348   				is resumed.
;;;1349   
;;;1350   				This task cannot be in an event list as it is the currently
;;;1351   				executing task. */
;;;1352   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1353   			}
;;;1354   			xAlreadyYielded = xTaskResumeAll();
000014  f7fffffe          BL       xTaskResumeAll
000018  4605              MOV      r5,r0
                  |L19.26|
;;;1355   		}
;;;1356   		else
;;;1357   		{
;;;1358   			mtCOVERAGE_TEST_MARKER();
;;;1359   		}
;;;1360   
;;;1361   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1362   		have put ourselves to sleep. */
;;;1363   		if( xAlreadyYielded == pdFALSE )
00001a  b93d              CBNZ     r5,|L19.44|
;;;1364   		{
;;;1365   			portYIELD_WITHIN_API();
00001c  f04f5080          MOV      r0,#0x10000000
000020  4903              LDR      r1,|L19.48|
000022  6008              STR      r0,[r1,#0]
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
                  |L19.44|
;;;1366   		}
;;;1367   		else
;;;1368   		{
;;;1369   			mtCOVERAGE_TEST_MARKER();
;;;1370   		}
;;;1371   	}
00002c  bd70              POP      {r4-r6,pc}
;;;1372   
                          ENDP

00002e  0000              DCW      0x0000
                  |L19.48|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1248   
;;;1249   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1250   	{
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;1251   	TickType_t xTimeToWake;
;;;1252   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1253   
;;;1254   		configASSERT( pxPreviousWakeTime );
;;;1255   		configASSERT( ( xTimeIncrement > 0U ) );
;;;1256   		configASSERT( uxSchedulerSuspended == 0 );
;;;1257   
;;;1258   		vTaskSuspendAll();
00000c  f7fffffe          BL       vTaskSuspendAll
;;;1259   		{
;;;1260   			/* Minor optimisation.  The tick count cannot change in this
;;;1261   			block. */
;;;1262   			const TickType_t xConstTickCount = xTickCount;
000010  4816              LDR      r0,|L20.108|
000012  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1263   
;;;1264   			/* Generate the tick time at which the task wants to wake. */
;;;1265   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000014  6820              LDR      r0,[r4,#0]
000016  eb000508          ADD      r5,r0,r8
;;;1266   
;;;1267   			if( xConstTickCount < *pxPreviousWakeTime )
00001a  6820              LDR      r0,[r4,#0]
00001c  42b0              CMP      r0,r6
00001e  d907              BLS      |L20.48|
;;;1268   			{
;;;1269   				/* The tick count has overflowed since this function was
;;;1270   				lasted called.  In this case the only time we should ever
;;;1271   				actually delay is if the wake time has also	overflowed,
;;;1272   				and the wake time is greater than the tick time.  When this
;;;1273   				is the case it is as if neither time had overflowed. */
;;;1274   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000020  6820              LDR      r0,[r4,#0]
000022  42a8              CMP      r0,r5
000024  d90b              BLS      |L20.62|
000026  42b5              CMP      r5,r6
000028  d909              BLS      |L20.62|
;;;1275   				{
;;;1276   					xShouldDelay = pdTRUE;
00002a  f04f0901          MOV      r9,#1
00002e  e006              B        |L20.62|
                  |L20.48|
;;;1277   				}
;;;1278   				else
;;;1279   				{
;;;1280   					mtCOVERAGE_TEST_MARKER();
;;;1281   				}
;;;1282   			}
;;;1283   			else
;;;1284   			{
;;;1285   				/* The tick time has not overflowed.  In this case we will
;;;1286   				delay if either the wake time has overflowed, and/or the
;;;1287   				tick time is less than the wake time. */
;;;1288   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
000030  6820              LDR      r0,[r4,#0]
000032  42a8              CMP      r0,r5
000034  d801              BHI      |L20.58|
000036  42b5              CMP      r5,r6
000038  d901              BLS      |L20.62|
                  |L20.58|
;;;1289   				{
;;;1290   					xShouldDelay = pdTRUE;
00003a  f04f0901          MOV      r9,#1
                  |L20.62|
;;;1291   				}
;;;1292   				else
;;;1293   				{
;;;1294   					mtCOVERAGE_TEST_MARKER();
;;;1295   				}
;;;1296   			}
;;;1297   
;;;1298   			/* Update the wake time ready for the next call. */
;;;1299   			*pxPreviousWakeTime = xTimeToWake;
00003e  6025              STR      r5,[r4,#0]
;;;1300   
;;;1301   			if( xShouldDelay != pdFALSE )
000040  f1b90f00          CMP      r9,#0
000044  d003              BEQ      |L20.78|
;;;1302   			{
;;;1303   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1304   
;;;1305   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1306   				the time to wake, so subtract the current tick count. */
;;;1307   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000046  1ba8              SUBS     r0,r5,r6
000048  2100              MOVS     r1,#0
00004a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L20.78|
;;;1308   			}
;;;1309   			else
;;;1310   			{
;;;1311   				mtCOVERAGE_TEST_MARKER();
;;;1312   			}
;;;1313   		}
;;;1314   		xAlreadyYielded = xTaskResumeAll();
00004e  f7fffffe          BL       xTaskResumeAll
000052  4607              MOV      r7,r0
;;;1315   
;;;1316   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1317   		have put ourselves to sleep. */
;;;1318   		if( xAlreadyYielded == pdFALSE )
000054  b93f              CBNZ     r7,|L20.102|
;;;1319   		{
;;;1320   			portYIELD_WITHIN_API();
000056  f04f5080          MOV      r0,#0x10000000
00005a  4905              LDR      r1,|L20.112|
00005c  6008              STR      r0,[r1,#0]
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
                  |L20.102|
;;;1321   		}
;;;1322   		else
;;;1323   		{
;;;1324   			mtCOVERAGE_TEST_MARKER();
;;;1325   		}
;;;1326   	}
000066  e8bd87f0          POP      {r4-r10,pc}
;;;1327   
                          ENDP

00006a  0000              DCW      0x0000
                  |L20.108|
                          DCD      xTickCount
                  |L20.112|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1156   
;;;1157   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1158   	{
000002  4605              MOV      r5,r0
;;;1159   	TCB_t *pxTCB;
;;;1160   
;;;1161   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1162   		{
;;;1163   			/* If null is passed in here then it is the calling task that is
;;;1164   			being deleted. */
;;;1165   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L21.16|
00000a  4827              LDR      r0,|L21.168|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L21.18|
                  |L21.16|
000010  4628              MOV      r0,r5
                  |L21.18|
000012  4604              MOV      r4,r0
;;;1166   
;;;1167   			/* Remove task from the ready list. */
;;;1168   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L21.60|
;;;1169   			{
;;;1170   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  4922              LDR      r1,|L21.172|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L21.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  491f              LDR      r1,|L21.176|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  481d              LDR      r0,|L21.176|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L21.60|
;;;1171   			}
;;;1172   			else
;;;1173   			{
;;;1174   				mtCOVERAGE_TEST_MARKER();
;;;1175   			}
;;;1176   
;;;1177   			/* Is the task waiting on an event also? */
;;;1178   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L21.72|
;;;1179   			{
;;;1180   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L21.72|
;;;1181   			}
;;;1182   			else
;;;1183   			{
;;;1184   				mtCOVERAGE_TEST_MARKER();
;;;1185   			}
;;;1186   
;;;1187   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1188   			detect that the task lists need re-generating.  This is done before
;;;1189   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1190   			not return. */
;;;1191   			uxTaskNumber++;
000048  481a              LDR      r0,|L21.180|
00004a  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00004c  1c40              ADDS     r0,r0,#1
00004e  4919              LDR      r1,|L21.180|
000050  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1192   
;;;1193   			if( pxTCB == pxCurrentTCB )
000052  4815              LDR      r0,|L21.168|
000054  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000056  4284              CMP      r4,r0
000058  d109              BNE      |L21.110|
;;;1194   			{
;;;1195   				/* A task is deleting itself.  This cannot complete within the
;;;1196   				task itself, as a context switch to another task is required.
;;;1197   				Place the task in the termination list.  The idle task will
;;;1198   				check the termination list and free up any memory allocated by
;;;1199   				the scheduler for the TCB and stack of the deleted task. */
;;;1200   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
00005a  1d21              ADDS     r1,r4,#4
00005c  4816              LDR      r0,|L21.184|
00005e  f7fffffe          BL       vListInsertEnd
;;;1201   
;;;1202   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1203   				there is a task that has been deleted and that it should therefore
;;;1204   				check the xTasksWaitingTermination list. */
;;;1205   				++uxDeletedTasksWaitingCleanUp;
000062  4816              LDR      r0,|L21.188|
000064  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000066  1c40              ADDS     r0,r0,#1
000068  4914              LDR      r1,|L21.188|
00006a  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
00006c  e009              B        |L21.130|
                  |L21.110|
;;;1206   
;;;1207   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1208   				in which Windows specific clean up operations are performed,
;;;1209   				after which it is not possible to yield away from this task -
;;;1210   				hence xYieldPending is used to latch that a context switch is
;;;1211   				required. */
;;;1212   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1213   			}
;;;1214   			else
;;;1215   			{
;;;1216   				--uxCurrentNumberOfTasks;
00006e  4814              LDR      r0,|L21.192|
000070  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000072  1e40              SUBS     r0,r0,#1
000074  4912              LDR      r1,|L21.192|
000076  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1217   				prvDeleteTCB( pxTCB );
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       prvDeleteTCB
;;;1218   
;;;1219   				/* Reset the next expected unblock time in case it referred to
;;;1220   				the task that has just been deleted. */
;;;1221   				prvResetNextTaskUnblockTime();
00007e  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L21.130|
;;;1222   			}
;;;1223   
;;;1224   			traceTASK_DELETE( pxTCB );
;;;1225   		}
;;;1226   		taskEXIT_CRITICAL();
000082  f7fffffe          BL       vPortExitCritical
;;;1227   
;;;1228   		/* Force a reschedule if it is the currently running task that has just
;;;1229   		been deleted. */
;;;1230   		if( xSchedulerRunning != pdFALSE )
000086  480f              LDR      r0,|L21.196|
000088  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00008a  b158              CBZ      r0,|L21.164|
;;;1231   		{
;;;1232   			if( pxTCB == pxCurrentTCB )
00008c  4806              LDR      r0,|L21.168|
00008e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000090  4284              CMP      r4,r0
000092  d107              BNE      |L21.164|
;;;1233   			{
;;;1234   				configASSERT( uxSchedulerSuspended == 0 );
;;;1235   				portYIELD_WITHIN_API();
000094  f04f5080          MOV      r0,#0x10000000
000098  490b              LDR      r1,|L21.200|
00009a  6008              STR      r0,[r1,#0]
00009c  f3bf8f4f          DSB      
0000a0  f3bf8f6f          ISB      
                  |L21.164|
;;;1236   			}
;;;1237   			else
;;;1238   			{
;;;1239   				mtCOVERAGE_TEST_MARKER();
;;;1240   			}
;;;1241   		}
;;;1242   	}
0000a4  bd70              POP      {r4-r6,pc}
;;;1243   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L21.168|
                          DCD      pxCurrentTCB
                  |L21.172|
                          DCD      pxReadyTasksLists
                  |L21.176|
                          DCD      uxTopReadyPriority
                  |L21.180|
                          DCD      uxTaskNumber
                  |L21.184|
                          DCD      xTasksWaitingTermination
                  |L21.188|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L21.192|
                          DCD      uxCurrentNumberOfTasks
                  |L21.196|
                          DCD      xSchedulerRunning
                  |L21.200|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;2088   
;;;2089   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;2090   {
;;;2091   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;2092   	routine so the original ISRs can be restored if necessary.  The port
;;;2093   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;2094   	portDISABLE_INTERRUPTS();
000002  bf00              NOP      
000004  20bf              MOVS     r0,#0xbf
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;2095   	xSchedulerRunning = pdFALSE;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L22.32|
000018  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;2096   	vPortEndScheduler();
00001a  f7fffffe          BL       vPortEndScheduler
;;;2097   }
00001e  bd10              POP      {r4,pc}
;;;2098   /*----------------------------------------------------------*/
                          ENDP

                  |L22.32|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskInternalSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskInternalSetTimeOutState PROC
;;;3206   
;;;3207   void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4903              LDR      r1,|L23.16|
;;;3208   {
;;;3209   	/* For internal use only as it does not use a critical section. */
;;;3210   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000004  6001              STR      r1,[r0,#0]
;;;3211   	pxTimeOut->xTimeOnEntering = xTickCount;
000006  4903              LDR      r1,|L23.20|
000008  6809              LDR      r1,[r1,#0]  ; xTickCount
00000a  6041              STR      r1,[r0,#4]
;;;3212   }
00000c  4770              BX       lr
;;;3213   /*-----------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L23.16|
                          DCD      xNumOfOverflows
                  |L23.20|
                          DCD      xTickCount

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3277   
;;;3278   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;3279   {
;;;3280   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L24.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3281   }
000006  4770              BX       lr
;;;3282   /*-----------------------------------------------------------*/
                          ENDP

                  |L24.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4956   
;;;4957   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4958   	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;4959   	TCB_t * pxTCB;
;;;4960   	uint8_t ucOriginalNotifyState;
;;;4961   	UBaseType_t uxSavedInterruptStatus;
;;;4962   
;;;4963   		configASSERT( xTaskToNotify );
;;;4964   
;;;4965   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4966   		maximum	system call (or maximum API call) interrupt priority.
;;;4967   		Interrupts that are	above the maximum system call priority are keep
;;;4968   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4969   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4970   		is defined in FreeRTOSConfig.h then
;;;4971   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4972   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4973   		been assigned a priority above the configured maximum system call
;;;4974   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4975   		from interrupts	that have been assigned a priority at or (logically)
;;;4976   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4977   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4978   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4979   		provided on the following link:
;;;4980   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4981   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4982   
;;;4983   		pxTCB = xTaskToNotify;
000008  462c              MOV      r4,r5
;;;4984   
;;;4985   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4607              MOV      r7,r0
;;;4986   		{
;;;4987   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000022  f8948048          LDRB     r8,[r4,#0x48]
;;;4988   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000026  2002              MOVS     r0,#2
000028  f8840048          STRB     r0,[r4,#0x48]
;;;4989   
;;;4990   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4991   			semaphore. */
;;;4992   			( pxTCB->ulNotifiedValue )++;
00002c  6c60              LDR      r0,[r4,#0x44]
00002e  1c40              ADDS     r0,r0,#1
000030  6460              STR      r0,[r4,#0x44]
;;;4993   
;;;4994   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4995   
;;;4996   			/* If the task is in the blocked state specifically to wait for a
;;;4997   			notification then unblock it now. */
;;;4998   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000032  f1b80f01          CMP      r8,#1
000036  d129              BNE      |L25.140|
;;;4999   			{
;;;5000   				/* The task should not have been on an event list. */
;;;5001   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;5002   
;;;5003   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000038  4817              LDR      r0,|L25.152|
00003a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00003c  b9a8              CBNZ     r0,|L25.106|
;;;5004   				{
;;;5005   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00003e  1d20              ADDS     r0,r4,#4
000040  f7fffffe          BL       uxListRemove
;;;5006   					prvAddTaskToReadyList( pxTCB );
000044  f894102c          LDRB     r1,[r4,#0x2c]
000048  2001              MOVS     r0,#1
00004a  4088              LSLS     r0,r0,r1
00004c  4913              LDR      r1,|L25.156|
00004e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000050  4308              ORRS     r0,r0,r1
000052  4912              LDR      r1,|L25.156|
000054  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000056  6ae1              LDR      r1,[r4,#0x2c]
000058  eb010181          ADD      r1,r1,r1,LSL #2
00005c  4a10              LDR      r2,|L25.160|
00005e  eb020081          ADD      r0,r2,r1,LSL #2
000062  1d21              ADDS     r1,r4,#4
000064  f7fffffe          BL       vListInsertEnd
000068  e004              B        |L25.116|
                  |L25.106|
;;;5007   				}
;;;5008   				else
;;;5009   				{
;;;5010   					/* The delayed and ready lists cannot be accessed, so hold
;;;5011   					this task pending until the scheduler is resumed. */
;;;5012   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00006a  f1040118          ADD      r1,r4,#0x18
00006e  480d              LDR      r0,|L25.164|
000070  f7fffffe          BL       vListInsertEnd
                  |L25.116|
;;;5013   				}
;;;5014   
;;;5015   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000074  490c              LDR      r1,|L25.168|
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00007a  6ac9              LDR      r1,[r1,#0x2c]
00007c  4288              CMP      r0,r1
00007e  d905              BLS      |L25.140|
;;;5016   				{
;;;5017   					/* The notified task has a priority above the currently
;;;5018   					executing task so a yield is required. */
;;;5019   					if( pxHigherPriorityTaskWoken != NULL )
000080  b10e              CBZ      r6,|L25.134|
;;;5020   					{
;;;5021   						*pxHigherPriorityTaskWoken = pdTRUE;
000082  2001              MOVS     r0,#1
000084  6030              STR      r0,[r6,#0]
                  |L25.134|
;;;5022   					}
;;;5023   
;;;5024   					/* Mark that a yield is pending in case the user is not
;;;5025   					using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;5026   					safe FreeRTOS function. */
;;;5027   					xYieldPending = pdTRUE;
000086  2001              MOVS     r0,#1
000088  4908              LDR      r1,|L25.172|
00008a  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L25.140|
;;;5028   				}
;;;5029   				else
;;;5030   				{
;;;5031   					mtCOVERAGE_TEST_MARKER();
;;;5032   				}
;;;5033   			}
;;;5034   		}
;;;5035   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00008c  bf00              NOP      
00008e  f3878811          MSR      BASEPRI,r7
000092  bf00              NOP      
;;;5036   	}
000094  e8bd81f0          POP      {r4-r8,pc}
;;;5037   
                          ENDP

                  |L25.152|
                          DCD      uxSchedulerSuspended
                  |L25.156|
                          DCD      uxTopReadyPriority
                  |L25.160|
                          DCD      pxReadyTasksLists
                  |L25.164|
                          DCD      xPendingReadyList
                  |L25.168|
                          DCD      pxCurrentTCB
                  |L25.172|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;3018   
;;;3019   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3020   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;3021   	configASSERT( pxEventList );
;;;3022   
;;;3023   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;3024   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;3025   
;;;3026   	/* Place the event list item of the TCB in the appropriate event list.
;;;3027   	This is placed in the list in priority order so the highest priority task
;;;3028   	is the first to be woken by the event.  The queue that contains the event
;;;3029   	list is locked, preventing simultaneous access from interrupts. */
;;;3030   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000006  4805              LDR      r0,|L26.28|
000008  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00000a  3118              ADDS     r1,r1,#0x18
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       vListInsert
;;;3031   
;;;3032   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3033   }
00001a  bd70              POP      {r4-r6,pc}
;;;3034   /*-----------------------------------------------------------*/
                          ENDP

                  |L26.28|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;3061   
;;;3062   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;3063   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;3064   		configASSERT( pxEventList );
;;;3065   
;;;3066   		/* This function should not be called by application code hence the
;;;3067   		'Restricted' in its name.  It is not part of the public API.  It is
;;;3068   		designed for use by kernel code, and has special calling requirements -
;;;3069   		it should be called with the scheduler suspended. */
;;;3070   
;;;3071   
;;;3072   		/* Place the event list item of the TCB in the appropriate event list.
;;;3073   		In this case it is assume that this is the only task that is going to
;;;3074   		be waiting on this event list, so the faster vListInsertEnd() function
;;;3075   		can be used in place of vListInsert. */
;;;3076   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000008  4806              LDR      r0,|L27.36|
00000a  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00000c  3118              ADDS     r1,r1,#0x18
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       vListInsertEnd
;;;3077   
;;;3078   		/* If the task should block indefinitely then set the block time to a
;;;3079   		value that will be recognised as an indefinite delay inside the
;;;3080   		prvAddCurrentTaskToDelayedList() function. */
;;;3081   		if( xWaitIndefinitely != pdFALSE )
000014  b10c              CBZ      r4,|L27.26|
;;;3082   		{
;;;3083   			xTicksToWait = portMAX_DELAY;
000016  f04f35ff          MOV      r5,#0xffffffff
                  |L27.26|
;;;3084   		}
;;;3085   
;;;3086   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;3087   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3088   	}
000022  bd70              POP      {r4-r6,pc}
;;;3089   
                          ENDP

                  |L27.36|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;3035   
;;;3036   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3037   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;3038   	configASSERT( pxEventList );
;;;3039   
;;;3040   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3041   	the event groups implementation. */
;;;3042   	configASSERT( uxSchedulerSuspended != 0 );
;;;3043   
;;;3044   	/* Store the item value in the event list item.  It is safe to access the
;;;3045   	event list item here as interrupts won't access the event list item of a
;;;3046   	task that is not in the Blocked state. */
;;;3047   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000008  f0444000          ORR      r0,r4,#0x80000000
00000c  4906              LDR      r1,|L28.40|
00000e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000010  6188              STR      r0,[r1,#0x18]
;;;3048   
;;;3049   	/* Place the event list item of the TCB at the end of the appropriate event
;;;3050   	list.  It is safe to access the event list here because it is part of an
;;;3051   	event group implementation - and interrupts don't access event groups
;;;3052   	directly (instead they access them indirectly by pending function calls to
;;;3053   	the task level). */
;;;3054   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000012  4805              LDR      r0,|L28.40|
000014  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000016  3118              ADDS     r1,r1,#0x18
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       vListInsertEnd
;;;3055   
;;;3056   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;3057   }
000026  bd70              POP      {r4-r6,pc}
;;;3058   /*-----------------------------------------------------------*/
                          ENDP

                  |L28.40|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1531   
;;;1532   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1533   	{
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;1534   	TCB_t *pxTCB;
;;;1535   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1536   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1537   
;;;1538   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;1539   
;;;1540   		/* Ensure the new priority is valid. */
;;;1541   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00000c  2d05              CMP      r5,#5
00000e  d300              BCC      |L29.18|
;;;1542   		{
;;;1543   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000010  2504              MOVS     r5,#4
                  |L29.18|
;;;1544   		}
;;;1545   		else
;;;1546   		{
;;;1547   			mtCOVERAGE_TEST_MARKER();
;;;1548   		}
;;;1549   
;;;1550   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1551   		{
;;;1552   			/* If null is passed in here then it is the priority of the calling
;;;1553   			task that is being changed. */
;;;1554   			pxTCB = prvGetTCBFromHandle( xTask );
000016  f1b80f00          CMP      r8,#0
00001a  d102              BNE      |L29.34|
00001c  482e              LDR      r0,|L29.216|
00001e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000020  e000              B        |L29.36|
                  |L29.34|
000022  4640              MOV      r0,r8
                  |L29.36|
000024  4604              MOV      r4,r0
;;;1555   
;;;1556   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1557   
;;;1558   			#if ( configUSE_MUTEXES == 1 )
;;;1559   			{
;;;1560   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1561   			}
;;;1562   			#else
;;;1563   			{
;;;1564   				uxCurrentBasePriority = pxTCB->uxPriority;
000026  6ae6              LDR      r6,[r4,#0x2c]
;;;1565   			}
;;;1566   			#endif
;;;1567   
;;;1568   			if( uxCurrentBasePriority != uxNewPriority )
000028  42ae              CMP      r6,r5
00002a  d051              BEQ      |L29.208|
;;;1569   			{
;;;1570   				/* The priority change may have readied a task of higher
;;;1571   				priority than the calling task. */
;;;1572   				if( uxNewPriority > uxCurrentBasePriority )
00002c  42b5              CMP      r5,r6
00002e  d90b              BLS      |L29.72|
;;;1573   				{
;;;1574   					if( pxTCB != pxCurrentTCB )
000030  4829              LDR      r0,|L29.216|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  4284              CMP      r4,r0
000036  d00d              BEQ      |L29.84|
;;;1575   					{
;;;1576   						/* The priority of a task other than the currently
;;;1577   						running task is being raised.  Is the priority being
;;;1578   						raised above that of the running task? */
;;;1579   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000038  4827              LDR      r0,|L29.216|
00003a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00003c  6ac0              LDR      r0,[r0,#0x2c]
00003e  42a8              CMP      r0,r5
000040  d808              BHI      |L29.84|
;;;1580   						{
;;;1581   							xYieldRequired = pdTRUE;
000042  f04f0901          MOV      r9,#1
000046  e005              B        |L29.84|
                  |L29.72|
;;;1582   						}
;;;1583   						else
;;;1584   						{
;;;1585   							mtCOVERAGE_TEST_MARKER();
;;;1586   						}
;;;1587   					}
;;;1588   					else
;;;1589   					{
;;;1590   						/* The priority of the running task is being raised,
;;;1591   						but the running task must already be the highest
;;;1592   						priority task able to run so no yield is required. */
;;;1593   					}
;;;1594   				}
;;;1595   				else if( pxTCB == pxCurrentTCB )
000048  4823              LDR      r0,|L29.216|
00004a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00004c  4284              CMP      r4,r0
00004e  d101              BNE      |L29.84|
;;;1596   				{
;;;1597   					/* Setting the priority of the running task down means
;;;1598   					there may now be another task of higher priority that
;;;1599   					is ready to execute. */
;;;1600   					xYieldRequired = pdTRUE;
000050  f04f0901          MOV      r9,#1
                  |L29.84|
;;;1601   				}
;;;1602   				else
;;;1603   				{
;;;1604   					/* Setting the priority of any other task down does not
;;;1605   					require a yield as the running task must be above the
;;;1606   					new priority of the task being modified. */
;;;1607   				}
;;;1608   
;;;1609   				/* Remember the ready list the task might be referenced from
;;;1610   				before its uxPriority member is changed so the
;;;1611   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1612   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000054  6ae7              LDR      r7,[r4,#0x2c]
;;;1613   
;;;1614   				#if ( configUSE_MUTEXES == 1 )
;;;1615   				{
;;;1616   					/* Only change the priority being used if the task is not
;;;1617   					currently using an inherited priority. */
;;;1618   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
;;;1619   					{
;;;1620   						pxTCB->uxPriority = uxNewPriority;
;;;1621   					}
;;;1622   					else
;;;1623   					{
;;;1624   						mtCOVERAGE_TEST_MARKER();
;;;1625   					}
;;;1626   
;;;1627   					/* The base priority gets set whatever. */
;;;1628   					pxTCB->uxBasePriority = uxNewPriority;
;;;1629   				}
;;;1630   				#else
;;;1631   				{
;;;1632   					pxTCB->uxPriority = uxNewPriority;
000056  62e5              STR      r5,[r4,#0x2c]
;;;1633   				}
;;;1634   				#endif
;;;1635   
;;;1636   				/* Only reset the event list item value if the value is not
;;;1637   				being used for anything else. */
;;;1638   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000058  69a0              LDR      r0,[r4,#0x18]
00005a  f0004000          AND      r0,r0,#0x80000000
00005e  b910              CBNZ     r0,|L29.102|
;;;1639   				{
;;;1640   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000060  f1c50005          RSB      r0,r5,#5
000064  61a0              STR      r0,[r4,#0x18]
                  |L29.102|
;;;1641   				}
;;;1642   				else
;;;1643   				{
;;;1644   					mtCOVERAGE_TEST_MARKER();
;;;1645   				}
;;;1646   
;;;1647   				/* If the task is in the blocked or suspended list we need do
;;;1648   				nothing more than change its priority variable. However, if
;;;1649   				the task is in a ready list it needs to be removed and placed
;;;1650   				in the list appropriate to its new priority. */
;;;1651   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000066  eb070187          ADD      r1,r7,r7,LSL #2
00006a  4a1c              LDR      r2,|L29.220|
00006c  eb020181          ADD      r1,r2,r1,LSL #2
000070  6960              LDR      r0,[r4,#0x14]
000072  4288              CMP      r0,r1
000074  d101              BNE      |L29.122|
000076  2001              MOVS     r0,#1
000078  e000              B        |L29.124|
                  |L29.122|
00007a  2000              MOVS     r0,#0
                  |L29.124|
00007c  b1e0              CBZ      r0,|L29.184|
;;;1652   				{
;;;1653   					/* The task is currently in its ready list - remove before
;;;1654   					adding it to it's new ready list.  As we are in a critical
;;;1655   					section we can do this even if the scheduler is suspended. */
;;;1656   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00007e  1d20              ADDS     r0,r4,#4
000080  f7fffffe          BL       uxListRemove
000084  b930              CBNZ     r0,|L29.148|
;;;1657   					{
;;;1658   						/* It is known that the task is in its ready list so
;;;1659   						there is no need to check again and the port level
;;;1660   						reset macro can be called directly. */
;;;1661   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
000086  2001              MOVS     r0,#1
000088  40b8              LSLS     r0,r0,r7
00008a  4915              LDR      r1,|L29.224|
00008c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00008e  4381              BICS     r1,r1,r0
000090  4813              LDR      r0,|L29.224|
000092  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L29.148|
;;;1662   					}
;;;1663   					else
;;;1664   					{
;;;1665   						mtCOVERAGE_TEST_MARKER();
;;;1666   					}
;;;1667   					prvAddTaskToReadyList( pxTCB );
000094  f894102c          LDRB     r1,[r4,#0x2c]
000098  2001              MOVS     r0,#1
00009a  4088              LSLS     r0,r0,r1
00009c  4910              LDR      r1,|L29.224|
00009e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
0000a0  4308              ORRS     r0,r0,r1
0000a2  490f              LDR      r1,|L29.224|
0000a4  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
0000a6  6ae1              LDR      r1,[r4,#0x2c]
0000a8  eb010181          ADD      r1,r1,r1,LSL #2
0000ac  4a0b              LDR      r2,|L29.220|
0000ae  eb020081          ADD      r0,r2,r1,LSL #2
0000b2  1d21              ADDS     r1,r4,#4
0000b4  f7fffffe          BL       vListInsertEnd
                  |L29.184|
;;;1668   				}
;;;1669   				else
;;;1670   				{
;;;1671   					mtCOVERAGE_TEST_MARKER();
;;;1672   				}
;;;1673   
;;;1674   				if( xYieldRequired != pdFALSE )
0000b8  f1b90f00          CMP      r9,#0
0000bc  d007              BEQ      |L29.206|
;;;1675   				{
;;;1676   					taskYIELD_IF_USING_PREEMPTION();
0000be  f04f5080          MOV      r0,#0x10000000
0000c2  4908              LDR      r1,|L29.228|
0000c4  6008              STR      r0,[r1,#0]
0000c6  f3bf8f4f          DSB      
0000ca  f3bf8f6f          ISB      
                  |L29.206|
;;;1677   				}
;;;1678   				else
;;;1679   				{
;;;1680   					mtCOVERAGE_TEST_MARKER();
;;;1681   				}
;;;1682   
;;;1683   				/* Remove compiler warning about unused variables when the port
;;;1684   				optimised task selection is not being used. */
;;;1685   				( void ) uxPriorityUsedOnEntry;
0000ce  bf00              NOP      
                  |L29.208|
;;;1686   			}
;;;1687   		}
;;;1688   		taskEXIT_CRITICAL();
0000d0  f7fffffe          BL       vPortExitCritical
;;;1689   	}
0000d4  e8bd87f0          POP      {r4-r10,pc}
;;;1690   
                          ENDP

                  |L29.216|
                          DCD      pxCurrentTCB
                  |L29.220|
                          DCD      pxReadyTasksLists
                  |L29.224|
                          DCD      uxTopReadyPriority
                  |L29.228|
                          DCD      0xe000ed04

                          AREA ||i.vTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskRemoveFromUnorderedEventList PROC
;;;3160   
;;;3161   void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;3162   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;3163   TCB_t *pxUnblockedTCB;
;;;3164   
;;;3165   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3166   	the event flags implementation. */
;;;3167   	configASSERT( uxSchedulerSuspended != pdFALSE );
;;;3168   
;;;3169   	/* Store the new item value in the event list. */
;;;3170   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000006  f0464000          ORR      r0,r6,#0x80000000
00000a  6028              STR      r0,[r5,#0]
;;;3171   
;;;3172   	/* Remove the event list form the event flag.  Interrupts do not access
;;;3173   	event flags. */
;;;3174   	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00000c  68ec              LDR      r4,[r5,#0xc]
;;;3175   	configASSERT( pxUnblockedTCB );
;;;3176   	( void ) uxListRemove( pxEventListItem );
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       uxListRemove
;;;3177   
;;;3178   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;3179   	scheduler is suspended so interrupts will not be accessing the ready
;;;3180   	lists. */
;;;3181   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;3182   	prvAddTaskToReadyList( pxUnblockedTCB );
00001a  f894102c          LDRB     r1,[r4,#0x2c]
00001e  2001              MOVS     r0,#1
000020  4088              LSLS     r0,r0,r1
000022  490c              LDR      r1,|L30.84|
000024  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000026  4308              ORRS     r0,r0,r1
000028  490a              LDR      r1,|L30.84|
00002a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00002c  6ae1              LDR      r1,[r4,#0x2c]
00002e  eb010181          ADD      r1,r1,r1,LSL #2
000032  4a09              LDR      r2,|L30.88|
000034  eb020081          ADD      r0,r2,r1,LSL #2
000038  1d21              ADDS     r1,r4,#4
00003a  f7fffffe          BL       vListInsertEnd
;;;3183   
;;;3184   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00003e  4907              LDR      r1,|L30.92|
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000044  6ac9              LDR      r1,[r1,#0x2c]
000046  4288              CMP      r0,r1
000048  d902              BLS      |L30.80|
;;;3185   	{
;;;3186   		/* The unblocked task has a priority above that of the calling task, so
;;;3187   		a context switch is required.  This function is called with the
;;;3188   		scheduler suspended so xYieldPending is set so the context switch
;;;3189   		occurs immediately that the scheduler is resumed (unsuspended). */
;;;3190   		xYieldPending = pdTRUE;
00004a  2001              MOVS     r0,#1
00004c  4904              LDR      r1,|L30.96|
00004e  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L30.80|
;;;3191   	}
;;;3192   }
000050  bd70              POP      {r4-r6,pc}
;;;3193   /*-----------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L30.84|
                          DCD      uxTopReadyPriority
                  |L30.88|
                          DCD      pxReadyTasksLists
                  |L30.92|
                          DCD      pxCurrentTCB
                  |L30.96|
                          DCD      xYieldPending

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1842   
;;;1843   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1844   	{
000002  4605              MOV      r5,r0
;;;1845   	TCB_t * const pxTCB = xTaskToResume;
000004  462c              MOV      r4,r5
;;;1846   
;;;1847   		/* It does not make sense to resume the calling task. */
;;;1848   		configASSERT( xTaskToResume );
;;;1849   
;;;1850   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1851   		currently executing task. */
;;;1852   		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
000006  4818              LDR      r0,|L31.104|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  4284              CMP      r4,r0
00000c  d02b              BEQ      |L31.102|
00000e  b354              CBZ      r4,|L31.102|
;;;1853   		{
;;;1854   			taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1855   			{
;;;1856   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvTaskIsTaskSuspended
00001a  b310              CBZ      r0,|L31.98|
;;;1857   				{
;;;1858   					traceTASK_RESUME( pxTCB );
;;;1859   
;;;1860   					/* The ready list can be accessed even if the scheduler is
;;;1861   					suspended because this is inside a critical section. */
;;;1862   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;1863   					prvAddTaskToReadyList( pxTCB );
000022  f894102c          LDRB     r1,[r4,#0x2c]
000026  2001              MOVS     r0,#1
000028  4088              LSLS     r0,r0,r1
00002a  4910              LDR      r1,|L31.108|
00002c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00002e  4308              ORRS     r0,r0,r1
000030  490e              LDR      r1,|L31.108|
000032  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000034  6ae1              LDR      r1,[r4,#0x2c]
000036  eb010181          ADD      r1,r1,r1,LSL #2
00003a  4a0d              LDR      r2,|L31.112|
00003c  eb020081          ADD      r0,r2,r1,LSL #2
000040  1d21              ADDS     r1,r4,#4
000042  f7fffffe          BL       vListInsertEnd
;;;1864   
;;;1865   					/* A higher priority task may have just been resumed. */
;;;1866   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000046  4908              LDR      r1,|L31.104|
000048  6ae0              LDR      r0,[r4,#0x2c]
00004a  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004c  6ac9              LDR      r1,[r1,#0x2c]
00004e  4288              CMP      r0,r1
000050  d307              BCC      |L31.98|
;;;1867   					{
;;;1868   						/* This yield may not cause the task just resumed to run,
;;;1869   						but will leave the lists in the correct state for the
;;;1870   						next yield. */
;;;1871   						taskYIELD_IF_USING_PREEMPTION();
000052  f04f5080          MOV      r0,#0x10000000
000056  4907              LDR      r1,|L31.116|
000058  6008              STR      r0,[r1,#0]
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
                  |L31.98|
;;;1872   					}
;;;1873   					else
;;;1874   					{
;;;1875   						mtCOVERAGE_TEST_MARKER();
;;;1876   					}
;;;1877   				}
;;;1878   				else
;;;1879   				{
;;;1880   					mtCOVERAGE_TEST_MARKER();
;;;1881   				}
;;;1882   			}
;;;1883   			taskEXIT_CRITICAL();
000062  f7fffffe          BL       vPortExitCritical
                  |L31.102|
;;;1884   		}
;;;1885   		else
;;;1886   		{
;;;1887   			mtCOVERAGE_TEST_MARKER();
;;;1888   		}
;;;1889   	}
000066  bd70              POP      {r4-r6,pc}
;;;1890   
                          ENDP

                  |L31.104|
                          DCD      pxCurrentTCB
                  |L31.108|
                          DCD      uxTopReadyPriority
                  |L31.112|
                          DCD      pxReadyTasksLists
                  |L31.116|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3194   
;;;3195   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3196   {
000002  4604              MOV      r4,r0
;;;3197   	configASSERT( pxTimeOut );
;;;3198   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;3199   	{
;;;3200   		pxTimeOut->xOverflowCount = xNumOfOverflows;
000008  4804              LDR      r0,|L32.28|
00000a  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
00000c  6020              STR      r0,[r4,#0]
;;;3201   		pxTimeOut->xTimeOnEntering = xTickCount;
00000e  4804              LDR      r0,|L32.32|
000010  6800              LDR      r0,[r0,#0]  ; xTickCount
000012  6060              STR      r0,[r4,#4]
;;;3202   	}
;;;3203   	taskEXIT_CRITICAL();
000014  f7fffffe          BL       vPortExitCritical
;;;3204   }
000018  bd10              POP      {r4,pc}
;;;3205   /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L32.28|
                          DCD      xNumOfOverflows
                  |L32.32|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1966   
;;;1967   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1968   {
;;;1969   BaseType_t xReturn;
;;;1970   
;;;1971   	/* Add the idle task at the lowest priority. */
;;;1972   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1973   	{
;;;1974   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1975   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1976   		uint32_t ulIdleTaskStackSize;
;;;1977   
;;;1978   		/* The Idle task is created using user provided RAM - obtain the
;;;1979   		address of the RAM then create the idle task. */
;;;1980   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1981   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1982   												configIDLE_TASK_NAME,
;;;1983   												ulIdleTaskStackSize,
;;;1984   												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
;;;1985   												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;1986   												pxIdleTaskStackBuffer,
;;;1987   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1988   
;;;1989   		if( xIdleTaskHandle != NULL )
;;;1990   		{
;;;1991   			xReturn = pdPASS;
;;;1992   		}
;;;1993   		else
;;;1994   		{
;;;1995   			xReturn = pdFAIL;
;;;1996   		}
;;;1997   	}
;;;1998   	#else
;;;1999   	{
;;;2000   		/* The Idle task is being created using dynamically allocated RAM. */
;;;2001   		xReturn = xTaskCreate(	prvIdleTask,
000002  4814              LDR      r0,|L33.84|
000004  2100              MOVS     r1,#0
000006  460b              MOV      r3,r1
000008  2280              MOVS     r2,#0x80
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  a112              ADR      r1,|L33.88|
000010  4813              LDR      r0,|L33.96|
000012  f7fffffe          BL       xTaskCreate
000016  4604              MOV      r4,r0
;;;2002   								configIDLE_TASK_NAME,
;;;2003   								configMINIMAL_STACK_SIZE,
;;;2004   								( void * ) NULL,
;;;2005   								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
;;;2006   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;2007   	}
;;;2008   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;2009   
;;;2010   	#if ( configUSE_TIMERS == 1 )
;;;2011   	{
;;;2012   		if( xReturn == pdPASS )
000018  2c01              CMP      r4,#1
00001a  d102              BNE      |L33.34|
;;;2013   		{
;;;2014   			xReturn = xTimerCreateTimerTask();
00001c  f7fffffe          BL       xTimerCreateTimerTask
000020  4604              MOV      r4,r0
                  |L33.34|
;;;2015   		}
;;;2016   		else
;;;2017   		{
;;;2018   			mtCOVERAGE_TEST_MARKER();
;;;2019   		}
;;;2020   	}
;;;2021   	#endif /* configUSE_TIMERS */
;;;2022   
;;;2023   	if( xReturn == pdPASS )
000022  2c01              CMP      r4,#1
000024  d114              BNE      |L33.80|
;;;2024   	{
;;;2025   		/* freertos_tasks_c_additions_init() should only be called if the user
;;;2026   		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
;;;2027   		the only macro called by the function. */
;;;2028   		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;;;2029   		{
;;;2030   			freertos_tasks_c_additions_init();
;;;2031   		}
;;;2032   		#endif
;;;2033   
;;;2034   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;2035   		before or during the call to xPortStartScheduler().  The stacks of
;;;2036   		the created tasks contain a status word with interrupts switched on
;;;2037   		so interrupts will automatically get re-enabled when the first task
;;;2038   		starts to run. */
;;;2039   		portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  20bf              MOVS     r0,#0xbf
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;2040   
;;;2041   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2042   		{
;;;2043   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2044   			structure specific to the task that will run first. */
;;;2045   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2046   		}
;;;2047   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2048   
;;;2049   		xNextTaskUnblockTime = portMAX_DELAY;
000038  f04f30ff          MOV      r0,#0xffffffff
00003c  4909              LDR      r1,|L33.100|
00003e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2050   		xSchedulerRunning = pdTRUE;
000040  2001              MOVS     r0,#1
000042  4909              LDR      r1,|L33.104|
000044  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;2051   		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
000046  2000              MOVS     r0,#0
000048  4908              LDR      r1,|L33.108|
00004a  6008              STR      r0,[r1,#0]  ; xTickCount
;;;2052   
;;;2053   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;2054   		macro must be defined to configure the timer/counter used to generate
;;;2055   		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
;;;2056   		is set to 0 and the following line fails to build then ensure you do not
;;;2057   		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
;;;2058   		FreeRTOSConfig.h file. */
;;;2059   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;2060   
;;;2061   		traceTASK_SWITCHED_IN();
;;;2062   
;;;2063   		/* Setting up the timer tick is hardware specific and thus in the
;;;2064   		portable interface. */
;;;2065   		if( xPortStartScheduler() != pdFALSE )
00004c  f7fffffe          BL       xPortStartScheduler
                  |L33.80|
;;;2066   		{
;;;2067   			/* Should not reach here as if the scheduler is running the
;;;2068   			function will not return. */
;;;2069   		}
;;;2070   		else
;;;2071   		{
;;;2072   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;2073   		}
;;;2074   	}
;;;2075   	else
;;;2076   	{
;;;2077   		/* This line will only be reached if the kernel could not be started,
;;;2078   		because there was not enough FreeRTOS heap to create the idle task
;;;2079   		or the timer task. */
;;;2080   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
;;;2081   	}
;;;2082   
;;;2083   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;2084   	meaning xIdleTaskHandle is not used anywhere else. */
;;;2085   	( void ) xIdleTaskHandle;
;;;2086   }
000050  bd1c              POP      {r2-r4,pc}
;;;2087   /*-----------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L33.84|
                          DCD      xIdleTaskHandle
                  |L33.88|
000058  49444c45          DCB      "IDLE",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L33.96|
                          DCD      prvIdleTask
                  |L33.100|
                          DCD      xNextTaskUnblockTime
                  |L33.104|
                          DCD      xSchedulerRunning
                  |L33.108|
                          DCD      xTickCount

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1695   
;;;1696   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1697   	{
000002  4605              MOV      r5,r0
;;;1698   	TCB_t *pxTCB;
;;;1699   
;;;1700   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1701   		{
;;;1702   			/* If null is passed in here then it is the running task that is
;;;1703   			being suspended. */
;;;1704   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L34.16|
00000a  4829              LDR      r0,|L34.176|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L34.18|
                  |L34.16|
000010  4628              MOV      r0,r5
                  |L34.18|
000012  4604              MOV      r4,r0
;;;1705   
;;;1706   			traceTASK_SUSPEND( pxTCB );
;;;1707   
;;;1708   			/* Remove task from the ready/delayed list and place in the
;;;1709   			suspended list. */
;;;1710   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
00001a  b978              CBNZ     r0,|L34.60|
;;;1711   			{
;;;1712   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00001c  6ae0              LDR      r0,[r4,#0x2c]
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  4924              LDR      r1,|L34.180|
000024  f8510020          LDR      r0,[r1,r0,LSL #2]
000028  b940              CBNZ     r0,|L34.60|
00002a  f894102c          LDRB     r1,[r4,#0x2c]
00002e  2001              MOVS     r0,#1
000030  4088              LSLS     r0,r0,r1
000032  4921              LDR      r1,|L34.184|
000034  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000036  4381              BICS     r1,r1,r0
000038  481f              LDR      r0,|L34.184|
00003a  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
                  |L34.60|
;;;1713   			}
;;;1714   			else
;;;1715   			{
;;;1716   				mtCOVERAGE_TEST_MARKER();
;;;1717   			}
;;;1718   
;;;1719   			/* Is the task waiting on an event also? */
;;;1720   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00003c  6aa0              LDR      r0,[r4,#0x28]
00003e  b118              CBZ      r0,|L34.72|
;;;1721   			{
;;;1722   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000040  f1040018          ADD      r0,r4,#0x18
000044  f7fffffe          BL       uxListRemove
                  |L34.72|
;;;1723   			}
;;;1724   			else
;;;1725   			{
;;;1726   				mtCOVERAGE_TEST_MARKER();
;;;1727   			}
;;;1728   
;;;1729   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000048  1d21              ADDS     r1,r4,#4
00004a  481c              LDR      r0,|L34.188|
00004c  f7fffffe          BL       vListInsertEnd
;;;1730   
;;;1731   			#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1732   			{
;;;1733   				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000050  f8940048          LDRB     r0,[r4,#0x48]
000054  2801              CMP      r0,#1
000056  d102              BNE      |L34.94|
;;;1734   				{
;;;1735   					/* The task was blocked to wait for a notification, but is
;;;1736   					now suspended, so no notification was received. */
;;;1737   					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000058  2000              MOVS     r0,#0
00005a  f8840048          STRB     r0,[r4,#0x48]
                  |L34.94|
;;;1738   				}
;;;1739   			}
;;;1740   			#endif
;;;1741   		}
;;;1742   		taskEXIT_CRITICAL();
00005e  f7fffffe          BL       vPortExitCritical
;;;1743   
;;;1744   		if( xSchedulerRunning != pdFALSE )
000062  4817              LDR      r0,|L34.192|
000064  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000066  b128              CBZ      r0,|L34.116|
;;;1745   		{
;;;1746   			/* Reset the next expected unblock time in case it referred to the
;;;1747   			task that is now in the Suspended state. */
;;;1748   			taskENTER_CRITICAL();
000068  f7fffffe          BL       vPortEnterCritical
;;;1749   			{
;;;1750   				prvResetNextTaskUnblockTime();
00006c  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1751   			}
;;;1752   			taskEXIT_CRITICAL();
000070  f7fffffe          BL       vPortExitCritical
                  |L34.116|
;;;1753   		}
;;;1754   		else
;;;1755   		{
;;;1756   			mtCOVERAGE_TEST_MARKER();
;;;1757   		}
;;;1758   
;;;1759   		if( pxTCB == pxCurrentTCB )
000074  480e              LDR      r0,|L34.176|
000076  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000078  4284              CMP      r4,r0
00007a  d117              BNE      |L34.172|
;;;1760   		{
;;;1761   			if( xSchedulerRunning != pdFALSE )
00007c  4810              LDR      r0,|L34.192|
00007e  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000080  b140              CBZ      r0,|L34.148|
;;;1762   			{
;;;1763   				/* The current task has just been suspended. */
;;;1764   				configASSERT( uxSchedulerSuspended == 0 );
;;;1765   				portYIELD_WITHIN_API();
000082  f04f5080          MOV      r0,#0x10000000
000086  490f              LDR      r1,|L34.196|
000088  6008              STR      r0,[r1,#0]
00008a  f3bf8f4f          DSB      
00008e  f3bf8f6f          ISB      
000092  e00b              B        |L34.172|
                  |L34.148|
;;;1766   			}
;;;1767   			else
;;;1768   			{
;;;1769   				/* The scheduler is not running, but the task that was pointed
;;;1770   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1771   				must be adjusted to point to a different task. */
;;;1772   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
000094  4809              LDR      r0,|L34.188|
000096  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
000098  490b              LDR      r1,|L34.200|
00009a  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
00009c  4288              CMP      r0,r1
00009e  d103              BNE      |L34.168|
;;;1773   				{
;;;1774   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1775   					NULL so when the next task is created pxCurrentTCB will
;;;1776   					be set to point to it no matter what its relative priority
;;;1777   					is. */
;;;1778   					pxCurrentTCB = NULL;
0000a0  2000              MOVS     r0,#0
0000a2  4903              LDR      r1,|L34.176|
0000a4  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
0000a6  e001              B        |L34.172|
                  |L34.168|
;;;1779   				}
;;;1780   				else
;;;1781   				{
;;;1782   					vTaskSwitchContext();
0000a8  f7fffffe          BL       vTaskSwitchContext
                  |L34.172|
;;;1783   				}
;;;1784   			}
;;;1785   		}
;;;1786   		else
;;;1787   		{
;;;1788   			mtCOVERAGE_TEST_MARKER();
;;;1789   		}
;;;1790   	}
0000ac  bd70              POP      {r4-r6,pc}
;;;1791   
                          ENDP

0000ae  0000              DCW      0x0000
                  |L34.176|
                          DCD      pxCurrentTCB
                  |L34.180|
                          DCD      pxReadyTasksLists
                  |L34.184|
                          DCD      uxTopReadyPriority
                  |L34.188|
                          DCD      xSuspendedTaskList
                  |L34.192|
                          DCD      xSchedulerRunning
                  |L34.196|
                          DCD      0xe000ed04
                  |L34.200|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;2099   
;;;2100   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L35.12|
;;;2101   {
;;;2102   	/* A critical section is not required as the variable is of type
;;;2103   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;2104   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;2105   	http://goo.gl/wu4acr */
;;;2106   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L35.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2107   }
00000a  4770              BX       lr
;;;2108   /*----------------------------------------------------------*/
                          ENDP

                  |L35.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2945   
;;;2946   void vTaskSwitchContext( void )
000000  4812              LDR      r0,|L36.76|
;;;2947   {
;;;2948   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  b118              CBZ      r0,|L36.14|
;;;2949   	{
;;;2950   		/* The scheduler is currently suspended - do not allow a context
;;;2951   		switch. */
;;;2952   		xYieldPending = pdTRUE;
000006  2001              MOVS     r0,#1
000008  4911              LDR      r1,|L36.80|
00000a  6008              STR      r0,[r1,#0]  ; xYieldPending
00000c  e01d              B        |L36.74|
                  |L36.14|
;;;2953   	}
;;;2954   	else
;;;2955   	{
;;;2956   		xYieldPending = pdFALSE;
00000e  2000              MOVS     r0,#0
000010  490f              LDR      r1,|L36.80|
000012  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2957   		traceTASK_SWITCHED_OUT();
;;;2958   
;;;2959   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2960   		{
;;;2961   			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2962   				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2963   			#else
;;;2964   				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2965   			#endif
;;;2966   
;;;2967   			/* Add the amount of time the task has been running to the
;;;2968   			accumulated time so far.  The time the task started running was
;;;2969   			stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2970   			protection here so count values are only valid until the timer
;;;2971   			overflows.  The guard against negative values is to protect
;;;2972   			against suspect run time stat counter implementations - which
;;;2973   			are provided by the application, not the kernel. */
;;;2974   			if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2975   			{
;;;2976   				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2977   			}
;;;2978   			else
;;;2979   			{
;;;2980   				mtCOVERAGE_TEST_MARKER();
;;;2981   			}
;;;2982   			ulTaskSwitchedInTime = ulTotalRunTime;
;;;2983   		}
;;;2984   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2985   
;;;2986   		/* Check for stack overflow, if configured. */
;;;2987   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2988   
;;;2989   		/* Before the currently running task is switched out, save its errno. */
;;;2990   		#if( configUSE_POSIX_ERRNO == 1 )
;;;2991   		{
;;;2992   			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
;;;2993   		}
;;;2994   		#endif
;;;2995   
;;;2996   		/* Select a new task to run using either the generic C or port
;;;2997   		optimised asm code. */
;;;2998   		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000014  480f              LDR      r0,|L36.84|
000016  6800              LDR      r0,[r0,#0]  ; uxTopReadyPriority
000018  fab0f080          CLZ      r0,r0
00001c  f1c0011f          RSB      r1,r0,#0x1f
000020  eb010281          ADD      r2,r1,r1,LSL #2
000024  4b0c              LDR      r3,|L36.88|
000026  eb030082          ADD      r0,r3,r2,LSL #2
00002a  6842              LDR      r2,[r0,#4]
00002c  6852              LDR      r2,[r2,#4]
00002e  6042              STR      r2,[r0,#4]
000030  f1000208          ADD      r2,r0,#8
000034  6843              LDR      r3,[r0,#4]
000036  4293              CMP      r3,r2
000038  d102              BNE      |L36.64|
00003a  6842              LDR      r2,[r0,#4]
00003c  6852              LDR      r2,[r2,#4]
00003e  6042              STR      r2,[r0,#4]
                  |L36.64|
000040  6842              LDR      r2,[r0,#4]
000042  68d2              LDR      r2,[r2,#0xc]
000044  4b05              LDR      r3,|L36.92|
000046  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
000048  bf00              NOP      
                  |L36.74|
;;;2999   		traceTASK_SWITCHED_IN();
;;;3000   
;;;3001   		/* After the new task is switched in, update the global errno. */
;;;3002   		#if( configUSE_POSIX_ERRNO == 1 )
;;;3003   		{
;;;3004   			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
;;;3005   		}
;;;3006   		#endif
;;;3007   
;;;3008   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3009   		{
;;;3010   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;3011   			structure specific to this task. */
;;;3012   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;3013   		}
;;;3014   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3015   	}
;;;3016   }
00004a  4770              BX       lr
;;;3017   /*-----------------------------------------------------------*/
                          ENDP

                  |L36.76|
                          DCD      uxSchedulerSuspended
                  |L36.80|
                          DCD      xYieldPending
                  |L36.84|
                          DCD      uxTopReadyPriority
                  |L36.88|
                          DCD      pxReadyTasksLists
                  |L36.92|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3214   
;;;3215   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3216   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;3217   BaseType_t xReturn;
;;;3218   
;;;3219   	configASSERT( pxTimeOut );
;;;3220   	configASSERT( pxTicksToWait );
;;;3221   
;;;3222   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;3223   	{
;;;3224   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3225   		const TickType_t xConstTickCount = xTickCount;
00000a  4812              LDR      r0,|L37.84|
00000c  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;3226   		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
00000e  6870              LDR      r0,[r6,#4]
000010  1a13              SUBS     r3,r2,r0
;;;3227   
;;;3228   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3229   			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
;;;3230   			{
;;;3231   				/* The delay was aborted, which is not the same as a time out,
;;;3232   				but has the same result. */
;;;3233   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3234   				xReturn = pdTRUE;
;;;3235   			}
;;;3236   			else
;;;3237   		#endif
;;;3238   
;;;3239   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3240   			if( *pxTicksToWait == portMAX_DELAY )
000012  6820              LDR      r0,[r4,#0]
000014  1c40              ADDS     r0,r0,#1
000016  b908              CBNZ     r0,|L37.28|
;;;3241   			{
;;;3242   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3243   				specified is the maximum block time then the task should block
;;;3244   				indefinitely, and therefore never time out. */
;;;3245   				xReturn = pdFALSE;
000018  2500              MOVS     r5,#0
00001a  e017              B        |L37.76|
                  |L37.28|
;;;3246   			}
;;;3247   			else
;;;3248   		#endif
;;;3249   
;;;3250   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
00001c  490e              LDR      r1,|L37.88|
00001e  6830              LDR      r0,[r6,#0]
000020  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000022  4288              CMP      r0,r1
000024  d004              BEQ      |L37.48|
000026  6870              LDR      r0,[r6,#4]
000028  4290              CMP      r0,r2
00002a  d801              BHI      |L37.48|
;;;3251   		{
;;;3252   			/* The tick count is greater than the time at which
;;;3253   			vTaskSetTimeout() was called, but has also overflowed since
;;;3254   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3255   			around and gone past again. This passed since vTaskSetTimeout()
;;;3256   			was called. */
;;;3257   			xReturn = pdTRUE;
00002c  2501              MOVS     r5,#1
00002e  e00d              B        |L37.76|
                  |L37.48|
;;;3258   		}
;;;3259   		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
000030  6820              LDR      r0,[r4,#0]
000032  4298              CMP      r0,r3
000034  d907              BLS      |L37.70|
;;;3260   		{
;;;3261   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3262   			*pxTicksToWait -= xElapsedTime;
000036  6820              LDR      r0,[r4,#0]
000038  1ac0              SUBS     r0,r0,r3
00003a  6020              STR      r0,[r4,#0]
;;;3263   			vTaskInternalSetTimeOutState( pxTimeOut );
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       vTaskInternalSetTimeOutState
;;;3264   			xReturn = pdFALSE;
000042  2500              MOVS     r5,#0
000044  e002              B        |L37.76|
                  |L37.70|
;;;3265   		}
;;;3266   		else
;;;3267   		{
;;;3268   			*pxTicksToWait = 0;
000046  2000              MOVS     r0,#0
000048  6020              STR      r0,[r4,#0]
;;;3269   			xReturn = pdTRUE;
00004a  2501              MOVS     r5,#1
                  |L37.76|
;;;3270   		}
;;;3271   	}
;;;3272   	taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;3273   
;;;3274   	return xReturn;
000050  4628              MOV      r0,r5
;;;3275   }
000052  bd70              POP      {r4-r6,pc}
;;;3276   /*-----------------------------------------------------------*/
                          ENDP

                  |L37.84|
                          DCD      xTickCount
                  |L37.88|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;729    
;;;730    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;731    							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;732    							const configSTACK_DEPTH_TYPE usStackDepth,
;;;733    							void * const pvParameters,
;;;734    							UBaseType_t uxPriority,
;;;735    							TaskHandle_t * const pxCreatedTask )
;;;736    	{
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  e9ddab12          LDRD     r10,r11,[sp,#0x48]
;;;737    	TCB_t *pxNewTCB;
;;;738    	BaseType_t xReturn;
;;;739    
;;;740    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;741    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;742    		the TCB then the stack. */
;;;743    		#if( portSTACK_GROWTH > 0 )
;;;744    		{
;;;745    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;746    			the implementation of the port malloc function and whether or not static
;;;747    			allocation is being used. */
;;;748    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;749    
;;;750    			if( pxNewTCB != NULL )
;;;751    			{
;;;752    				/* Allocate space for the stack used by the task being created.
;;;753    				The base of the stack memory stored in the TCB so the task can
;;;754    				be deleted later if required. */
;;;755    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;756    
;;;757    				if( pxNewTCB->pxStack == NULL )
;;;758    				{
;;;759    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;760    					vPortFree( pxNewTCB );
;;;761    					pxNewTCB = NULL;
;;;762    				}
;;;763    			}
;;;764    		}
;;;765    		#else /* portSTACK_GROWTH */
;;;766    		{
;;;767    		StackType_t *pxStack;
;;;768    
;;;769    			/* Allocate space for the stack used by the task being created. */
;;;770    			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
000010  00b8              LSLS     r0,r7,#2
000012  f7fffffe          BL       pvPortMalloc
000016  4606              MOV      r6,r0
;;;771    
;;;772    			if( pxStack != NULL )
000018  b156              CBZ      r6,|L38.48|
;;;773    			{
;;;774    				/* Allocate space for the TCB. */
;;;775    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
00001a  204c              MOVS     r0,#0x4c
00001c  f7fffffe          BL       pvPortMalloc
000020  4604              MOV      r4,r0
;;;776    
;;;777    				if( pxNewTCB != NULL )
000022  b10c              CBZ      r4,|L38.40|
;;;778    				{
;;;779    					/* Store the stack location in the TCB. */
;;;780    					pxNewTCB->pxStack = pxStack;
000024  6326              STR      r6,[r4,#0x30]
000026  e004              B        |L38.50|
                  |L38.40|
;;;781    				}
;;;782    				else
;;;783    				{
;;;784    					/* The stack cannot be used as the TCB was not created.  Free
;;;785    					it again. */
;;;786    					vPortFree( pxStack );
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       vPortFree
00002e  e000              B        |L38.50|
                  |L38.48|
;;;787    				}
;;;788    			}
;;;789    			else
;;;790    			{
;;;791    				pxNewTCB = NULL;
000030  2400              MOVS     r4,#0
                  |L38.50|
;;;792    			}
;;;793    		}
;;;794    		#endif /* portSTACK_GROWTH */
;;;795    
;;;796    		if( pxNewTCB != NULL )
000032  b17c              CBZ      r4,|L38.84|
;;;797    		{
;;;798    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
;;;799    			{
;;;800    				/* Tasks can be created statically or dynamically, so note this
;;;801    				task was created dynamically in case it is later deleted. */
;;;802    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;803    			}
;;;804    			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
;;;805    
;;;806    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000034  2000              MOVS     r0,#0
000036  e9cdab00          STRD     r10,r11,[sp,#0]
00003a  e9cd4002          STRD     r4,r0,[sp,#8]
00003e  463a              MOV      r2,r7
000040  4649              MOV      r1,r9
000042  4640              MOV      r0,r8
000044  9b08              LDR      r3,[sp,#0x20]
000046  f7fffffe          BL       prvInitialiseNewTask
;;;807    			prvAddNewTaskToReadyList( pxNewTCB );
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       prvAddNewTaskToReadyList
;;;808    			xReturn = pdPASS;
000050  2501              MOVS     r5,#1
000052  e001              B        |L38.88|
                  |L38.84|
;;;809    		}
;;;810    		else
;;;811    		{
;;;812    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000054  f04f35ff          MOV      r5,#0xffffffff
                  |L38.88|
;;;813    		}
;;;814    
;;;815    		return xReturn;
000058  4628              MOV      r0,r5
;;;816    	}
00005a  b009              ADD      sp,sp,#0x24
00005c  e8bd8ff0          POP      {r4-r11,pc}
;;;817    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4713   
;;;4714   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4715   	{
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;4716   	TCB_t * pxTCB;
;;;4717   	BaseType_t xReturn = pdPASS;
00000c  f04f0a01          MOV      r10,#1
;;;4718   	uint8_t ucOriginalNotifyState;
;;;4719   
;;;4720   		configASSERT( xTaskToNotify );
;;;4721   		pxTCB = xTaskToNotify;
000010  464c              MOV      r4,r9
;;;4722   
;;;4723   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;4724   		{
;;;4725   			if( pulPreviousNotificationValue != NULL )
000016  b10f              CBZ      r7,|L39.28|
;;;4726   			{
;;;4727   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000018  6c60              LDR      r0,[r4,#0x44]
00001a  6038              STR      r0,[r7,#0]
                  |L39.28|
;;;4728   			}
;;;4729   
;;;4730   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00001c  f8948048          LDRB     r8,[r4,#0x48]
;;;4731   
;;;4732   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000020  2002              MOVS     r0,#2
000022  f8840048          STRB     r0,[r4,#0x48]
;;;4733   
;;;4734   			switch( eAction )
000026  2e05              CMP      r6,#5
000028  d217              BCS      |L39.90|
00002a  e8dff006          TBB      [pc,r6]
00002e  1503              DCB      0x15,0x03
000030  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4735   			{
;;;4736   				case eSetBits	:
;;;4737   					pxTCB->ulNotifiedValue |= ulValue;
000034  6c60              LDR      r0,[r4,#0x44]
000036  4328              ORRS     r0,r0,r5
000038  6460              STR      r0,[r4,#0x44]
;;;4738   					break;
00003a  e00f              B        |L39.92|
;;;4739   
;;;4740   				case eIncrement	:
;;;4741   					( pxTCB->ulNotifiedValue )++;
00003c  6c60              LDR      r0,[r4,#0x44]
00003e  1c40              ADDS     r0,r0,#1
000040  6460              STR      r0,[r4,#0x44]
;;;4742   					break;
000042  e00b              B        |L39.92|
;;;4743   
;;;4744   				case eSetValueWithOverwrite	:
;;;4745   					pxTCB->ulNotifiedValue = ulValue;
000044  6465              STR      r5,[r4,#0x44]
;;;4746   					break;
000046  e009              B        |L39.92|
;;;4747   
;;;4748   				case eSetValueWithoutOverwrite :
;;;4749   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000048  f1b80f02          CMP      r8,#2
00004c  d001              BEQ      |L39.82|
;;;4750   					{
;;;4751   						pxTCB->ulNotifiedValue = ulValue;
00004e  6465              STR      r5,[r4,#0x44]
000050  e001              B        |L39.86|
                  |L39.82|
;;;4752   					}
;;;4753   					else
;;;4754   					{
;;;4755   						/* The value could not be written to the task. */
;;;4756   						xReturn = pdFAIL;
000052  f04f0a00          MOV      r10,#0
                  |L39.86|
;;;4757   					}
;;;4758   					break;
000056  e001              B        |L39.92|
;;;4759   
;;;4760   				case eNoAction:
;;;4761   					/* The task is being notified without its notify value being
;;;4762   					updated. */
;;;4763   					break;
000058  e000              B        |L39.92|
                  |L39.90|
;;;4764   
;;;4765   				default:
;;;4766   					/* Should not get here if all enums are handled.
;;;4767   					Artificially force an assert by testing a value the
;;;4768   					compiler can't assume is const. */
;;;4769   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
;;;4770   
;;;4771   					break;
00005a  bf00              NOP      
                  |L39.92|
00005c  bf00              NOP                            ;4738
;;;4772   			}
;;;4773   
;;;4774   			traceTASK_NOTIFY();
;;;4775   
;;;4776   			/* If the task is in the blocked state specifically to wait for a
;;;4777   			notification then unblock it now. */
;;;4778   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00005e  f1b80f01          CMP      r8,#1
000062  d122              BNE      |L39.170|
;;;4779   			{
;;;4780   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000064  1d20              ADDS     r0,r4,#4
000066  f7fffffe          BL       uxListRemove
;;;4781   				prvAddTaskToReadyList( pxTCB );
00006a  f894102c          LDRB     r1,[r4,#0x2c]
00006e  2001              MOVS     r0,#1
000070  4088              LSLS     r0,r0,r1
000072  4910              LDR      r1,|L39.180|
000074  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000076  4308              ORRS     r0,r0,r1
000078  490e              LDR      r1,|L39.180|
00007a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00007c  6ae1              LDR      r1,[r4,#0x2c]
00007e  eb010181          ADD      r1,r1,r1,LSL #2
000082  4a0d              LDR      r2,|L39.184|
000084  eb020081          ADD      r0,r2,r1,LSL #2
000088  1d21              ADDS     r1,r4,#4
00008a  f7fffffe          BL       vListInsertEnd
;;;4782   
;;;4783   				/* The task should not have been on an event list. */
;;;4784   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4785   
;;;4786   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4787   				{
;;;4788   					/* If a task is blocked waiting for a notification then
;;;4789   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4790   					out time.  If the task is unblocked for a reason other than
;;;4791   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4792   					because it will automatically get reset to a new value when
;;;4793   					the tick count equals xNextTaskUnblockTime.  However if
;;;4794   					tickless idling is used it might be more important to enter
;;;4795   					sleep mode at the earliest possible time - so reset
;;;4796   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4797   					earliest possible time. */
;;;4798   					prvResetNextTaskUnblockTime();
;;;4799   				}
;;;4800   				#endif
;;;4801   
;;;4802   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00008e  490b              LDR      r1,|L39.188|
000090  6ae0              LDR      r0,[r4,#0x2c]
000092  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000094  6ac9              LDR      r1,[r1,#0x2c]
000096  4288              CMP      r0,r1
000098  d907              BLS      |L39.170|
;;;4803   				{
;;;4804   					/* The notified task has a priority above the currently
;;;4805   					executing task so a yield is required. */
;;;4806   					taskYIELD_IF_USING_PREEMPTION();
00009a  f04f5080          MOV      r0,#0x10000000
00009e  4908              LDR      r1,|L39.192|
0000a0  6008              STR      r0,[r1,#0]
0000a2  f3bf8f4f          DSB      
0000a6  f3bf8f6f          ISB      
                  |L39.170|
;;;4807   				}
;;;4808   				else
;;;4809   				{
;;;4810   					mtCOVERAGE_TEST_MARKER();
;;;4811   				}
;;;4812   			}
;;;4813   			else
;;;4814   			{
;;;4815   				mtCOVERAGE_TEST_MARKER();
;;;4816   			}
;;;4817   		}
;;;4818   		taskEXIT_CRITICAL();
0000aa  f7fffffe          BL       vPortExitCritical
;;;4819   
;;;4820   		return xReturn;
0000ae  4650              MOV      r0,r10
;;;4821   	}
0000b0  e8bd87f0          POP      {r4-r10,pc}
;;;4822   
                          ENDP

                  |L39.180|
                          DCD      uxTopReadyPriority
                  |L39.184|
                          DCD      pxReadyTasksLists
                  |L39.188|
                          DCD      pxCurrentTCB
                  |L39.192|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4827   
;;;4828   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4829   	{
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;4830   	TCB_t * pxTCB;
;;;4831   	uint8_t ucOriginalNotifyState;
;;;4832   	BaseType_t xReturn = pdPASS;
000010  2001              MOVS     r0,#1
000012  9000              STR      r0,[sp,#0]
;;;4833   	UBaseType_t uxSavedInterruptStatus;
;;;4834   
;;;4835   		configASSERT( xTaskToNotify );
;;;4836   
;;;4837   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4838   		maximum	system call (or maximum API call) interrupt priority.
;;;4839   		Interrupts that are	above the maximum system call priority are keep
;;;4840   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4841   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4842   		is defined in FreeRTOSConfig.h then
;;;4843   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4844   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4845   		been assigned a priority above the configured maximum system call
;;;4846   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4847   		from interrupts	that have been assigned a priority at or (logically)
;;;4848   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4849   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4850   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4851   		provided on the following link:
;;;4852   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4853   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4854   
;;;4855   		pxTCB = xTaskToNotify;
000014  4654              MOV      r4,r10
;;;4856   
;;;4857   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000016  bf00              NOP      
000018  21bf              MOVS     r1,#0xbf
00001a  f3ef8011          MRS      r0,BASEPRI
00001e  f3818811          MSR      BASEPRI,r1
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
00002a  bf00              NOP      
00002c  4681              MOV      r9,r0
;;;4858   		{
;;;4859   			if( pulPreviousNotificationValue != NULL )
00002e  b10f              CBZ      r7,|L40.52|
;;;4860   			{
;;;4861   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000030  6c60              LDR      r0,[r4,#0x44]
000032  6038              STR      r0,[r7,#0]
                  |L40.52|
;;;4862   			}
;;;4863   
;;;4864   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000034  f8948048          LDRB     r8,[r4,#0x48]
;;;4865   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000038  2002              MOVS     r0,#2
00003a  f8840048          STRB     r0,[r4,#0x48]
;;;4866   
;;;4867   			switch( eAction )
00003e  2e05              CMP      r6,#5
000040  d217              BCS      |L40.114|
000042  e8dff006          TBB      [pc,r6]
000046  1503              DCB      0x15,0x03
000048  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4868   			{
;;;4869   				case eSetBits	:
;;;4870   					pxTCB->ulNotifiedValue |= ulValue;
00004c  6c60              LDR      r0,[r4,#0x44]
00004e  4328              ORRS     r0,r0,r5
000050  6460              STR      r0,[r4,#0x44]
;;;4871   					break;
000052  e00f              B        |L40.116|
;;;4872   
;;;4873   				case eIncrement	:
;;;4874   					( pxTCB->ulNotifiedValue )++;
000054  6c60              LDR      r0,[r4,#0x44]
000056  1c40              ADDS     r0,r0,#1
000058  6460              STR      r0,[r4,#0x44]
;;;4875   					break;
00005a  e00b              B        |L40.116|
;;;4876   
;;;4877   				case eSetValueWithOverwrite	:
;;;4878   					pxTCB->ulNotifiedValue = ulValue;
00005c  6465              STR      r5,[r4,#0x44]
;;;4879   					break;
00005e  e009              B        |L40.116|
;;;4880   
;;;4881   				case eSetValueWithoutOverwrite :
;;;4882   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000060  f1b80f02          CMP      r8,#2
000064  d001              BEQ      |L40.106|
;;;4883   					{
;;;4884   						pxTCB->ulNotifiedValue = ulValue;
000066  6465              STR      r5,[r4,#0x44]
000068  e001              B        |L40.110|
                  |L40.106|
;;;4885   					}
;;;4886   					else
;;;4887   					{
;;;4888   						/* The value could not be written to the task. */
;;;4889   						xReturn = pdFAIL;
00006a  2000              MOVS     r0,#0
00006c  9000              STR      r0,[sp,#0]
                  |L40.110|
;;;4890   					}
;;;4891   					break;
00006e  e001              B        |L40.116|
;;;4892   
;;;4893   				case eNoAction :
;;;4894   					/* The task is being notified without its notify value being
;;;4895   					updated. */
;;;4896   					break;
000070  e000              B        |L40.116|
                  |L40.114|
;;;4897   
;;;4898   				default:
;;;4899   					/* Should not get here if all enums are handled.
;;;4900   					Artificially force an assert by testing a value the
;;;4901   					compiler can't assume is const. */
;;;4902   					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
;;;4903   					break;
000072  bf00              NOP      
                  |L40.116|
000074  bf00              NOP                            ;4871
;;;4904   			}
;;;4905   
;;;4906   			traceTASK_NOTIFY_FROM_ISR();
;;;4907   
;;;4908   			/* If the task is in the blocked state specifically to wait for a
;;;4909   			notification then unblock it now. */
;;;4910   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000076  f1b80f01          CMP      r8,#1
00007a  d12c              BNE      |L40.214|
;;;4911   			{
;;;4912   				/* The task should not have been on an event list. */
;;;4913   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4914   
;;;4915   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00007c  4819              LDR      r0,|L40.228|
00007e  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000080  b9a8              CBNZ     r0,|L40.174|
;;;4916   				{
;;;4917   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000082  1d20              ADDS     r0,r4,#4
000084  f7fffffe          BL       uxListRemove
;;;4918   					prvAddTaskToReadyList( pxTCB );
000088  f894102c          LDRB     r1,[r4,#0x2c]
00008c  2001              MOVS     r0,#1
00008e  4088              LSLS     r0,r0,r1
000090  4915              LDR      r1,|L40.232|
000092  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000094  4308              ORRS     r0,r0,r1
000096  4914              LDR      r1,|L40.232|
000098  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00009a  6ae1              LDR      r1,[r4,#0x2c]
00009c  eb010181          ADD      r1,r1,r1,LSL #2
0000a0  4a12              LDR      r2,|L40.236|
0000a2  eb020081          ADD      r0,r2,r1,LSL #2
0000a6  1d21              ADDS     r1,r4,#4
0000a8  f7fffffe          BL       vListInsertEnd
0000ac  e004              B        |L40.184|
                  |L40.174|
;;;4919   				}
;;;4920   				else
;;;4921   				{
;;;4922   					/* The delayed and ready lists cannot be accessed, so hold
;;;4923   					this task pending until the scheduler is resumed. */
;;;4924   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000ae  f1040118          ADD      r1,r4,#0x18
0000b2  480f              LDR      r0,|L40.240|
0000b4  f7fffffe          BL       vListInsertEnd
                  |L40.184|
;;;4925   				}
;;;4926   
;;;4927   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000b8  490e              LDR      r1,|L40.244|
0000ba  6ae0              LDR      r0,[r4,#0x2c]
0000bc  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000be  6ac9              LDR      r1,[r1,#0x2c]
0000c0  4288              CMP      r0,r1
0000c2  d908              BLS      |L40.214|
;;;4928   				{
;;;4929   					/* The notified task has a priority above the currently
;;;4930   					executing task so a yield is required. */
;;;4931   					if( pxHigherPriorityTaskWoken != NULL )
0000c4  f1bb0f00          CMP      r11,#0
0000c8  d002              BEQ      |L40.208|
;;;4932   					{
;;;4933   						*pxHigherPriorityTaskWoken = pdTRUE;
0000ca  2001              MOVS     r0,#1
0000cc  f8cb0000          STR      r0,[r11,#0]
                  |L40.208|
;;;4934   					}
;;;4935   
;;;4936   					/* Mark that a yield is pending in case the user is not
;;;4937   					using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4938   					safe FreeRTOS function. */
;;;4939   					xYieldPending = pdTRUE;
0000d0  2001              MOVS     r0,#1
0000d2  4909              LDR      r1,|L40.248|
0000d4  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L40.214|
;;;4940   				}
;;;4941   				else
;;;4942   				{
;;;4943   					mtCOVERAGE_TEST_MARKER();
;;;4944   				}
;;;4945   			}
;;;4946   		}
;;;4947   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000d6  bf00              NOP      
0000d8  f3898811          MSR      BASEPRI,r9
0000dc  bf00              NOP      
;;;4948   
;;;4949   		return xReturn;
0000de  9800              LDR      r0,[sp,#0]
;;;4950   	}
0000e0  e8bd8ff8          POP      {r3-r11,pc}
;;;4951   
                          ENDP

                  |L40.228|
                          DCD      uxSchedulerSuspended
                  |L40.232|
                          DCD      uxTopReadyPriority
                  |L40.236|
                          DCD      pxReadyTasksLists
                  |L40.240|
                          DCD      xPendingReadyList
                  |L40.244|
                          DCD      pxCurrentTCB
                  |L40.248|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3905   
;;;3906   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L41.8|
;;;3907   	{
;;;3908   	TaskHandle_t xReturn;
;;;3909   
;;;3910   		/* A critical section is not required as this is not called from
;;;3911   		an interrupt and the current TCB will always be the same for any
;;;3912   		individual execution thread. */
;;;3913   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3914   
;;;3915   		return xReturn;
;;;3916   	}
000004  4770              BX       lr
;;;3917   
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3922   
;;;3923   	BaseType_t xTaskGetSchedulerState( void )
000000  4905              LDR      r1,|L42.24|
;;;3924   	{
;;;3925   	BaseType_t xReturn;
;;;3926   
;;;3927   		if( xSchedulerRunning == pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000004  b909              CBNZ     r1,|L42.10|
;;;3928   		{
;;;3929   			xReturn = taskSCHEDULER_NOT_STARTED;
000006  2001              MOVS     r0,#1
000008  e005              B        |L42.22|
                  |L42.10|
;;;3930   		}
;;;3931   		else
;;;3932   		{
;;;3933   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000a  4904              LDR      r1,|L42.28|
00000c  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
00000e  b909              CBNZ     r1,|L42.20|
;;;3934   			{
;;;3935   				xReturn = taskSCHEDULER_RUNNING;
000010  2002              MOVS     r0,#2
000012  e000              B        |L42.22|
                  |L42.20|
;;;3936   			}
;;;3937   			else
;;;3938   			{
;;;3939   				xReturn = taskSCHEDULER_SUSPENDED;
000014  2000              MOVS     r0,#0
                  |L42.22|
;;;3940   			}
;;;3941   		}
;;;3942   
;;;3943   		return xReturn;
;;;3944   	}
000016  4770              BX       lr
;;;3945   
                          ENDP

                  |L42.24|
                          DCD      xSchedulerRunning
                  |L42.28|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2282   
;;;2283   TickType_t xTaskGetTickCount( void )
000000  4901              LDR      r1,|L43.8|
;;;2284   {
;;;2285   TickType_t xTicks;
;;;2286   
;;;2287   	/* Critical section required if running on a 16 bit processor. */
;;;2288   	portTICK_TYPE_ENTER_CRITICAL();
;;;2289   	{
;;;2290   		xTicks = xTickCount;
000002  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;2291   	}
;;;2292   	portTICK_TYPE_EXIT_CRITICAL();
;;;2293   
;;;2294   	return xTicks;
;;;2295   }
000004  4770              BX       lr
;;;2296   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2297   
;;;2298   TickType_t xTaskGetTickCountFromISR( void )
000000  2100              MOVS     r1,#0
;;;2299   {
;;;2300   TickType_t xReturn;
;;;2301   UBaseType_t uxSavedInterruptStatus;
;;;2302   
;;;2303   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2304   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2305   	above the maximum system call priority are kept permanently enabled, even
;;;2306   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2307   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2308   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2309   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2310   	assigned a priority above the configured maximum system call priority.
;;;2311   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2312   	that have been assigned a priority at or (logically) below the maximum
;;;2313   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2314   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2315   	More information (albeit Cortex-M specific) is provided on the following
;;;2316   	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2317   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;2318   
;;;2319   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2320   	{
;;;2321   		xReturn = xTickCount;
000002  4a01              LDR      r2,|L44.8|
000004  6810              LDR      r0,[r2,#0]  ; xTickCount
;;;2322   	}
;;;2323   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2324   
;;;2325   	return xReturn;
;;;2326   }
000006  4770              BX       lr
;;;2327   /*-----------------------------------------------------------*/
                          ENDP

                  |L44.8|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2663   
;;;2664   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2665   {
;;;2666   TCB_t * pxTCB;
;;;2667   TickType_t xItemValue;
;;;2668   BaseType_t xSwitchRequired = pdFALSE;
000004  2700              MOVS     r7,#0
;;;2669   
;;;2670   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2671   	Increments the tick then checks to see if the new tick value will cause any
;;;2672   	tasks to be unblocked. */
;;;2673   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2674   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000006  483a              LDR      r0,|L45.240|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  2800              CMP      r0,#0
00000c  d163              BNE      |L45.214|
;;;2675   	{
;;;2676   		/* Minor optimisation.  The tick count cannot change in this
;;;2677   		block. */
;;;2678   		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
00000e  4839              LDR      r0,|L45.244|
000010  6800              LDR      r0,[r0,#0]  ; xTickCount
000012  1c45              ADDS     r5,r0,#1
;;;2679   
;;;2680   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2681   		delayed lists if it wraps to 0. */
;;;2682   		xTickCount = xConstTickCount;
000014  4837              LDR      r0,|L45.244|
000016  6005              STR      r5,[r0,#0]  ; xTickCount
;;;2683   
;;;2684   		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
000018  b98d              CBNZ     r5,|L45.62|
;;;2685   		{
;;;2686   			taskSWITCH_DELAYED_LISTS();
00001a  4837              LDR      r0,|L45.248|
00001c  f8d08000          LDR      r8,[r0,#0]  ; pxDelayedTaskList
000020  4836              LDR      r0,|L45.252|
000022  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000024  4934              LDR      r1,|L45.248|
000026  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
000028  4834              LDR      r0,|L45.252|
00002a  f8c08000          STR      r8,[r0,#0]  ; pxOverflowDelayedTaskList
00002e  4834              LDR      r0,|L45.256|
000030  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000032  1c40              ADDS     r0,r0,#1
000034  4932              LDR      r1,|L45.256|
000036  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
000038  f7fffffe          BL       prvResetNextTaskUnblockTime
00003c  bf00              NOP      
                  |L45.62|
;;;2687   		}
;;;2688   		else
;;;2689   		{
;;;2690   			mtCOVERAGE_TEST_MARKER();
;;;2691   		}
;;;2692   
;;;2693   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2694   		the	queue in the order of their wake time - meaning once one task
;;;2695   		has been found whose block time has not expired there is no need to
;;;2696   		look any further down the list. */
;;;2697   		if( xConstTickCount >= xNextTaskUnblockTime )
00003e  4831              LDR      r0,|L45.260|
000040  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000042  4285              CMP      r5,r0
000044  d33b              BCC      |L45.190|
;;;2698   		{
;;;2699   			for( ;; )
000046  bf00              NOP      
                  |L45.72|
;;;2700   			{
;;;2701   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000048  482b              LDR      r0,|L45.248|
00004a  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00004c  6800              LDR      r0,[r0,#0]
00004e  b908              CBNZ     r0,|L45.84|
000050  2001              MOVS     r0,#1
000052  e000              B        |L45.86|
                  |L45.84|
000054  2000              MOVS     r0,#0
                  |L45.86|
000056  b120              CBZ      r0,|L45.98|
;;;2702   				{
;;;2703   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2704   					to the maximum possible value so it is extremely
;;;2705   					unlikely that the
;;;2706   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2707   					next time through. */
;;;2708   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000058  f04f30ff          MOV      r0,#0xffffffff
00005c  4929              LDR      r1,|L45.260|
00005e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2709   					break;
000060  e02c              B        |L45.188|
                  |L45.98|
;;;2710   				}
;;;2711   				else
;;;2712   				{
;;;2713   					/* The delayed list is not empty, get the value of the
;;;2714   					item at the head of the delayed list.  This is the time
;;;2715   					at which the task at the head of the delayed list must
;;;2716   					be removed from the Blocked state. */
;;;2717   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000062  4825              LDR      r0,|L45.248|
000064  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000066  68c0              LDR      r0,[r0,#0xc]
000068  68c4              LDR      r4,[r0,#0xc]
;;;2718   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
00006a  6866              LDR      r6,[r4,#4]
;;;2719   
;;;2720   					if( xConstTickCount < xItemValue )
00006c  42b5              CMP      r5,r6
00006e  d202              BCS      |L45.118|
;;;2721   					{
;;;2722   						/* It is not time to unblock this item yet, but the
;;;2723   						item value is the time at which the task at the head
;;;2724   						of the blocked list must be removed from the Blocked
;;;2725   						state -	so record the item value in
;;;2726   						xNextTaskUnblockTime. */
;;;2727   						xNextTaskUnblockTime = xItemValue;
000070  4824              LDR      r0,|L45.260|
000072  6006              STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2728   						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
000074  e022              B        |L45.188|
                  |L45.118|
;;;2729   					}
;;;2730   					else
;;;2731   					{
;;;2732   						mtCOVERAGE_TEST_MARKER();
;;;2733   					}
;;;2734   
;;;2735   					/* It is time to remove the item from the Blocked state. */
;;;2736   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000076  1d20              ADDS     r0,r4,#4
000078  f7fffffe          BL       uxListRemove
;;;2737   
;;;2738   					/* Is the task waiting on an event also?  If so remove
;;;2739   					it from the event list. */
;;;2740   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00007c  6aa0              LDR      r0,[r4,#0x28]
00007e  b118              CBZ      r0,|L45.136|
;;;2741   					{
;;;2742   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000080  f1040018          ADD      r0,r4,#0x18
000084  f7fffffe          BL       uxListRemove
                  |L45.136|
;;;2743   					}
;;;2744   					else
;;;2745   					{
;;;2746   						mtCOVERAGE_TEST_MARKER();
;;;2747   					}
;;;2748   
;;;2749   					/* Place the unblocked task into the appropriate ready
;;;2750   					list. */
;;;2751   					prvAddTaskToReadyList( pxTCB );
000088  f894102c          LDRB     r1,[r4,#0x2c]
00008c  2001              MOVS     r0,#1
00008e  4088              LSLS     r0,r0,r1
000090  491d              LDR      r1,|L45.264|
000092  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000094  4308              ORRS     r0,r0,r1
000096  491c              LDR      r1,|L45.264|
000098  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00009a  6ae1              LDR      r1,[r4,#0x2c]
00009c  eb010181          ADD      r1,r1,r1,LSL #2
0000a0  4a1a              LDR      r2,|L45.268|
0000a2  eb020081          ADD      r0,r2,r1,LSL #2
0000a6  1d21              ADDS     r1,r4,#4
0000a8  f7fffffe          BL       vListInsertEnd
;;;2752   
;;;2753   					/* A task being unblocked cannot cause an immediate
;;;2754   					context switch if preemption is turned off. */
;;;2755   					#if (  configUSE_PREEMPTION == 1 )
;;;2756   					{
;;;2757   						/* Preemption is on, but a context switch should
;;;2758   						only be performed if the unblocked task has a
;;;2759   						priority that is equal to or higher than the
;;;2760   						currently executing task. */
;;;2761   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000ac  4918              LDR      r1,|L45.272|
0000ae  6ae0              LDR      r0,[r4,#0x2c]
0000b0  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000b2  6ac9              LDR      r1,[r1,#0x2c]
0000b4  4288              CMP      r0,r1
0000b6  d3c7              BCC      |L45.72|
;;;2762   						{
;;;2763   							xSwitchRequired = pdTRUE;
0000b8  2701              MOVS     r7,#1
0000ba  e7c5              B        |L45.72|
                  |L45.188|
0000bc  bf00              NOP                            ;2709
                  |L45.190|
;;;2764   						}
;;;2765   						else
;;;2766   						{
;;;2767   							mtCOVERAGE_TEST_MARKER();
;;;2768   						}
;;;2769   					}
;;;2770   					#endif /* configUSE_PREEMPTION */
;;;2771   				}
;;;2772   			}
;;;2773   		}
;;;2774   
;;;2775   		/* Tasks of equal priority to the currently running task will share
;;;2776   		processing time (time slice) if preemption is on, and the application
;;;2777   		writer has not explicitly turned time slicing off. */
;;;2778   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2779   		{
;;;2780   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
0000be  4814              LDR      r0,|L45.272|
0000c0  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
0000c2  6ac0              LDR      r0,[r0,#0x2c]
0000c4  eb000080          ADD      r0,r0,r0,LSL #2
0000c8  4910              LDR      r1,|L45.268|
0000ca  f8510020          LDR      r0,[r1,r0,LSL #2]
0000ce  2801              CMP      r0,#1
0000d0  d900              BLS      |L45.212|
;;;2781   			{
;;;2782   				xSwitchRequired = pdTRUE;
0000d2  2701              MOVS     r7,#1
                  |L45.212|
;;;2783   			}
;;;2784   			else
;;;2785   			{
;;;2786   				mtCOVERAGE_TEST_MARKER();
;;;2787   			}
;;;2788   		}
;;;2789   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2790   
;;;2791   		#if ( configUSE_TICK_HOOK == 1 )
;;;2792   		{
;;;2793   			/* Guard against the tick hook being called when the pended tick
;;;2794   			count is being unwound (when the scheduler is being unlocked). */
;;;2795   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2796   			{
;;;2797   				vApplicationTickHook();
;;;2798   			}
;;;2799   			else
;;;2800   			{
;;;2801   				mtCOVERAGE_TEST_MARKER();
;;;2802   			}
;;;2803   		}
;;;2804   		#endif /* configUSE_TICK_HOOK */
;;;2805   	}
0000d4  e004              B        |L45.224|
                  |L45.214|
;;;2806   	else
;;;2807   	{
;;;2808   		++uxPendedTicks;
0000d6  480f              LDR      r0,|L45.276|
0000d8  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0000da  1c40              ADDS     r0,r0,#1
0000dc  490d              LDR      r1,|L45.276|
0000de  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L45.224|
;;;2809   
;;;2810   		/* The tick hook gets called at regular intervals, even if the
;;;2811   		scheduler is locked. */
;;;2812   		#if ( configUSE_TICK_HOOK == 1 )
;;;2813   		{
;;;2814   			vApplicationTickHook();
;;;2815   		}
;;;2816   		#endif
;;;2817   	}
;;;2818   
;;;2819   	#if ( configUSE_PREEMPTION == 1 )
;;;2820   	{
;;;2821   		if( xYieldPending != pdFALSE )
0000e0  480d              LDR      r0,|L45.280|
0000e2  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000e4  b100              CBZ      r0,|L45.232|
;;;2822   		{
;;;2823   			xSwitchRequired = pdTRUE;
0000e6  2701              MOVS     r7,#1
                  |L45.232|
;;;2824   		}
;;;2825   		else
;;;2826   		{
;;;2827   			mtCOVERAGE_TEST_MARKER();
;;;2828   		}
;;;2829   	}
;;;2830   	#endif /* configUSE_PREEMPTION */
;;;2831   
;;;2832   	return xSwitchRequired;
0000e8  4638              MOV      r0,r7
;;;2833   }
0000ea  e8bd81f0          POP      {r4-r8,pc}
;;;2834   /*-----------------------------------------------------------*/
                          ENDP

0000ee  0000              DCW      0x0000
                  |L45.240|
                          DCD      uxSchedulerSuspended
                  |L45.244|
                          DCD      xTickCount
                  |L45.248|
                          DCD      pxDelayedTaskList
                  |L45.252|
                          DCD      pxOverflowDelayedTaskList
                  |L45.256|
                          DCD      xNumOfOverflows
                  |L45.260|
                          DCD      xNextTaskUnblockTime
                  |L45.264|
                          DCD      uxTopReadyPriority
                  |L45.268|
                          DCD      pxReadyTasksLists
                  |L45.272|
                          DCD      pxCurrentTCB
                  |L45.276|
                          DCD      uxPendedTicks
                  |L45.280|
                          DCD      xYieldPending

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;5043   
;;;5044   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;5045   	{
000002  4605              MOV      r5,r0
;;;5046   	TCB_t *pxTCB;
;;;5047   	BaseType_t xReturn;
;;;5048   
;;;5049   		/* If null is passed in here then it is the calling task that is having
;;;5050   		its notification state cleared. */
;;;5051   		pxTCB = prvGetTCBFromHandle( xTask );
000004  b915              CBNZ     r5,|L46.12|
000006  480a              LDR      r0,|L46.48|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L46.14|
                  |L46.12|
00000c  4628              MOV      r0,r5
                  |L46.14|
00000e  4606              MOV      r6,r0
;;;5052   
;;;5053   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;5054   		{
;;;5055   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000014  f8960048          LDRB     r0,[r6,#0x48]
000018  2802              CMP      r0,#2
00001a  d104              BNE      |L46.38|
;;;5056   			{
;;;5057   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00001c  2000              MOVS     r0,#0
00001e  f8860048          STRB     r0,[r6,#0x48]
;;;5058   				xReturn = pdPASS;
000022  2401              MOVS     r4,#1
000024  e000              B        |L46.40|
                  |L46.38|
;;;5059   			}
;;;5060   			else
;;;5061   			{
;;;5062   				xReturn = pdFAIL;
000026  2400              MOVS     r4,#0
                  |L46.40|
;;;5063   			}
;;;5064   		}
;;;5065   		taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;5066   
;;;5067   		return xReturn;
00002c  4620              MOV      r0,r4
;;;5068   	}
00002e  bd70              POP      {r4-r6,pc}
;;;5069   
                          ENDP

                  |L46.48|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4633   
;;;4634   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4635   	{
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;4636   	BaseType_t xReturn;
;;;4637   
;;;4638   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4639   		{
;;;4640   			/* Only block if a notification is not already pending. */
;;;4641   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4821              LDR      r0,|L47.152|
000012  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000014  f8900048          LDRB     r0,[r0,#0x48]
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L47.78|
;;;4642   			{
;;;4643   				/* Clear bits in the task's notification value as bits may get
;;;4644   				set	by the notifying task or interrupt.  This can be used to
;;;4645   				clear the value to zero. */
;;;4646   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  491e              LDR      r1,|L47.152|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  f1010044          ADD      r0,r1,#0x44
000024  6c49              LDR      r1,[r1,#0x44]
000026  43b9              BICS     r1,r1,r7
000028  6001              STR      r1,[r0,#0]
;;;4647   
;;;4648   				/* Mark this task as waiting for a notification. */
;;;4649   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
00002a  2001              MOVS     r0,#1
00002c  491a              LDR      r1,|L47.152|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f8810048          STRB     r0,[r1,#0x48]
;;;4650   
;;;4651   				if( xTicksToWait > ( TickType_t ) 0 )
000034  b15d              CBZ      r5,|L47.78|
;;;4652   				{
;;;4653   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4654   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4655   
;;;4656   					/* All ports are written to allow a yield in a critical
;;;4657   					section (some will yield immediately, others wait until the
;;;4658   					critical section exits) - but it is not something that
;;;4659   					application code should ever do. */
;;;4660   					portYIELD_WITHIN_API();
00003e  f04f5080          MOV      r0,#0x10000000
000042  4916              LDR      r1,|L47.156|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L47.78|
;;;4661   				}
;;;4662   				else
;;;4663   				{
;;;4664   					mtCOVERAGE_TEST_MARKER();
;;;4665   				}
;;;4666   			}
;;;4667   			else
;;;4668   			{
;;;4669   				mtCOVERAGE_TEST_MARKER();
;;;4670   			}
;;;4671   		}
;;;4672   		taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;4673   
;;;4674   		taskENTER_CRITICAL();
000052  f7fffffe          BL       vPortEnterCritical
;;;4675   		{
;;;4676   			traceTASK_NOTIFY_WAIT();
;;;4677   
;;;4678   			if( pulNotificationValue != NULL )
000056  b11c              CBZ      r4,|L47.96|
;;;4679   			{
;;;4680   				/* Output the current notification value, which may or may not
;;;4681   				have changed. */
;;;4682   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000058  480f              LDR      r0,|L47.152|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  6c40              LDR      r0,[r0,#0x44]
00005e  6020              STR      r0,[r4,#0]
                  |L47.96|
;;;4683   			}
;;;4684   
;;;4685   			/* If ucNotifyValue is set then either the task never entered the
;;;4686   			blocked state (because a notification was already pending) or the
;;;4687   			task unblocked because of a notification.  Otherwise the task
;;;4688   			unblocked because of a timeout. */
;;;4689   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000060  480d              LDR      r0,|L47.152|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  f8900048          LDRB     r0,[r0,#0x48]
000068  2802              CMP      r0,#2
00006a  d001              BEQ      |L47.112|
;;;4690   			{
;;;4691   				/* A notification was not received. */
;;;4692   				xReturn = pdFALSE;
00006c  2600              MOVS     r6,#0
00006e  e008              B        |L47.130|
                  |L47.112|
;;;4693   			}
;;;4694   			else
;;;4695   			{
;;;4696   				/* A notification was already pending or a notification was
;;;4697   				received while the task was waiting. */
;;;4698   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000070  4909              LDR      r1,|L47.152|
000072  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000074  f1010044          ADD      r0,r1,#0x44
000078  6c49              LDR      r1,[r1,#0x44]
00007a  ea210108          BIC      r1,r1,r8
00007e  6001              STR      r1,[r0,#0]
;;;4699   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
                  |L47.130|
;;;4700   			}
;;;4701   
;;;4702   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000082  2000              MOVS     r0,#0
000084  4904              LDR      r1,|L47.152|
000086  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000088  f8810048          STRB     r0,[r1,#0x48]
;;;4703   		}
;;;4704   		taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;4705   
;;;4706   		return xReturn;
000090  4630              MOV      r0,r6
;;;4707   	}
000092  e8bd81f0          POP      {r4-r8,pc}
;;;4708   
                          ENDP

000096  0000              DCW      0x0000
                  |L47.152|
                          DCD      pxCurrentTCB
                  |L47.156|
                          DCD      0xe000ed04

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;3092   
;;;3093   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;3094   {
000002  4606              MOV      r6,r0
;;;3095   TCB_t *pxUnblockedTCB;
;;;3096   BaseType_t xReturn;
;;;3097   
;;;3098   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;3099   	called from a critical section within an ISR. */
;;;3100   
;;;3101   	/* The event list is sorted in priority order, so the first in the list can
;;;3102   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;3103   	the delayed list, and add it to the ready list.
;;;3104   
;;;3105   	If an event is for a queue that is locked then this function will never
;;;3106   	get called - the lock count on the queue will get modified instead.  This
;;;3107   	means exclusive access to the event list is guaranteed here.
;;;3108   
;;;3109   	This function assumes that a check has already been made to ensure that
;;;3110   	pxEventList is not empty. */
;;;3111   	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;3112   	configASSERT( pxUnblockedTCB );
;;;3113   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000008  f1040018          ADD      r0,r4,#0x18
00000c  f7fffffe          BL       uxListRemove
;;;3114   
;;;3115   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000010  4815              LDR      r0,|L48.104|
000012  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000014  b9a8              CBNZ     r0,|L48.66|
;;;3116   	{
;;;3117   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;3118   		prvAddTaskToReadyList( pxUnblockedTCB );
00001c  f894102c          LDRB     r1,[r4,#0x2c]
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  4911              LDR      r1,|L48.108|
000026  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000028  4308              ORRS     r0,r0,r1
00002a  4910              LDR      r1,|L48.108|
00002c  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00002e  6ae1              LDR      r1,[r4,#0x2c]
000030  eb010181          ADD      r1,r1,r1,LSL #2
000034  4a0e              LDR      r2,|L48.112|
000036  eb020081          ADD      r0,r2,r1,LSL #2
00003a  1d21              ADDS     r1,r4,#4
00003c  f7fffffe          BL       vListInsertEnd
000040  e004              B        |L48.76|
                  |L48.66|
;;;3119   
;;;3120   		#if( configUSE_TICKLESS_IDLE != 0 )
;;;3121   		{
;;;3122   			/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3123   			might be set to the blocked task's time out time.  If the task is
;;;3124   			unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3125   			normally left unchanged, because it is automatically reset to a new
;;;3126   			value when the tick count equals xNextTaskUnblockTime.  However if
;;;3127   			tickless idling is used it might be more important to enter sleep mode
;;;3128   			at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3129   			ensure it is updated at the earliest possible time. */
;;;3130   			prvResetNextTaskUnblockTime();
;;;3131   		}
;;;3132   		#endif
;;;3133   	}
;;;3134   	else
;;;3135   	{
;;;3136   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;3137   		pending until the scheduler is resumed. */
;;;3138   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000042  f1040118          ADD      r1,r4,#0x18
000046  480b              LDR      r0,|L48.116|
000048  f7fffffe          BL       vListInsertEnd
                  |L48.76|
;;;3139   	}
;;;3140   
;;;3141   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00004c  490a              LDR      r1,|L48.120|
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000052  6ac9              LDR      r1,[r1,#0x2c]
000054  4288              CMP      r0,r1
000056  d904              BLS      |L48.98|
;;;3142   	{
;;;3143   		/* Return true if the task removed from the event list has a higher
;;;3144   		priority than the calling task.  This allows the calling task to know if
;;;3145   		it should force a context switch now. */
;;;3146   		xReturn = pdTRUE;
000058  2501              MOVS     r5,#1
;;;3147   
;;;3148   		/* Mark that a yield is pending in case the user is not using the
;;;3149   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;3150   		xYieldPending = pdTRUE;
00005a  2001              MOVS     r0,#1
00005c  4907              LDR      r1,|L48.124|
00005e  6008              STR      r0,[r1,#0]  ; xYieldPending
000060  e000              B        |L48.100|
                  |L48.98|
;;;3151   	}
;;;3152   	else
;;;3153   	{
;;;3154   		xReturn = pdFALSE;
000062  2500              MOVS     r5,#0
                  |L48.100|
;;;3155   	}
;;;3156   
;;;3157   	return xReturn;
000064  4628              MOV      r0,r5
;;;3158   }
000066  bd70              POP      {r4-r6,pc}
;;;3159   /*-----------------------------------------------------------*/
                          ENDP

                  |L48.104|
                          DCD      uxSchedulerSuspended
                  |L48.108|
                          DCD      uxTopReadyPriority
                  |L48.112|
                          DCD      pxReadyTasksLists
                  |L48.116|
                          DCD      xPendingReadyList
                  |L48.120|
                          DCD      pxCurrentTCB
                  |L48.124|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2172   
;;;2173   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2174   {
;;;2175   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2176   BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;2177   
;;;2178   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2179   	previous call to vTaskSuspendAll(). */
;;;2180   	configASSERT( uxSchedulerSuspended );
;;;2181   
;;;2182   	/* It is possible that an ISR caused a task to be removed from an event
;;;2183   	list while the scheduler was suspended.  If this was the case then the
;;;2184   	removed task will have been added to the xPendingReadyList.  Once the
;;;2185   	scheduler has been resumed it is safe to move all the pending ready
;;;2186   	tasks from this list into their appropriate ready list. */
;;;2187   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2188   	{
;;;2189   		--uxSchedulerSuspended;
00000a  482e              LDR      r0,|L49.196|
00000c  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000e  1e40              SUBS     r0,r0,#1
000010  492c              LDR      r1,|L49.196|
000012  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2190   
;;;2191   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000018  2800              CMP      r0,#0
00001a  d14f              BNE      |L49.188|
;;;2192   		{
;;;2193   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
00001c  482a              LDR      r0,|L49.200|
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2800              CMP      r0,#0
000022  d04b              BEQ      |L49.188|
;;;2194   			{
;;;2195   				/* Move any readied tasks from the pending list into the
;;;2196   				appropriate ready list. */
;;;2197   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000024  e024              B        |L49.112|
                  |L49.38|
;;;2198   				{
;;;2199   					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000026  4829              LDR      r0,|L49.204|
000028  68c0              LDR      r0,[r0,#0xc]
00002a  68c4              LDR      r4,[r0,#0xc]
;;;2200   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00002c  f1040018          ADD      r0,r4,#0x18
000030  f7fffffe          BL       uxListRemove
;;;2201   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       uxListRemove
;;;2202   					prvAddTaskToReadyList( pxTCB );
00003a  f894102c          LDRB     r1,[r4,#0x2c]
00003e  2001              MOVS     r0,#1
000040  4088              LSLS     r0,r0,r1
000042  4923              LDR      r1,|L49.208|
000044  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000046  4308              ORRS     r0,r0,r1
000048  4921              LDR      r1,|L49.208|
00004a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
00004c  6ae1              LDR      r1,[r4,#0x2c]
00004e  eb010181          ADD      r1,r1,r1,LSL #2
000052  4a20              LDR      r2,|L49.212|
000054  eb020081          ADD      r0,r2,r1,LSL #2
000058  1d21              ADDS     r1,r4,#4
00005a  f7fffffe          BL       vListInsertEnd
;;;2203   
;;;2204   					/* If the moved task has a priority higher than the current
;;;2205   					task then a yield must be performed. */
;;;2206   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00005e  491e              LDR      r1,|L49.216|
000060  6ae0              LDR      r0,[r4,#0x2c]
000062  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000064  6ac9              LDR      r1,[r1,#0x2c]
000066  4288              CMP      r0,r1
000068  d302              BCC      |L49.112|
;;;2207   					{
;;;2208   						xYieldPending = pdTRUE;
00006a  2001              MOVS     r0,#1
00006c  491b              LDR      r1,|L49.220|
00006e  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L49.112|
000070  4816              LDR      r0,|L49.204|
000072  6800              LDR      r0,[r0,#0]            ;2197  ; xPendingReadyList
000074  b908              CBNZ     r0,|L49.122|
000076  2001              MOVS     r0,#1                 ;2197
000078  e000              B        |L49.124|
                  |L49.122|
00007a  2000              MOVS     r0,#0                 ;2197
                  |L49.124|
00007c  2800              CMP      r0,#0                 ;2197
00007e  d0d2              BEQ      |L49.38|
;;;2209   					}
;;;2210   					else
;;;2211   					{
;;;2212   						mtCOVERAGE_TEST_MARKER();
;;;2213   					}
;;;2214   				}
;;;2215   
;;;2216   				if( pxTCB != NULL )
000080  b10c              CBZ      r4,|L49.134|
;;;2217   				{
;;;2218   					/* A task was unblocked while the scheduler was suspended,
;;;2219   					which may have prevented the next unblock time from being
;;;2220   					re-calculated, in which case re-calculate it now.  Mainly
;;;2221   					important for low power tickless implementations, where
;;;2222   					this can prevent an unnecessary exit from low power
;;;2223   					state. */
;;;2224   					prvResetNextTaskUnblockTime();
000082  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L49.134|
;;;2225   				}
;;;2226   
;;;2227   				/* If any ticks occurred while the scheduler was suspended then
;;;2228   				they should be processed now.  This ensures the tick count does
;;;2229   				not	slip, and that any delayed tasks are resumed at the correct
;;;2230   				time. */
;;;2231   				{
;;;2232   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000086  4816              LDR      r0,|L49.224|
000088  6805              LDR      r5,[r0,#0]  ; uxPendedTicks
;;;2233   
;;;2234   					if( uxPendedCounts > ( UBaseType_t ) 0U )
00008a  b165              CBZ      r5,|L49.166|
;;;2235   					{
;;;2236   						do
00008c  bf00              NOP      
                  |L49.142|
;;;2237   						{
;;;2238   							if( xTaskIncrementTick() != pdFALSE )
00008e  f7fffffe          BL       xTaskIncrementTick
000092  b110              CBZ      r0,|L49.154|
;;;2239   							{
;;;2240   								xYieldPending = pdTRUE;
000094  2001              MOVS     r0,#1
000096  4911              LDR      r1,|L49.220|
000098  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L49.154|
;;;2241   							}
;;;2242   							else
;;;2243   							{
;;;2244   								mtCOVERAGE_TEST_MARKER();
;;;2245   							}
;;;2246   							--uxPendedCounts;
00009a  1e6d              SUBS     r5,r5,#1
;;;2247   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
00009c  2d00              CMP      r5,#0
00009e  d1f6              BNE      |L49.142|
;;;2248   
;;;2249   						uxPendedTicks = 0;
0000a0  2000              MOVS     r0,#0
0000a2  490f              LDR      r1,|L49.224|
0000a4  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L49.166|
;;;2250   					}
;;;2251   					else
;;;2252   					{
;;;2253   						mtCOVERAGE_TEST_MARKER();
;;;2254   					}
;;;2255   				}
;;;2256   
;;;2257   				if( xYieldPending != pdFALSE )
0000a6  480d              LDR      r0,|L49.220|
0000a8  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000aa  b138              CBZ      r0,|L49.188|
;;;2258   				{
;;;2259   					#if( configUSE_PREEMPTION != 0 )
;;;2260   					{
;;;2261   						xAlreadyYielded = pdTRUE;
0000ac  2601              MOVS     r6,#1
;;;2262   					}
;;;2263   					#endif
;;;2264   					taskYIELD_IF_USING_PREEMPTION();
0000ae  0730              LSLS     r0,r6,#28
0000b0  490c              LDR      r1,|L49.228|
0000b2  6008              STR      r0,[r1,#0]
0000b4  f3bf8f4f          DSB      
0000b8  f3bf8f6f          ISB      
                  |L49.188|
;;;2265   				}
;;;2266   				else
;;;2267   				{
;;;2268   					mtCOVERAGE_TEST_MARKER();
;;;2269   				}
;;;2270   			}
;;;2271   		}
;;;2272   		else
;;;2273   		{
;;;2274   			mtCOVERAGE_TEST_MARKER();
;;;2275   		}
;;;2276   	}
;;;2277   	taskEXIT_CRITICAL();
0000bc  f7fffffe          BL       vPortExitCritical
;;;2278   
;;;2279   	return xAlreadyYielded;
0000c0  4630              MOV      r0,r6
;;;2280   }
0000c2  bd70              POP      {r4-r6,pc}
;;;2281   /*-----------------------------------------------------------*/
                          ENDP

                  |L49.196|
                          DCD      uxSchedulerSuspended
                  |L49.200|
                          DCD      uxCurrentNumberOfTasks
                  |L49.204|
                          DCD      xPendingReadyList
                  |L49.208|
                          DCD      uxTopReadyPriority
                  |L49.212|
                          DCD      pxReadyTasksLists
                  |L49.216|
                          DCD      pxCurrentTCB
                  |L49.220|
                          DCD      xYieldPending
                  |L49.224|
                          DCD      uxPendedTicks
                  |L49.228|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1896   
;;;1897   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1898   	{
000004  4606              MOV      r6,r0
;;;1899   	BaseType_t xYieldRequired = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1900   	TCB_t * const pxTCB = xTaskToResume;
000008  4634              MOV      r4,r6
;;;1901   	UBaseType_t uxSavedInterruptStatus;
;;;1902   
;;;1903   		configASSERT( xTaskToResume );
;;;1904   
;;;1905   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1906   		maximum	system call (or maximum API call) interrupt priority.
;;;1907   		Interrupts that are	above the maximum system call priority are keep
;;;1908   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1909   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1910   		is defined in FreeRTOSConfig.h then
;;;1911   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1912   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1913   		been assigned a priority above the configured maximum system call
;;;1914   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1915   		from interrupts	that have been assigned a priority at or (logically)
;;;1916   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1917   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1918   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1919   		provided on the following link:
;;;1920   		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1921   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1922   
;;;1923   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4605              MOV      r5,r0
;;;1924   		{
;;;1925   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       prvTaskIsTaskSuspended
000028  b320              CBZ      r0,|L50.116|
;;;1926   			{
;;;1927   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1928   
;;;1929   				/* Check the ready lists can be accessed. */
;;;1930   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00002a  4816              LDR      r0,|L50.132|
00002c  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002e  b9e0              CBNZ     r0,|L50.106|
;;;1931   				{
;;;1932   					/* Ready lists can be accessed so move the task from the
;;;1933   					suspended list to the ready list directly. */
;;;1934   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000030  4915              LDR      r1,|L50.136|
000032  6ae0              LDR      r0,[r4,#0x2c]
000034  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000036  6ac9              LDR      r1,[r1,#0x2c]
000038  4288              CMP      r0,r1
00003a  d300              BCC      |L50.62|
;;;1935   					{
;;;1936   						xYieldRequired = pdTRUE;
00003c  2701              MOVS     r7,#1
                  |L50.62|
;;;1937   					}
;;;1938   					else
;;;1939   					{
;;;1940   						mtCOVERAGE_TEST_MARKER();
;;;1941   					}
;;;1942   
;;;1943   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00003e  1d20              ADDS     r0,r4,#4
000040  f7fffffe          BL       uxListRemove
;;;1944   					prvAddTaskToReadyList( pxTCB );
000044  f894102c          LDRB     r1,[r4,#0x2c]
000048  2001              MOVS     r0,#1
00004a  4088              LSLS     r0,r0,r1
00004c  490f              LDR      r1,|L50.140|
00004e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000050  4308              ORRS     r0,r0,r1
000052  490e              LDR      r1,|L50.140|
000054  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
000056  6ae1              LDR      r1,[r4,#0x2c]
000058  eb010181          ADD      r1,r1,r1,LSL #2
00005c  4a0c              LDR      r2,|L50.144|
00005e  eb020081          ADD      r0,r2,r1,LSL #2
000062  1d21              ADDS     r1,r4,#4
000064  f7fffffe          BL       vListInsertEnd
000068  e004              B        |L50.116|
                  |L50.106|
;;;1945   				}
;;;1946   				else
;;;1947   				{
;;;1948   					/* The delayed or ready lists cannot be accessed so the task
;;;1949   					is held in the pending ready list until the scheduler is
;;;1950   					unsuspended. */
;;;1951   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00006a  f1040118          ADD      r1,r4,#0x18
00006e  4809              LDR      r0,|L50.148|
000070  f7fffffe          BL       vListInsertEnd
                  |L50.116|
;;;1952   				}
;;;1953   			}
;;;1954   			else
;;;1955   			{
;;;1956   				mtCOVERAGE_TEST_MARKER();
;;;1957   			}
;;;1958   		}
;;;1959   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000074  bf00              NOP      
000076  f3858811          MSR      BASEPRI,r5
00007a  bf00              NOP      
;;;1960   
;;;1961   		return xYieldRequired;
00007c  4638              MOV      r0,r7
;;;1962   	}
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;1963   
                          ENDP

000082  0000              DCW      0x0000
                  |L50.132|
                          DCD      uxSchedulerSuspended
                  |L50.136|
                          DCD      pxCurrentTCB
                  |L50.140|
                          DCD      uxTopReadyPriority
                  |L50.144|
                          DCD      pxReadyTasksLists
                  |L50.148|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
