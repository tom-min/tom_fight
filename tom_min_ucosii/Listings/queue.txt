; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\FreeRTOS\include -I.\FreeRTOS\portable\RVDS\ARM_CM3 -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\queue.crf FreeRTOS\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2148   
;;;2149   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;2150   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2151   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000006  6c20              LDR      r0,[r4,#0x40]
000008  b170              CBZ      r0,|L1.40|
;;;2152   	{
;;;2153   		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4401              ADD      r1,r1,r0
000010  60e1              STR      r1,[r4,#0xc]
;;;2154   		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  e9d41002          LDRD     r1,r0,[r4,#8]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L1.30|
;;;2155   		{
;;;2156   			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
00001a  6821              LDR      r1,[r4,#0]
00001c  60e1              STR      r1,[r4,#0xc]
                  |L1.30|
;;;2157   		}
;;;2158   		else
;;;2159   		{
;;;2160   			mtCOVERAGE_TEST_MARKER();
;;;2161   		}
;;;2162   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L1.40|
;;;2163   	}
;;;2164   }
000028  bd70              POP      {r4-r6,pc}
;;;2165   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2069   
;;;2070   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2071   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;2072   BaseType_t xReturn = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;2073   UBaseType_t uxMessagesWaiting;
;;;2074   
;;;2075   	/* This function is called from a critical section. */
;;;2076   
;;;2077   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000e  6ba6              LDR      r6,[r4,#0x38]
;;;2078   
;;;2079   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000010  6c20              LDR      r0,[r4,#0x40]
000012  b328              CBZ      r0,|L2.96|
;;;2080   	{
;;;2081   		#if ( configUSE_MUTEXES == 1 )
;;;2082   		{
;;;2083   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;2084   			{
;;;2085   				/* The mutex is no longer being held. */
;;;2086   				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;2087   				pxQueue->u.xSemaphore.xMutexHolder = NULL;
;;;2088   			}
;;;2089   			else
;;;2090   			{
;;;2091   				mtCOVERAGE_TEST_MARKER();
;;;2092   			}
;;;2093   		}
;;;2094   		#endif /* configUSE_MUTEXES */
;;;2095   	}
;;;2096   	else if( xPosition == queueSEND_TO_BACK )
000014  b97d              CBNZ     r5,|L2.54|
;;;2097   	{
;;;2098   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
000016  4639              MOV      r1,r7
000018  6c22              LDR      r2,[r4,#0x40]
00001a  6860              LDR      r0,[r4,#4]
00001c  f7fffffe          BL       __aeabi_memcpy
;;;2099   		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
000020  6c21              LDR      r1,[r4,#0x40]
000022  6860              LDR      r0,[r4,#4]
000024  4408              ADD      r0,r0,r1
000026  6060              STR      r0,[r4,#4]
;;;2100   		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000028  e9d40101          LDRD     r0,r1,[r4,#4]
00002c  4288              CMP      r0,r1
00002e  d317              BCC      |L2.96|
;;;2101   		{
;;;2102   			pxQueue->pcWriteTo = pxQueue->pcHead;
000030  6820              LDR      r0,[r4,#0]
000032  6060              STR      r0,[r4,#4]
000034  e014              B        |L2.96|
                  |L2.54|
;;;2103   		}
;;;2104   		else
;;;2105   		{
;;;2106   			mtCOVERAGE_TEST_MARKER();
;;;2107   		}
;;;2108   	}
;;;2109   	else
;;;2110   	{
;;;2111   		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
000036  4639              MOV      r1,r7
000038  6c22              LDR      r2,[r4,#0x40]
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  f7fffffe          BL       __aeabi_memcpy
;;;2112   		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
000040  6c21              LDR      r1,[r4,#0x40]
000042  68e0              LDR      r0,[r4,#0xc]
000044  1a41              SUBS     r1,r0,r1
000046  60e1              STR      r1,[r4,#0xc]
;;;2113   		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000048  6821              LDR      r1,[r4,#0]
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  4288              CMP      r0,r1
00004e  d203              BCS      |L2.88|
;;;2114   		{
;;;2115   			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
000050  6c21              LDR      r1,[r4,#0x40]
000052  68a0              LDR      r0,[r4,#8]
000054  1a41              SUBS     r1,r0,r1
000056  60e1              STR      r1,[r4,#0xc]
                  |L2.88|
;;;2116   		}
;;;2117   		else
;;;2118   		{
;;;2119   			mtCOVERAGE_TEST_MARKER();
;;;2120   		}
;;;2121   
;;;2122   		if( xPosition == queueOVERWRITE )
000058  2d02              CMP      r5,#2
00005a  d101              BNE      |L2.96|
;;;2123   		{
;;;2124   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00005c  b106              CBZ      r6,|L2.96|
;;;2125   			{
;;;2126   				/* An item is not being added but overwritten, so subtract
;;;2127   				one from the recorded number of items in the queue so when
;;;2128   				one is added again below the number of recorded items remains
;;;2129   				correct. */
;;;2130   				--uxMessagesWaiting;
00005e  1e76              SUBS     r6,r6,#1
                  |L2.96|
;;;2131   			}
;;;2132   			else
;;;2133   			{
;;;2134   				mtCOVERAGE_TEST_MARKER();
;;;2135   			}
;;;2136   		}
;;;2137   		else
;;;2138   		{
;;;2139   			mtCOVERAGE_TEST_MARKER();
;;;2140   		}
;;;2141   	}
;;;2142   
;;;2143   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000060  1c70              ADDS     r0,r6,#1
000062  63a0              STR      r0,[r4,#0x38]
;;;2144   
;;;2145   	return xReturn;
000064  4640              MOV      r0,r8
;;;2146   }
000066  e8bd81f0          POP      {r4-r8,pc}
;;;2147   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewQueue PROC
;;;428    
;;;429    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;430    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c06              LDR      r4,[sp,#0x18]
;;;431    	/* Remove compiler warnings about unused parameters should
;;;432    	configUSE_TRACE_FACILITY not be set to 1. */
;;;433    	( void ) ucQueueType;
;;;434    
;;;435    	if( uxItemSize == ( UBaseType_t ) 0 )
00000e  b90d              CBNZ     r5,|L3.20|
;;;436    	{
;;;437    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;438    		be set to NULL because NULL is used as a key to say the queue is used as
;;;439    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;440    		value that is known to be within the memory map. */
;;;441    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000010  6024              STR      r4,[r4,#0]
000012  e000              B        |L3.22|
                  |L3.20|
;;;442    	}
;;;443    	else
;;;444    	{
;;;445    		/* Set the head to the start of the queue storage area. */
;;;446    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
000014  6027              STR      r7,[r4,#0]
                  |L3.22|
;;;447    	}
;;;448    
;;;449    	/* Initialise the queue members as described where the queue type is
;;;450    	defined. */
;;;451    	pxNewQueue->uxLength = uxQueueLength;
000016  63e6              STR      r6,[r4,#0x3c]
;;;452    	pxNewQueue->uxItemSize = uxItemSize;
000018  6425              STR      r5,[r4,#0x40]
;;;453    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xQueueGenericReset
;;;454    
;;;455    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;456    	{
;;;457    		pxNewQueue->ucQueueType = ucQueueType;
;;;458    	}
;;;459    	#endif /* configUSE_TRACE_FACILITY */
;;;460    
;;;461    	#if( configUSE_QUEUE_SETS == 1 )
;;;462    	{
;;;463    		pxNewQueue->pxQueueSetContainer = NULL;
;;;464    	}
;;;465    	#endif /* configUSE_QUEUE_SETS */
;;;466    
;;;467    	traceQUEUE_CREATE( pxNewQueue );
;;;468    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;469    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2286   
;;;2287   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2288   {
000002  4605              MOV      r5,r0
;;;2289   BaseType_t xReturn;
;;;2290   
;;;2291   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2292   	{
;;;2293   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L4.16|
;;;2294   		{
;;;2295   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L4.18|
                  |L4.16|
;;;2296   		}
;;;2297   		else
;;;2298   		{
;;;2299   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L4.18|
;;;2300   		}
;;;2301   	}
;;;2302   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;2303   
;;;2304   	return xReturn;
000016  4620              MOV      r0,r4
;;;2305   }
000018  bd70              POP      {r4-r6,pc}
;;;2306   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;2326   
;;;2327   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2328   {
000002  4605              MOV      r5,r0
;;;2329   BaseType_t xReturn;
;;;2330   
;;;2331   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2332   	{
;;;2333   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L5.20|
;;;2334   		{
;;;2335   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L5.22|
                  |L5.20|
;;;2336   		}
;;;2337   		else
;;;2338   		{
;;;2339   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L5.22|
;;;2340   		}
;;;2341   	}
;;;2342   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;2343   
;;;2344   	return xReturn;
00001a  4620              MOV      r0,r4
;;;2345   }
00001c  bd70              POP      {r4-r6,pc}
;;;2346   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2166   
;;;2167   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2168   {
000002  4604              MOV      r4,r0
;;;2169   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2170   
;;;2171   	/* The lock counts contains the number of extra data items placed or
;;;2172   	removed from the queue while the queue was locked.  When a queue is
;;;2173   	locked items can be added or removed, but the event lists cannot be
;;;2174   	updated. */
;;;2175   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2176   	{
;;;2177   		int8_t cTxLock = pxQueue->cTxLock;
000008  f9945045          LDRSB    r5,[r4,#0x45]
;;;2178   
;;;2179   		/* See if data was added to the queue while it was locked. */
;;;2180   		while( cTxLock > queueLOCKED_UNMODIFIED )
00000c  e010              B        |L6.48|
                  |L6.14|
;;;2181   		{
;;;2182   			/* Data was posted while the queue was locked.  Are any tasks
;;;2183   			blocked waiting for data to become available? */
;;;2184   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2185   			{
;;;2186   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2187   				{
;;;2188   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;2189   					{
;;;2190   						/* The queue is a member of a queue set, and posting to
;;;2191   						the queue set caused a higher priority task to unblock.
;;;2192   						A context switch is required. */
;;;2193   						vTaskMissedYield();
;;;2194   					}
;;;2195   					else
;;;2196   					{
;;;2197   						mtCOVERAGE_TEST_MARKER();
;;;2198   					}
;;;2199   				}
;;;2200   				else
;;;2201   				{
;;;2202   					/* Tasks that are removed from the event list will get
;;;2203   					added to the pending ready list as the scheduler is still
;;;2204   					suspended. */
;;;2205   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2206   					{
;;;2207   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2208   						{
;;;2209   							/* The task waiting has a higher priority so record that a
;;;2210   							context	switch is required. */
;;;2211   							vTaskMissedYield();
;;;2212   						}
;;;2213   						else
;;;2214   						{
;;;2215   							mtCOVERAGE_TEST_MARKER();
;;;2216   						}
;;;2217   					}
;;;2218   					else
;;;2219   					{
;;;2220   						break;
;;;2221   					}
;;;2222   				}
;;;2223   			}
;;;2224   			#else /* configUSE_QUEUE_SETS */
;;;2225   			{
;;;2226   				/* Tasks that are removed from the event list will get added to
;;;2227   				the pending ready list as the scheduler is still suspended. */
;;;2228   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000e  6a60              LDR      r0,[r4,#0x24]
000010  b908              CBNZ     r0,|L6.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L6.24|
                  |L6.22|
000016  2000              MOVS     r0,#0
                  |L6.24|
000018  b938              CBNZ     r0,|L6.42|
;;;2229   				{
;;;2230   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00001a  f1040024          ADD      r0,r4,#0x24
00001e  f7fffffe          BL       xTaskRemoveFromEventList
000022  b118              CBZ      r0,|L6.44|
;;;2231   					{
;;;2232   						/* The task waiting has a higher priority so record that
;;;2233   						a context switch is required. */
;;;2234   						vTaskMissedYield();
000024  f7fffffe          BL       vTaskMissedYield
000028  e000              B        |L6.44|
                  |L6.42|
;;;2235   					}
;;;2236   					else
;;;2237   					{
;;;2238   						mtCOVERAGE_TEST_MARKER();
;;;2239   					}
;;;2240   				}
;;;2241   				else
;;;2242   				{
;;;2243   					break;
00002a  e003              B        |L6.52|
                  |L6.44|
;;;2244   				}
;;;2245   			}
;;;2246   			#endif /* configUSE_QUEUE_SETS */
;;;2247   
;;;2248   			--cTxLock;
00002c  1e68              SUBS     r0,r5,#1
00002e  b245              SXTB     r5,r0
                  |L6.48|
000030  2d00              CMP      r5,#0                 ;2180
000032  dcec              BGT      |L6.14|
                  |L6.52|
000034  bf00              NOP                            ;2243
;;;2249   		}
;;;2250   
;;;2251   		pxQueue->cTxLock = queueUNLOCKED;
000036  20ff              MOVS     r0,#0xff
000038  f8840045          STRB     r0,[r4,#0x45]
;;;2252   	}
;;;2253   	taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;2254   
;;;2255   	/* Do the same for the Rx lock. */
;;;2256   	taskENTER_CRITICAL();
000040  f7fffffe          BL       vPortEnterCritical
;;;2257   	{
;;;2258   		int8_t cRxLock = pxQueue->cRxLock;
000044  f9945044          LDRSB    r5,[r4,#0x44]
;;;2259   
;;;2260   		while( cRxLock > queueLOCKED_UNMODIFIED )
000048  e010              B        |L6.108|
                  |L6.74|
;;;2261   		{
;;;2262   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00004a  6920              LDR      r0,[r4,#0x10]
00004c  b908              CBNZ     r0,|L6.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L6.84|
                  |L6.82|
000052  2000              MOVS     r0,#0
                  |L6.84|
000054  b948              CBNZ     r0,|L6.106|
;;;2263   			{
;;;2264   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000056  f1040010          ADD      r0,r4,#0x10
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  b108              CBZ      r0,|L6.100|
;;;2265   				{
;;;2266   					vTaskMissedYield();
000060  f7fffffe          BL       vTaskMissedYield
                  |L6.100|
;;;2267   				}
;;;2268   				else
;;;2269   				{
;;;2270   					mtCOVERAGE_TEST_MARKER();
;;;2271   				}
;;;2272   
;;;2273   				--cRxLock;
000064  1e68              SUBS     r0,r5,#1
000066  b245              SXTB     r5,r0
000068  e000              B        |L6.108|
                  |L6.106|
;;;2274   			}
;;;2275   			else
;;;2276   			{
;;;2277   				break;
00006a  e001              B        |L6.112|
                  |L6.108|
00006c  2d00              CMP      r5,#0                 ;2260
00006e  dcec              BGT      |L6.74|
                  |L6.112|
000070  bf00              NOP      
;;;2278   			}
;;;2279   		}
;;;2280   
;;;2281   		pxQueue->cRxLock = queueUNLOCKED;
000072  20ff              MOVS     r0,#0xff
000074  f8840044          STRB     r0,[r4,#0x44]
;;;2282   	}
;;;2283   	taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;2284   }
00007c  bd70              POP      {r4-r6,pc}
;;;2285   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1925   
;;;1926   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1927   {
000002  4604              MOV      r4,r0
;;;1928   UBaseType_t uxReturn;
;;;1929   
;;;1930   	configASSERT( xQueue );
;;;1931   
;;;1932   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1933   	{
;;;1934   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000008  6ba5              LDR      r5,[r4,#0x38]
;;;1935   	}
;;;1936   	taskEXIT_CRITICAL();
00000a  f7fffffe          BL       vPortExitCritical
;;;1937   
;;;1938   	return uxReturn;
00000e  4628              MOV      r0,r5
;;;1939   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000010  bd70              POP      {r4-r6,pc}
;;;1940   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1958   
;;;1959   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;1960   {
;;;1961   UBaseType_t uxReturn;
;;;1962   Queue_t * const pxQueue = xQueue;
000002  460a              MOV      r2,r1
;;;1963   
;;;1964   	configASSERT( pxQueue );
;;;1965   	uxReturn = pxQueue->uxMessagesWaiting;
000004  6b90              LDR      r0,[r2,#0x38]
;;;1966   
;;;1967   	return uxReturn;
;;;1968   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000006  4770              BX       lr
;;;1969   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1941   
;;;1942   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1943   {
000002  4604              MOV      r4,r0
;;;1944   UBaseType_t uxReturn;
;;;1945   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1946   
;;;1947   	configASSERT( pxQueue );
;;;1948   
;;;1949   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1950   	{
;;;1951   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00000a  e9d5100e          LDRD     r1,r0,[r5,#0x38]
00000e  1a46              SUBS     r6,r0,r1
;;;1952   	}
;;;1953   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;1954   
;;;1955   	return uxReturn;
000014  4630              MOV      r0,r6
;;;1956   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000016  bd70              POP      {r4-r6,pc}
;;;1957   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1970   
;;;1971   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1972   {
000002  4604              MOV      r4,r0
;;;1973   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1974   
;;;1975   	configASSERT( pxQueue );
;;;1976   	traceQUEUE_DELETE( pxQueue );
;;;1977   
;;;1978   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1979   	{
;;;1980   		vQueueUnregisterQueue( pxQueue );
;;;1981   	}
;;;1982   	#endif
;;;1983   
;;;1984   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1985   	{
;;;1986   		/* The queue can only have been allocated dynamically - free it
;;;1987   		again. */
;;;1988   		vPortFree( pxQueue );
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       vPortFree
;;;1989   	}
;;;1990   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1991   	{
;;;1992   		/* The queue could have been allocated statically or dynamically, so
;;;1993   		check before attempting to free the memory. */
;;;1994   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1995   		{
;;;1996   			vPortFree( pxQueue );
;;;1997   		}
;;;1998   		else
;;;1999   		{
;;;2000   			mtCOVERAGE_TEST_MARKER();
;;;2001   		}
;;;2002   	}
;;;2003   	#else
;;;2004   	{
;;;2005   		/* The queue must have been statically allocated, so is not going to be
;;;2006   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;2007   		( void ) pxQueue;
;;;2008   	}
;;;2009   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;2010   }
00000c  bd70              POP      {r4-r6,pc}
;;;2011   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueWaitForMessageRestricted||, CODE, READONLY, ALIGN=1

                  vQueueWaitForMessageRestricted PROC
;;;2732   
;;;2733   	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2734   	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;2735   	Queue_t * const pxQueue = xQueue;
00000a  462c              MOV      r4,r5
;;;2736   
;;;2737   		/* This function should not be called by application code hence the
;;;2738   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2739   		designed for use by kernel code, and has special calling requirements.
;;;2740   		It can result in vListInsert() being called on a list that can only
;;;2741   		possibly ever have one item in it, so the list will be fast, but even
;;;2742   		so it should be called with the scheduler locked and not from a critical
;;;2743   		section. */
;;;2744   
;;;2745   		/* Only do anything if there are no messages in the queue.  This function
;;;2746   		will not actually cause the task to block, just place it on a blocked
;;;2747   		list.  It will not block until the scheduler is unlocked - at which
;;;2748   		time a yield will be performed.  If an item is added to the queue while
;;;2749   		the queue is locked, and the calling task blocks on the queue, then the
;;;2750   		calling task will be immediately unblocked when the queue is unlocked. */
;;;2751   		prvLockQueue( pxQueue );
00000c  f7fffffe          BL       vPortEnterCritical
000010  f9940044          LDRSB    r0,[r4,#0x44]
000014  1c40              ADDS     r0,r0,#1
000016  b910              CBNZ     r0,|L11.30|
000018  2000              MOVS     r0,#0
00001a  f8840044          STRB     r0,[r4,#0x44]
                  |L11.30|
00001e  f9940045          LDRSB    r0,[r4,#0x45]
000022  1c40              ADDS     r0,r0,#1
000024  b910              CBNZ     r0,|L11.44|
000026  2000              MOVS     r0,#0
000028  f8840045          STRB     r0,[r4,#0x45]
                  |L11.44|
00002c  f7fffffe          BL       vPortExitCritical
;;;2752   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
000030  6ba0              LDR      r0,[r4,#0x38]
000032  b928              CBNZ     r0,|L11.64|
;;;2753   		{
;;;2754   			/* There is nothing in the queue, block for the specified period. */
;;;2755   			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
000034  463a              MOV      r2,r7
000036  4631              MOV      r1,r6
000038  f1040024          ADD      r0,r4,#0x24
00003c  f7fffffe          BL       vTaskPlaceOnEventListRestricted
                  |L11.64|
;;;2756   		}
;;;2757   		else
;;;2758   		{
;;;2759   			mtCOVERAGE_TEST_MARKER();
;;;2760   		}
;;;2761   		prvUnlockQueue( pxQueue );
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       prvUnlockQueue
;;;2762   	}
000046  e8bd81f0          POP      {r4-r8,pc}
;;;2763   
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;367    
;;;368    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;369    	{
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;370    	Queue_t *pxNewQueue;
;;;371    	size_t xQueueSizeInBytes;
;;;372    	uint8_t *pucQueueStorage;
;;;373    
;;;374    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;375    
;;;376    		if( uxItemSize == ( UBaseType_t ) 0 )
00000a  b90d              CBNZ     r5,|L12.16|
;;;377    		{
;;;378    			/* There is not going to be a queue storage area. */
;;;379    			xQueueSizeInBytes = ( size_t ) 0;
00000c  2600              MOVS     r6,#0
00000e  e001              B        |L12.20|
                  |L12.16|
;;;380    		}
;;;381    		else
;;;382    		{
;;;383    			/* Allocate enough space to hold the maximum number of items that
;;;384    			can be in the queue at any time. */
;;;385    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000010  fb07f605          MUL      r6,r7,r5
                  |L12.20|
;;;386    		}
;;;387    
;;;388    		/* Allocate the queue and storage area.  Justification for MISRA
;;;389    		deviation as follows:  pvPortMalloc() always ensures returned memory
;;;390    		blocks are aligned per the requirements of the MCU stack.  In this case
;;;391    		pvPortMalloc() must return a pointer that is guaranteed to meet the
;;;392    		alignment requirements of the Queue_t structure - which in this case
;;;393    		is an int8_t *.  Therefore, whenever the stack alignment requirements
;;;394    		are greater than or equal to the pointer to char requirements the cast
;;;395    		is safe.  In other cases alignment requirements are not strict (one or
;;;396    		two bytes). */
;;;397    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
000014  f1060048          ADD      r0,r6,#0x48
000018  f7fffffe          BL       pvPortMalloc
00001c  4604              MOV      r4,r0
;;;398    
;;;399    		if( pxNewQueue != NULL )
00001e  b14c              CBZ      r4,|L12.52|
;;;400    		{
;;;401    			/* Jump past the queue structure to find the location of the queue
;;;402    			storage area. */
;;;403    			pucQueueStorage = ( uint8_t * ) pxNewQueue;
000020  46a1              MOV      r9,r4
;;;404    			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000022  f1090948          ADD      r9,r9,#0x48
;;;405    
;;;406    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;407    			{
;;;408    				/* Queues can be created either statically or dynamically, so
;;;409    				note this task was created dynamically in case it is later
;;;410    				deleted. */
;;;411    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;412    			}
;;;413    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;414    
;;;415    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000026  4643              MOV      r3,r8
000028  464a              MOV      r2,r9
00002a  4629              MOV      r1,r5
00002c  4638              MOV      r0,r7
00002e  9400              STR      r4,[sp,#0]
000030  f7fffffe          BL       prvInitialiseNewQueue
                  |L12.52|
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;420    			mtCOVERAGE_TEST_MARKER();
;;;421    		}
;;;422    
;;;423    		return pxNewQueue;
000034  4620              MOV      r0,r4
;;;424    	}
000036  e8bd83f8          POP      {r3-r9,pc}
;;;425    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;254    
;;;255    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;257    Queue_t * const pxQueue = xQueue;
000006  462c              MOV      r4,r5
;;;258    
;;;259    	configASSERT( pxQueue );
;;;260    
;;;261    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;262    	{
;;;263    		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
00000c  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000010  6820              LDR      r0,[r4,#0]
000012  fb010002          MLA      r0,r1,r2,r0
000016  60a0              STR      r0,[r4,#8]
;;;264    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000018  2000              MOVS     r0,#0
00001a  63a0              STR      r0,[r4,#0x38]
;;;265    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001c  6820              LDR      r0,[r4,#0]
00001e  6060              STR      r0,[r4,#4]
;;;266    		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000020  6be0              LDR      r0,[r4,#0x3c]
000022  1e40              SUBS     r0,r0,#1
000024  6c22              LDR      r2,[r4,#0x40]
000026  6821              LDR      r1,[r4,#0]
000028  fb001102          MLA      r1,r0,r2,r1
00002c  60e1              STR      r1,[r4,#0xc]
;;;267    		pxQueue->cRxLock = queueUNLOCKED;
00002e  20ff              MOVS     r0,#0xff
000030  f8840044          STRB     r0,[r4,#0x44]
;;;268    		pxQueue->cTxLock = queueUNLOCKED;
000034  f8840045          STRB     r0,[r4,#0x45]
;;;269    
;;;270    		if( xNewQueue == pdFALSE )
000038  b99e              CBNZ     r6,|L13.98|
;;;271    		{
;;;272    			/* If there are tasks blocked waiting to read from the queue, then
;;;273    			the tasks will remain blocked as after this function exits the queue
;;;274    			will still be empty.  If there are tasks blocked waiting to write to
;;;275    			the queue, then one should be unblocked as after this function exits
;;;276    			it will be possible to write to it. */
;;;277    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00003a  6920              LDR      r0,[r4,#0x10]
00003c  b908              CBNZ     r0,|L13.66|
00003e  2001              MOVS     r0,#1
000040  e000              B        |L13.68|
                  |L13.66|
000042  2000              MOVS     r0,#0
                  |L13.68|
000044  b9a8              CBNZ     r0,|L13.114|
;;;278    			{
;;;279    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000046  f1040010          ADD      r0,r4,#0x10
00004a  f7fffffe          BL       xTaskRemoveFromEventList
00004e  b180              CBZ      r0,|L13.114|
;;;280    				{
;;;281    					queueYIELD_IF_USING_PREEMPTION();
000050  f04f5080          MOV      r0,#0x10000000
000054  4909              LDR      r1,|L13.124|
000056  6008              STR      r0,[r1,#0]
000058  f3bf8f4f          DSB      
00005c  f3bf8f6f          ISB      
000060  e007              B        |L13.114|
                  |L13.98|
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			else
;;;289    			{
;;;290    				mtCOVERAGE_TEST_MARKER();
;;;291    			}
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			/* Ensure the event queues start in the correct state. */
;;;296    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000062  f1040010          ADD      r0,r4,#0x10
000066  f7fffffe          BL       vListInitialise
;;;297    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00006a  f1040024          ADD      r0,r4,#0x24
00006e  f7fffffe          BL       vListInitialise
                  |L13.114|
;;;298    		}
;;;299    	}
;;;300    	taskEXIT_CRITICAL();
000072  f7fffffe          BL       vPortExitCritical
;;;301    
;;;302    	/* A value is returned for calling semantic consistency with previous
;;;303    	versions. */
;;;304    	return pdPASS;
000076  2001              MOVS     r0,#1
;;;305    }
000078  bd70              POP      {r4-r6,pc}
;;;306    /*-----------------------------------------------------------*/
                          ENDP

00007a  0000              DCW      0x0000
                  |L13.124|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;746    
;;;747    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;748    {
000004  b083              SUB      sp,sp,#0xc
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  461d              MOV      r5,r3
;;;749    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0900          MOV      r9,#0
;;;750    TimeOut_t xTimeOut;
;;;751    Queue_t * const pxQueue = xQueue;
000010  463c              MOV      r4,r7
;;;752    
;;;753    	configASSERT( pxQueue );
;;;754    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;755    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;756    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;757    	{
;;;758    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;759    	}
;;;760    	#endif
;;;761    
;;;762    
;;;763    	/*lint -save -e904 This function relaxes the coding standard somewhat to
;;;764    	allow return statements within the function itself.  This is done in the
;;;765    	interest of execution time efficiency. */
;;;766    	for( ;; )
000012  bf00              NOP      
                  |L14.20|
;;;767    	{
;;;768    		taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;769    		{
;;;770    			/* Is there room on the queue now?  The running task must be the
;;;771    			highest priority task wanting to access the queue.  If the head item
;;;772    			in the queue is to be overwritten then it does not matter if the
;;;773    			queue is full. */
;;;774    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  6be1              LDR      r1,[r4,#0x3c]
00001c  4288              CMP      r0,r1
00001e  d301              BCC      |L14.36|
000020  2d02              CMP      r5,#2
000022  d128              BNE      |L14.118|
                  |L14.36|
;;;775    			{
;;;776    				traceQUEUE_SEND( pxQueue );
;;;777    
;;;778    				#if ( configUSE_QUEUE_SETS == 1 )
;;;779    				{
;;;780    				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;781    
;;;782    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;783    
;;;784    					if( pxQueue->pxQueueSetContainer != NULL )
;;;785    					{
;;;786    						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;787    						{
;;;788    							/* Do not notify the queue set as an existing item
;;;789    							was overwritten in the queue so the number of items
;;;790    							in the queue has not changed. */
;;;791    							mtCOVERAGE_TEST_MARKER();
;;;792    						}
;;;793    						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;794    						{
;;;795    							/* The queue is a member of a queue set, and posting
;;;796    							to the queue set caused a higher priority task to
;;;797    							unblock. A context switch is required. */
;;;798    							queueYIELD_IF_USING_PREEMPTION();
;;;799    						}
;;;800    						else
;;;801    						{
;;;802    							mtCOVERAGE_TEST_MARKER();
;;;803    						}
;;;804    					}
;;;805    					else
;;;806    					{
;;;807    						/* If there was a task waiting for data to arrive on the
;;;808    						queue then unblock it now. */
;;;809    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;810    						{
;;;811    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;812    							{
;;;813    								/* The unblocked task has a priority higher than
;;;814    								our own so yield immediately.  Yes it is ok to
;;;815    								do this from within the critical section - the
;;;816    								kernel takes care of that. */
;;;817    								queueYIELD_IF_USING_PREEMPTION();
;;;818    							}
;;;819    							else
;;;820    							{
;;;821    								mtCOVERAGE_TEST_MARKER();
;;;822    							}
;;;823    						}
;;;824    						else if( xYieldRequired != pdFALSE )
;;;825    						{
;;;826    							/* This path is a special case that will only get
;;;827    							executed if the task was holding multiple mutexes
;;;828    							and the mutexes were given back in an order that is
;;;829    							different to that in which they were taken. */
;;;830    							queueYIELD_IF_USING_PREEMPTION();
;;;831    						}
;;;832    						else
;;;833    						{
;;;834    							mtCOVERAGE_TEST_MARKER();
;;;835    						}
;;;836    					}
;;;837    				}
;;;838    				#else /* configUSE_QUEUE_SETS */
;;;839    				{
;;;840    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000024  462a              MOV      r2,r5
000026  4641              MOV      r1,r8
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       prvCopyDataToQueue
00002e  4606              MOV      r6,r0
;;;841    
;;;842    					/* If there was a task waiting for data to arrive on the
;;;843    					queue then unblock it now. */
;;;844    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000030  6a60              LDR      r0,[r4,#0x24]
000032  b908              CBNZ     r0,|L14.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L14.58|
                  |L14.56|
000038  2000              MOVS     r0,#0
                  |L14.58|
00003a  b968              CBNZ     r0,|L14.88|
;;;845    					{
;;;846    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00003c  f1040024          ADD      r0,r4,#0x24
000040  f7fffffe          BL       xTaskRemoveFromEventList
000044  b188              CBZ      r0,|L14.106|
;;;847    						{
;;;848    							/* The unblocked task has a priority higher than
;;;849    							our own so yield immediately.  Yes it is ok to do
;;;850    							this from within the critical section - the kernel
;;;851    							takes care of that. */
;;;852    							queueYIELD_IF_USING_PREEMPTION();
000046  f04f5080          MOV      r0,#0x10000000
00004a  4932              LDR      r1,|L14.276|
00004c  6008              STR      r0,[r1,#0]
00004e  f3bf8f4f          DSB      
000052  f3bf8f6f          ISB      
000056  e008              B        |L14.106|
                  |L14.88|
;;;853    						}
;;;854    						else
;;;855    						{
;;;856    							mtCOVERAGE_TEST_MARKER();
;;;857    						}
;;;858    					}
;;;859    					else if( xYieldRequired != pdFALSE )
000058  b13e              CBZ      r6,|L14.106|
;;;860    					{
;;;861    						/* This path is a special case that will only get
;;;862    						executed if the task was holding multiple mutexes and
;;;863    						the mutexes were given back in an order that is
;;;864    						different to that in which they were taken. */
;;;865    						queueYIELD_IF_USING_PREEMPTION();
00005a  f04f5080          MOV      r0,#0x10000000
00005e  492d              LDR      r1,|L14.276|
000060  6008              STR      r0,[r1,#0]
000062  f3bf8f4f          DSB      
000066  f3bf8f6f          ISB      
                  |L14.106|
;;;866    					}
;;;867    					else
;;;868    					{
;;;869    						mtCOVERAGE_TEST_MARKER();
;;;870    					}
;;;871    				}
;;;872    				#endif /* configUSE_QUEUE_SETS */
;;;873    
;;;874    				taskEXIT_CRITICAL();
00006a  f7fffffe          BL       vPortExitCritical
;;;875    				return pdPASS;
00006e  2001              MOVS     r0,#1
                  |L14.112|
;;;876    			}
;;;877    			else
;;;878    			{
;;;879    				if( xTicksToWait == ( TickType_t ) 0 )
;;;880    				{
;;;881    					/* The queue was full and no block time is specified (or
;;;882    					the block time has expired) so leave now. */
;;;883    					taskEXIT_CRITICAL();
;;;884    
;;;885    					/* Return to the original privilege level before exiting
;;;886    					the function. */
;;;887    					traceQUEUE_SEND_FAILED( pxQueue );
;;;888    					return errQUEUE_FULL;
;;;889    				}
;;;890    				else if( xEntryTimeSet == pdFALSE )
;;;891    				{
;;;892    					/* The queue was full and a block time was specified so
;;;893    					configure the timeout structure. */
;;;894    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;895    					xEntryTimeSet = pdTRUE;
;;;896    				}
;;;897    				else
;;;898    				{
;;;899    					/* Entry time was already set. */
;;;900    					mtCOVERAGE_TEST_MARKER();
;;;901    				}
;;;902    			}
;;;903    		}
;;;904    		taskEXIT_CRITICAL();
;;;905    
;;;906    		/* Interrupts and other tasks can send to and receive from the queue
;;;907    		now the critical section has been exited. */
;;;908    
;;;909    		vTaskSuspendAll();
;;;910    		prvLockQueue( pxQueue );
;;;911    
;;;912    		/* Update the timeout state to see if it has expired yet. */
;;;913    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;914    		{
;;;915    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;916    			{
;;;917    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;918    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;919    
;;;920    				/* Unlocking the queue means queue events can effect the
;;;921    				event list.  It is possible that interrupts occurring now
;;;922    				remove this task from the event list again - but as the
;;;923    				scheduler is suspended the task will go onto the pending
;;;924    				ready last instead of the actual ready list. */
;;;925    				prvUnlockQueue( pxQueue );
;;;926    
;;;927    				/* Resuming the scheduler will move tasks from the pending
;;;928    				ready list into the ready list - so it is feasible that this
;;;929    				task is already in a ready list before it yields - in which
;;;930    				case the yield will not cause a context switch unless there
;;;931    				is also a higher priority task in the pending ready list. */
;;;932    				if( xTaskResumeAll() == pdFALSE )
;;;933    				{
;;;934    					portYIELD_WITHIN_API();
;;;935    				}
;;;936    			}
;;;937    			else
;;;938    			{
;;;939    				/* Try again. */
;;;940    				prvUnlockQueue( pxQueue );
;;;941    				( void ) xTaskResumeAll();
;;;942    			}
;;;943    		}
;;;944    		else
;;;945    		{
;;;946    			/* The timeout has expired. */
;;;947    			prvUnlockQueue( pxQueue );
;;;948    			( void ) xTaskResumeAll();
;;;949    
;;;950    			traceQUEUE_SEND_FAILED( pxQueue );
;;;951    			return errQUEUE_FULL;
;;;952    		}
;;;953    	} /*lint -restore */
;;;954    }
000070  b007              ADD      sp,sp,#0x1c
000072  e8bd83f0          POP      {r4-r9,pc}
                  |L14.118|
000076  9805              LDR      r0,[sp,#0x14]         ;879
000078  b918              CBNZ     r0,|L14.130|
00007a  f7fffffe          BL       vPortExitCritical
00007e  2000              MOVS     r0,#0                 ;888
000080  e7f6              B        |L14.112|
                  |L14.130|
000082  f1b90f00          CMP      r9,#0                 ;890
000086  d104              BNE      |L14.146|
000088  a801              ADD      r0,sp,#4              ;894
00008a  f7fffffe          BL       vTaskInternalSetTimeOutState
00008e  f04f0901          MOV      r9,#1                 ;895
                  |L14.146|
000092  f7fffffe          BL       vPortExitCritical
000096  f7fffffe          BL       vTaskSuspendAll
00009a  f7fffffe          BL       vPortEnterCritical
00009e  f9940044          LDRSB    r0,[r4,#0x44]         ;910
0000a2  1c40              ADDS     r0,r0,#1              ;910
0000a4  b910              CBNZ     r0,|L14.172|
0000a6  2000              MOVS     r0,#0                 ;910
0000a8  f8840044          STRB     r0,[r4,#0x44]         ;910
                  |L14.172|
0000ac  f9940045          LDRSB    r0,[r4,#0x45]         ;910
0000b0  1c40              ADDS     r0,r0,#1              ;910
0000b2  b910              CBNZ     r0,|L14.186|
0000b4  2000              MOVS     r0,#0                 ;910
0000b6  f8840045          STRB     r0,[r4,#0x45]         ;910
                  |L14.186|
0000ba  f7fffffe          BL       vPortExitCritical
0000be  a905              ADD      r1,sp,#0x14           ;913
0000c0  a801              ADD      r0,sp,#4              ;913
0000c2  f7fffffe          BL       xTaskCheckForTimeOut
0000c6  b9f0              CBNZ     r0,|L14.262|
0000c8  4620              MOV      r0,r4                 ;915
0000ca  f7fffffe          BL       prvIsQueueFull
0000ce  b1a0              CBZ      r0,|L14.250|
0000d0  f1040010          ADD      r0,r4,#0x10           ;918
0000d4  9905              LDR      r1,[sp,#0x14]         ;918
0000d6  f7fffffe          BL       vTaskPlaceOnEventList
0000da  4620              MOV      r0,r4                 ;925
0000dc  f7fffffe          BL       prvUnlockQueue
0000e0  f7fffffe          BL       xTaskResumeAll
0000e4  2800              CMP      r0,#0                 ;932
0000e6  d195              BNE      |L14.20|
0000e8  f04f5080          MOV      r0,#0x10000000        ;934
0000ec  4909              LDR      r1,|L14.276|
0000ee  6008              STR      r0,[r1,#0]            ;934
0000f0  f3bf8f4f          DSB                            ;934
0000f4  f3bf8f6f          ISB                            ;934
0000f8  e78c              B        |L14.20|
                  |L14.250|
0000fa  4620              MOV      r0,r4                 ;940
0000fc  f7fffffe          BL       prvUnlockQueue
000100  f7fffffe          BL       xTaskResumeAll
000104  e786              B        |L14.20|
                  |L14.262|
000106  4620              MOV      r0,r4                 ;947
000108  f7fffffe          BL       prvUnlockQueue
00010c  f7fffffe          BL       xTaskResumeAll
000110  2000              MOVS     r0,#0                 ;951
000112  e7ad              B        |L14.112|
;;;955    /*-----------------------------------------------------------*/
                          ENDP

                  |L14.276|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;956    
;;;957    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;958    {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;959    BaseType_t xReturn;
;;;960    UBaseType_t uxSavedInterruptStatus;
;;;961    Queue_t * const pxQueue = xQueue;
00000c  462c              MOV      r4,r5
;;;962    
;;;963    	configASSERT( pxQueue );
;;;964    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;965    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;966    
;;;967    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;968    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;969    	above the maximum system call priority are kept permanently enabled, even
;;;970    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;971    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;972    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;973    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;974    	assigned a priority above the configured maximum system call priority.
;;;975    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;976    	that have been assigned a priority at or (logically) below the maximum
;;;977    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;978    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;979    	More information (albeit Cortex-M specific) is provided on the following
;;;980    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;981    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;982    
;;;983    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;984    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;985    	read, instead return a flag to say whether a context switch is required or
;;;986    	not (i.e. has a task with a higher priority than us been woken by this
;;;987    	post). */
;;;988    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000e  bf00              NOP      
000010  21bf              MOVS     r1,#0xbf
000012  f3ef8011          MRS      r0,BASEPRI
000016  f3818811          MSR      BASEPRI,r1
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  4681              MOV      r9,r0
;;;989    	{
;;;990    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000026  6ba0              LDR      r0,[r4,#0x38]
000028  6be1              LDR      r1,[r4,#0x3c]
00002a  4288              CMP      r0,r1
00002c  d301              BCC      |L15.50|
00002e  2f02              CMP      r7,#2
000030  d120              BNE      |L15.116|
                  |L15.50|
;;;991    		{
;;;992    			const int8_t cTxLock = pxQueue->cTxLock;
000032  f994b045          LDRSB    r11,[r4,#0x45]
;;;993    
;;;994    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;995    
;;;996    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;997    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;998    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;999    			called here even though the disinherit function does not check if
;;;1000   			the scheduler is suspended before accessing the ready lists. */
;;;1001   			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000036  463a              MOV      r2,r7
000038  4651              MOV      r1,r10
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       prvCopyDataToQueue
;;;1002   
;;;1003   			/* The event list is not altered if the queue is locked.  This will
;;;1004   			be done when the queue is unlocked later. */
;;;1005   			if( cTxLock == queueUNLOCKED )
000040  f10b0001          ADD      r0,r11,#1
000044  b970              CBNZ     r0,|L15.100|
;;;1006   			{
;;;1007   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1008   				{
;;;1009   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1010   					{
;;;1011   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;1012   						{
;;;1013   							/* The queue is a member of a queue set, and posting
;;;1014   							to the queue set caused a higher priority task to
;;;1015   							unblock.  A context switch is required. */
;;;1016   							if( pxHigherPriorityTaskWoken != NULL )
;;;1017   							{
;;;1018   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1019   							}
;;;1020   							else
;;;1021   							{
;;;1022   								mtCOVERAGE_TEST_MARKER();
;;;1023   							}
;;;1024   						}
;;;1025   						else
;;;1026   						{
;;;1027   							mtCOVERAGE_TEST_MARKER();
;;;1028   						}
;;;1029   					}
;;;1030   					else
;;;1031   					{
;;;1032   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1033   						{
;;;1034   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1035   							{
;;;1036   								/* The task waiting has a higher priority so
;;;1037   								record that a context switch is required. */
;;;1038   								if( pxHigherPriorityTaskWoken != NULL )
;;;1039   								{
;;;1040   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1041   								}
;;;1042   								else
;;;1043   								{
;;;1044   									mtCOVERAGE_TEST_MARKER();
;;;1045   								}
;;;1046   							}
;;;1047   							else
;;;1048   							{
;;;1049   								mtCOVERAGE_TEST_MARKER();
;;;1050   							}
;;;1051   						}
;;;1052   						else
;;;1053   						{
;;;1054   							mtCOVERAGE_TEST_MARKER();
;;;1055   						}
;;;1056   					}
;;;1057   				}
;;;1058   				#else /* configUSE_QUEUE_SETS */
;;;1059   				{
;;;1060   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000046  6a60              LDR      r0,[r4,#0x24]
000048  b908              CBNZ     r0,|L15.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L15.80|
                  |L15.78|
00004e  2000              MOVS     r0,#0
                  |L15.80|
000050  b968              CBNZ     r0,|L15.110|
;;;1061   					{
;;;1062   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000052  f1040024          ADD      r0,r4,#0x24
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  b140              CBZ      r0,|L15.110|
;;;1063   						{
;;;1064   							/* The task waiting has a higher priority so record that a
;;;1065   							context	switch is required. */
;;;1066   							if( pxHigherPriorityTaskWoken != NULL )
00005c  b13e              CBZ      r6,|L15.110|
;;;1067   							{
;;;1068   								*pxHigherPriorityTaskWoken = pdTRUE;
00005e  2001              MOVS     r0,#1
000060  6030              STR      r0,[r6,#0]
000062  e004              B        |L15.110|
                  |L15.100|
;;;1069   							}
;;;1070   							else
;;;1071   							{
;;;1072   								mtCOVERAGE_TEST_MARKER();
;;;1073   							}
;;;1074   						}
;;;1075   						else
;;;1076   						{
;;;1077   							mtCOVERAGE_TEST_MARKER();
;;;1078   						}
;;;1079   					}
;;;1080   					else
;;;1081   					{
;;;1082   						mtCOVERAGE_TEST_MARKER();
;;;1083   					}
;;;1084   				}
;;;1085   				#endif /* configUSE_QUEUE_SETS */
;;;1086   			}
;;;1087   			else
;;;1088   			{
;;;1089   				/* Increment the lock count so the task that unlocks the queue
;;;1090   				knows that data was posted while it was locked. */
;;;1091   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000064  f10b0001          ADD      r0,r11,#1
000068  b240              SXTB     r0,r0
00006a  f8840045          STRB     r0,[r4,#0x45]
                  |L15.110|
;;;1092   			}
;;;1093   
;;;1094   			xReturn = pdPASS;
00006e  f04f0801          MOV      r8,#1
;;;1095   		}
000072  e001              B        |L15.120|
                  |L15.116|
;;;1096   		else
;;;1097   		{
;;;1098   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1099   			xReturn = errQUEUE_FULL;
000074  f04f0800          MOV      r8,#0
                  |L15.120|
;;;1100   		}
;;;1101   	}
;;;1102   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000078  bf00              NOP      
00007a  f3898811          MSR      BASEPRI,r9
00007e  bf00              NOP      
;;;1103   
;;;1104   	return xReturn;
000080  4640              MOV      r0,r8
;;;1105   }
000082  e8bd9ff0          POP      {r4-r12,pc}
;;;1106   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1107   
;;;1108   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1109   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1110   BaseType_t xReturn;
;;;1111   UBaseType_t uxSavedInterruptStatus;
;;;1112   Queue_t * const pxQueue = xQueue;
000008  462c              MOV      r4,r5
;;;1113   
;;;1114   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1115   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1116   	read, instead return a flag to say whether a context switch is required or
;;;1117   	not (i.e. has a task with a higher priority than us been woken by this
;;;1118   	post). */
;;;1119   
;;;1120   	configASSERT( pxQueue );
;;;1121   
;;;1122   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1123   	if the item size is not 0. */
;;;1124   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1125   
;;;1126   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1127   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1128   	interrupts, only tasks. */
;;;1129   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
;;;1130   
;;;1131   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1132   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1133   	above the maximum system call priority are kept permanently enabled, even
;;;1134   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1135   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1136   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1137   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1138   	assigned a priority above the configured maximum system call priority.
;;;1139   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1140   	that have been assigned a priority at or (logically) below the maximum
;;;1141   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1142   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1143   	More information (albeit Cortex-M specific) is provided on the following
;;;1144   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1145   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1146   
;;;1147   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4680              MOV      r8,r0
;;;1148   	{
;;;1149   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000022  f8d49038          LDR      r9,[r4,#0x38]
;;;1150   
;;;1151   		/* When the queue is used to implement a semaphore no data is ever
;;;1152   		moved through the queue but it is still valid to see if the queue 'has
;;;1153   		space'. */
;;;1154   		if( uxMessagesWaiting < pxQueue->uxLength )
000026  6be0              LDR      r0,[r4,#0x3c]
000028  4548              CMP      r0,r9
00002a  d91d              BLS      |L16.104|
;;;1155   		{
;;;1156   			const int8_t cTxLock = pxQueue->cTxLock;
00002c  f994a045          LDRSB    r10,[r4,#0x45]
;;;1157   
;;;1158   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1159   
;;;1160   			/* A task can only have an inherited priority if it is a mutex
;;;1161   			holder - and if there is a mutex holder then the mutex cannot be
;;;1162   			given from an ISR.  As this is the ISR version of the function it
;;;1163   			can be assumed there is no mutex holder and no need to determine if
;;;1164   			priority disinheritance is needed.  Simply increase the count of
;;;1165   			messages (semaphores) available. */
;;;1166   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000030  f1090001          ADD      r0,r9,#1
000034  63a0              STR      r0,[r4,#0x38]
;;;1167   
;;;1168   			/* The event list is not altered if the queue is locked.  This will
;;;1169   			be done when the queue is unlocked later. */
;;;1170   			if( cTxLock == queueUNLOCKED )
000036  f10a0001          ADD      r0,r10,#1
00003a  b970              CBNZ     r0,|L16.90|
;;;1171   			{
;;;1172   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1173   				{
;;;1174   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1175   					{
;;;1176   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1177   						{
;;;1178   							/* The semaphore is a member of a queue set, and
;;;1179   							posting	to the queue set caused a higher priority
;;;1180   							task to	unblock.  A context switch is required. */
;;;1181   							if( pxHigherPriorityTaskWoken != NULL )
;;;1182   							{
;;;1183   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1184   							}
;;;1185   							else
;;;1186   							{
;;;1187   								mtCOVERAGE_TEST_MARKER();
;;;1188   							}
;;;1189   						}
;;;1190   						else
;;;1191   						{
;;;1192   							mtCOVERAGE_TEST_MARKER();
;;;1193   						}
;;;1194   					}
;;;1195   					else
;;;1196   					{
;;;1197   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1198   						{
;;;1199   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1200   							{
;;;1201   								/* The task waiting has a higher priority so
;;;1202   								record that a context switch is required. */
;;;1203   								if( pxHigherPriorityTaskWoken != NULL )
;;;1204   								{
;;;1205   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1206   								}
;;;1207   								else
;;;1208   								{
;;;1209   									mtCOVERAGE_TEST_MARKER();
;;;1210   								}
;;;1211   							}
;;;1212   							else
;;;1213   							{
;;;1214   								mtCOVERAGE_TEST_MARKER();
;;;1215   							}
;;;1216   						}
;;;1217   						else
;;;1218   						{
;;;1219   							mtCOVERAGE_TEST_MARKER();
;;;1220   						}
;;;1221   					}
;;;1222   				}
;;;1223   				#else /* configUSE_QUEUE_SETS */
;;;1224   				{
;;;1225   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00003c  6a60              LDR      r0,[r4,#0x24]
00003e  b908              CBNZ     r0,|L16.68|
000040  2001              MOVS     r0,#1
000042  e000              B        |L16.70|
                  |L16.68|
000044  2000              MOVS     r0,#0
                  |L16.70|
000046  b968              CBNZ     r0,|L16.100|
;;;1226   					{
;;;1227   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000048  f1040024          ADD      r0,r4,#0x24
00004c  f7fffffe          BL       xTaskRemoveFromEventList
000050  b140              CBZ      r0,|L16.100|
;;;1228   						{
;;;1229   							/* The task waiting has a higher priority so record that a
;;;1230   							context	switch is required. */
;;;1231   							if( pxHigherPriorityTaskWoken != NULL )
000052  b13e              CBZ      r6,|L16.100|
;;;1232   							{
;;;1233   								*pxHigherPriorityTaskWoken = pdTRUE;
000054  2001              MOVS     r0,#1
000056  6030              STR      r0,[r6,#0]
000058  e004              B        |L16.100|
                  |L16.90|
;;;1234   							}
;;;1235   							else
;;;1236   							{
;;;1237   								mtCOVERAGE_TEST_MARKER();
;;;1238   							}
;;;1239   						}
;;;1240   						else
;;;1241   						{
;;;1242   							mtCOVERAGE_TEST_MARKER();
;;;1243   						}
;;;1244   					}
;;;1245   					else
;;;1246   					{
;;;1247   						mtCOVERAGE_TEST_MARKER();
;;;1248   					}
;;;1249   				}
;;;1250   				#endif /* configUSE_QUEUE_SETS */
;;;1251   			}
;;;1252   			else
;;;1253   			{
;;;1254   				/* Increment the lock count so the task that unlocks the queue
;;;1255   				knows that data was posted while it was locked. */
;;;1256   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
00005a  f10a0001          ADD      r0,r10,#1
00005e  b240              SXTB     r0,r0
000060  f8840045          STRB     r0,[r4,#0x45]
                  |L16.100|
;;;1257   			}
;;;1258   
;;;1259   			xReturn = pdPASS;
000064  2701              MOVS     r7,#1
;;;1260   		}
000066  e000              B        |L16.106|
                  |L16.104|
;;;1261   		else
;;;1262   		{
;;;1263   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1264   			xReturn = errQUEUE_FULL;
000068  2700              MOVS     r7,#0
                  |L16.106|
;;;1265   		}
;;;1266   	}
;;;1267   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00006a  bf00              NOP      
00006c  f3888811          MSR      BASEPRI,r8
000070  bf00              NOP      
;;;1268   
;;;1269   	return xReturn;
000072  4638              MOV      r0,r7
;;;1270   }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;1271   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2307   
;;;2308   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2309   {
;;;2310   BaseType_t xReturn;
;;;2311   Queue_t * const pxQueue = xQueue;
000002  460a              MOV      r2,r1
;;;2312   
;;;2313   	configASSERT( pxQueue );
;;;2314   	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
000004  6b93              LDR      r3,[r2,#0x38]
000006  b90b              CBNZ     r3,|L17.12|
;;;2315   	{
;;;2316   		xReturn = pdTRUE;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L17.14|
                  |L17.12|
;;;2317   	}
;;;2318   	else
;;;2319   	{
;;;2320   		xReturn = pdFALSE;
00000c  2000              MOVS     r0,#0
                  |L17.14|
;;;2321   	}
;;;2322   
;;;2323   	return xReturn;
;;;2324   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000e  4770              BX       lr
;;;2325   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2347   
;;;2348   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;2349   {
000002  4601              MOV      r1,r0
;;;2350   BaseType_t xReturn;
;;;2351   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;2352   
;;;2353   	configASSERT( pxQueue );
;;;2354   	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000006  6b93              LDR      r3,[r2,#0x38]
000008  6bd4              LDR      r4,[r2,#0x3c]
00000a  42a3              CMP      r3,r4
00000c  d101              BNE      |L18.18|
;;;2355   	{
;;;2356   		xReturn = pdTRUE;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L18.20|
                  |L18.18|
;;;2357   	}
;;;2358   	else
;;;2359   	{
;;;2360   		xReturn = pdFALSE;
000012  2000              MOVS     r0,#0
                  |L18.20|
;;;2361   	}
;;;2362   
;;;2363   	return xReturn;
;;;2364   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000014  bd10              POP      {r4,pc}
;;;2365   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=2

                  xQueuePeek PROC
;;;1631   
;;;1632   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1633   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;1634   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1635   TimeOut_t xTimeOut;
;;;1636   int8_t *pcOriginalReadPosition;
;;;1637   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1638   
;;;1639   	/* Check the pointer is not NULL. */
;;;1640   	configASSERT( ( pxQueue ) );
;;;1641   
;;;1642   	/* The buffer into which data is received can only be NULL if the data size
;;;1643   	is zero (so no data is copied into the buffer. */
;;;1644   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1645   
;;;1646   	/* Cannot block if the scheduler is suspended. */
;;;1647   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1648   	{
;;;1649   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1650   	}
;;;1651   	#endif
;;;1652   
;;;1653   
;;;1654   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1655   	allow return statements within the function itself.  This is done in the
;;;1656   	interest of execution time efficiency. */
;;;1657   	for( ;; )
000010  bf00              NOP      
                  |L19.18|
;;;1658   	{
;;;1659   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1660   		{
;;;1661   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000016  f8d49038          LDR      r9,[r4,#0x38]
;;;1662   
;;;1663   			/* Is there data in the queue now?  To be running the calling task
;;;1664   			must be the highest priority task wanting to access the queue. */
;;;1665   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00001a  f1b90f00          CMP      r9,#0
00001e  d01e              BEQ      |L19.94|
;;;1666   			{
;;;1667   				/* Remember the read position so it can be reset after the data
;;;1668   				is read from the queue as this function is only peeking the
;;;1669   				data, not removing it. */
;;;1670   				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
000020  68e6              LDR      r6,[r4,#0xc]
;;;1671   
;;;1672   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000022  4639              MOV      r1,r7
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       prvCopyDataFromQueue
;;;1673   				traceQUEUE_PEEK( pxQueue );
;;;1674   
;;;1675   				/* The data is not being removed, so reset the read pointer. */
;;;1676   				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
00002a  60e6              STR      r6,[r4,#0xc]
;;;1677   
;;;1678   				/* The data is being left in the queue, so see if there are
;;;1679   				any other tasks waiting for the data. */
;;;1680   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00002c  6a60              LDR      r0,[r4,#0x24]
00002e  b908              CBNZ     r0,|L19.52|
000030  2001              MOVS     r0,#1
000032  e000              B        |L19.54|
                  |L19.52|
000034  2000              MOVS     r0,#0
                  |L19.54|
000036  b960              CBNZ     r0,|L19.82|
;;;1681   				{
;;;1682   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000038  f1040024          ADD      r0,r4,#0x24
00003c  f7fffffe          BL       xTaskRemoveFromEventList
000040  b138              CBZ      r0,|L19.82|
;;;1683   					{
;;;1684   						/* The task waiting has a higher priority than this task. */
;;;1685   						queueYIELD_IF_USING_PREEMPTION();
000042  f04f5080          MOV      r0,#0x10000000
000046  4930              LDR      r1,|L19.264|
000048  6008              STR      r0,[r1,#0]
00004a  f3bf8f4f          DSB      
00004e  f3bf8f6f          ISB      
                  |L19.82|
;;;1686   					}
;;;1687   					else
;;;1688   					{
;;;1689   						mtCOVERAGE_TEST_MARKER();
;;;1690   					}
;;;1691   				}
;;;1692   				else
;;;1693   				{
;;;1694   					mtCOVERAGE_TEST_MARKER();
;;;1695   				}
;;;1696   
;;;1697   				taskEXIT_CRITICAL();
000052  f7fffffe          BL       vPortExitCritical
;;;1698   				return pdPASS;
000056  2001              MOVS     r0,#1
                  |L19.88|
;;;1699   			}
;;;1700   			else
;;;1701   			{
;;;1702   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1703   				{
;;;1704   					/* The queue was empty and no block time is specified (or
;;;1705   					the block time has expired) so leave now. */
;;;1706   					taskEXIT_CRITICAL();
;;;1707   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1708   					return errQUEUE_EMPTY;
;;;1709   				}
;;;1710   				else if( xEntryTimeSet == pdFALSE )
;;;1711   				{
;;;1712   					/* The queue was empty and a block time was specified so
;;;1713   					configure the timeout structure ready to enter the blocked
;;;1714   					state. */
;;;1715   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1716   					xEntryTimeSet = pdTRUE;
;;;1717   				}
;;;1718   				else
;;;1719   				{
;;;1720   					/* Entry time was already set. */
;;;1721   					mtCOVERAGE_TEST_MARKER();
;;;1722   				}
;;;1723   			}
;;;1724   		}
;;;1725   		taskEXIT_CRITICAL();
;;;1726   
;;;1727   		/* Interrupts and other tasks can send to and receive from the queue
;;;1728   		now the critical section has been exited. */
;;;1729   
;;;1730   		vTaskSuspendAll();
;;;1731   		prvLockQueue( pxQueue );
;;;1732   
;;;1733   		/* Update the timeout state to see if it has expired yet. */
;;;1734   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1735   		{
;;;1736   			/* Timeout has not expired yet, check to see if there is data in the
;;;1737   			queue now, and if not enter the Blocked state to wait for data. */
;;;1738   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1739   			{
;;;1740   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1741   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1742   				prvUnlockQueue( pxQueue );
;;;1743   				if( xTaskResumeAll() == pdFALSE )
;;;1744   				{
;;;1745   					portYIELD_WITHIN_API();
;;;1746   				}
;;;1747   				else
;;;1748   				{
;;;1749   					mtCOVERAGE_TEST_MARKER();
;;;1750   				}
;;;1751   			}
;;;1752   			else
;;;1753   			{
;;;1754   				/* There is data in the queue now, so don't enter the blocked
;;;1755   				state, instead return to try and obtain the data. */
;;;1756   				prvUnlockQueue( pxQueue );
;;;1757   				( void ) xTaskResumeAll();
;;;1758   			}
;;;1759   		}
;;;1760   		else
;;;1761   		{
;;;1762   			/* The timeout has expired.  If there is still no data in the queue
;;;1763   			exit, otherwise go back and try to read the data again. */
;;;1764   			prvUnlockQueue( pxQueue );
;;;1765   			( void ) xTaskResumeAll();
;;;1766   
;;;1767   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1768   			{
;;;1769   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1770   				return errQUEUE_EMPTY;
;;;1771   			}
;;;1772   			else
;;;1773   			{
;;;1774   				mtCOVERAGE_TEST_MARKER();
;;;1775   			}
;;;1776   		}
;;;1777   	} /*lint -restore */
;;;1778   }
000058  b005              ADD      sp,sp,#0x14
00005a  e8bd83f0          POP      {r4-r9,pc}
                  |L19.94|
00005e  9804              LDR      r0,[sp,#0x10]         ;1702
000060  b918              CBNZ     r0,|L19.106|
000062  f7fffffe          BL       vPortExitCritical
000066  2000              MOVS     r0,#0                 ;1708
000068  e7f6              B        |L19.88|
                  |L19.106|
00006a  f1b80f00          CMP      r8,#0                 ;1710
00006e  d104              BNE      |L19.122|
000070  4668              MOV      r0,sp                 ;1715
000072  f7fffffe          BL       vTaskInternalSetTimeOutState
000076  f04f0801          MOV      r8,#1                 ;1716
                  |L19.122|
00007a  f7fffffe          BL       vPortExitCritical
00007e  f7fffffe          BL       vTaskSuspendAll
000082  f7fffffe          BL       vPortEnterCritical
000086  f9940044          LDRSB    r0,[r4,#0x44]         ;1731
00008a  1c40              ADDS     r0,r0,#1              ;1731
00008c  b910              CBNZ     r0,|L19.148|
00008e  2000              MOVS     r0,#0                 ;1731
000090  f8840044          STRB     r0,[r4,#0x44]         ;1731
                  |L19.148|
000094  f9940045          LDRSB    r0,[r4,#0x45]         ;1731
000098  1c40              ADDS     r0,r0,#1              ;1731
00009a  b910              CBNZ     r0,|L19.162|
00009c  2000              MOVS     r0,#0                 ;1731
00009e  f8840045          STRB     r0,[r4,#0x45]         ;1731
                  |L19.162|
0000a2  f7fffffe          BL       vPortExitCritical
0000a6  a904              ADD      r1,sp,#0x10           ;1734
0000a8  4668              MOV      r0,sp                 ;1734
0000aa  f7fffffe          BL       xTaskCheckForTimeOut
0000ae  b9f0              CBNZ     r0,|L19.238|
0000b0  4620              MOV      r0,r4                 ;1738
0000b2  f7fffffe          BL       prvIsQueueEmpty
0000b6  b1a0              CBZ      r0,|L19.226|
0000b8  f1040024          ADD      r0,r4,#0x24           ;1741
0000bc  9904              LDR      r1,[sp,#0x10]         ;1741
0000be  f7fffffe          BL       vTaskPlaceOnEventList
0000c2  4620              MOV      r0,r4                 ;1742
0000c4  f7fffffe          BL       prvUnlockQueue
0000c8  f7fffffe          BL       xTaskResumeAll
0000cc  2800              CMP      r0,#0                 ;1743
0000ce  d1a0              BNE      |L19.18|
0000d0  f04f5080          MOV      r0,#0x10000000        ;1745
0000d4  490c              LDR      r1,|L19.264|
0000d6  6008              STR      r0,[r1,#0]            ;1745
0000d8  f3bf8f4f          DSB                            ;1745
0000dc  f3bf8f6f          ISB                            ;1745
0000e0  e797              B        |L19.18|
                  |L19.226|
0000e2  4620              MOV      r0,r4                 ;1756
0000e4  f7fffffe          BL       prvUnlockQueue
0000e8  f7fffffe          BL       xTaskResumeAll
0000ec  e791              B        |L19.18|
                  |L19.238|
0000ee  4620              MOV      r0,r4                 ;1764
0000f0  f7fffffe          BL       prvUnlockQueue
0000f4  f7fffffe          BL       xTaskResumeAll
0000f8  4620              MOV      r0,r4                 ;1767
0000fa  f7fffffe          BL       prvIsQueueEmpty
0000fe  2800              CMP      r0,#0                 ;1767
000100  d087              BEQ      |L19.18|
000102  2000              MOVS     r0,#0                 ;1770
000104  e7a8              B        |L19.88|
;;;1779   /*-----------------------------------------------------------*/
                          ENDP

000106  0000              DCW      0x0000
                  |L19.264|
                          DCD      0xe000ed04

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1871   
;;;1872   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1873   {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
;;;1874   BaseType_t xReturn;
;;;1875   UBaseType_t uxSavedInterruptStatus;
;;;1876   int8_t *pcOriginalReadPosition;
;;;1877   Queue_t * const pxQueue = xQueue;
000008  462c              MOV      r4,r5
;;;1878   
;;;1879   	configASSERT( pxQueue );
;;;1880   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1881   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
;;;1882   
;;;1883   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1884   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1885   	above the maximum system call priority are kept permanently enabled, even
;;;1886   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1887   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1888   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1889   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1890   	assigned a priority above the configured maximum system call priority.
;;;1891   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1892   	that have been assigned a priority at or (logically) below the maximum
;;;1893   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1894   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1895   	More information (albeit Cortex-M specific) is provided on the following
;;;1896   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1897   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1898   
;;;1899   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4607              MOV      r7,r0
;;;1900   	{
;;;1901   		/* Cannot block in an ISR, so check there is data available. */
;;;1902   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000022  6ba0              LDR      r0,[r4,#0x38]
000024  b148              CBZ      r0,|L20.58|
;;;1903   		{
;;;1904   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1905   
;;;1906   			/* Remember the read position so it can be reset as nothing is
;;;1907   			actually being removed from the queue. */
;;;1908   			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
000026  f8d4800c          LDR      r8,[r4,#0xc]
;;;1909   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00002a  4649              MOV      r1,r9
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvCopyDataFromQueue
;;;1910   			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
000032  f8c4800c          STR      r8,[r4,#0xc]
;;;1911   
;;;1912   			xReturn = pdPASS;
000036  2601              MOVS     r6,#1
000038  e000              B        |L20.60|
                  |L20.58|
;;;1913   		}
;;;1914   		else
;;;1915   		{
;;;1916   			xReturn = pdFAIL;
00003a  2600              MOVS     r6,#0
                  |L20.60|
;;;1917   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1918   		}
;;;1919   	}
;;;1920   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00003c  bf00              NOP      
00003e  f3878811          MSR      BASEPRI,r7
000042  bf00              NOP      
;;;1921   
;;;1922   	return xReturn;
000044  4630              MOV      r0,r6
;;;1923   }
000046  e8bd87f0          POP      {r4-r10,pc}
;;;1924   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=2

                  xQueueReceive PROC
;;;1272   
;;;1273   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;1274   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;1275   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1276   TimeOut_t xTimeOut;
;;;1277   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1278   
;;;1279   	/* Check the pointer is not NULL. */
;;;1280   	configASSERT( ( pxQueue ) );
;;;1281   
;;;1282   	/* The buffer into which data is received can only be NULL if the data size
;;;1283   	is zero (so no data is copied into the buffer. */
;;;1284   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1285   
;;;1286   	/* Cannot block if the scheduler is suspended. */
;;;1287   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1288   	{
;;;1289   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1290   	}
;;;1291   	#endif
;;;1292   
;;;1293   
;;;1294   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1295   	allow return statements within the function itself.  This is done in the
;;;1296   	interest of execution time efficiency. */
;;;1297   	for( ;; )
000010  bf00              NOP      
                  |L21.18|
;;;1298   	{
;;;1299   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1300   		{
;;;1301   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000016  6ba6              LDR      r6,[r4,#0x38]
;;;1302   
;;;1303   			/* Is there data in the queue now?  To be running the calling task
;;;1304   			must be the highest priority task wanting to access the queue. */
;;;1305   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000018  b1f6              CBZ      r6,|L21.88|
;;;1306   			{
;;;1307   				/* Data available, remove one item. */
;;;1308   				prvCopyDataFromQueue( pxQueue, pvBuffer );
00001a  4639              MOV      r1,r7
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       prvCopyDataFromQueue
;;;1309   				traceQUEUE_RECEIVE( pxQueue );
;;;1310   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
000022  1e70              SUBS     r0,r6,#1
000024  63a0              STR      r0,[r4,#0x38]
;;;1311   
;;;1312   				/* There is now space in the queue, were any tasks waiting to
;;;1313   				post to the queue?  If so, unblock the highest priority waiting
;;;1314   				task. */
;;;1315   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000026  6920              LDR      r0,[r4,#0x10]
000028  b908              CBNZ     r0,|L21.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L21.48|
                  |L21.46|
00002e  2000              MOVS     r0,#0
                  |L21.48|
000030  b960              CBNZ     r0,|L21.76|
;;;1316   				{
;;;1317   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000032  f1040010          ADD      r0,r4,#0x10
000036  f7fffffe          BL       xTaskRemoveFromEventList
00003a  b138              CBZ      r0,|L21.76|
;;;1318   					{
;;;1319   						queueYIELD_IF_USING_PREEMPTION();
00003c  f04f5080          MOV      r0,#0x10000000
000040  492f              LDR      r1,|L21.256|
000042  6008              STR      r0,[r1,#0]
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
                  |L21.76|
;;;1320   					}
;;;1321   					else
;;;1322   					{
;;;1323   						mtCOVERAGE_TEST_MARKER();
;;;1324   					}
;;;1325   				}
;;;1326   				else
;;;1327   				{
;;;1328   					mtCOVERAGE_TEST_MARKER();
;;;1329   				}
;;;1330   
;;;1331   				taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;1332   				return pdPASS;
000050  2001              MOVS     r0,#1
                  |L21.82|
;;;1333   			}
;;;1334   			else
;;;1335   			{
;;;1336   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1337   				{
;;;1338   					/* The queue was empty and no block time is specified (or
;;;1339   					the block time has expired) so leave now. */
;;;1340   					taskEXIT_CRITICAL();
;;;1341   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1342   					return errQUEUE_EMPTY;
;;;1343   				}
;;;1344   				else if( xEntryTimeSet == pdFALSE )
;;;1345   				{
;;;1346   					/* The queue was empty and a block time was specified so
;;;1347   					configure the timeout structure. */
;;;1348   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1349   					xEntryTimeSet = pdTRUE;
;;;1350   				}
;;;1351   				else
;;;1352   				{
;;;1353   					/* Entry time was already set. */
;;;1354   					mtCOVERAGE_TEST_MARKER();
;;;1355   				}
;;;1356   			}
;;;1357   		}
;;;1358   		taskEXIT_CRITICAL();
;;;1359   
;;;1360   		/* Interrupts and other tasks can send to and receive from the queue
;;;1361   		now the critical section has been exited. */
;;;1362   
;;;1363   		vTaskSuspendAll();
;;;1364   		prvLockQueue( pxQueue );
;;;1365   
;;;1366   		/* Update the timeout state to see if it has expired yet. */
;;;1367   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1368   		{
;;;1369   			/* The timeout has not expired.  If the queue is still empty place
;;;1370   			the task on the list of tasks waiting to receive from the queue. */
;;;1371   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1372   			{
;;;1373   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1374   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1375   				prvUnlockQueue( pxQueue );
;;;1376   				if( xTaskResumeAll() == pdFALSE )
;;;1377   				{
;;;1378   					portYIELD_WITHIN_API();
;;;1379   				}
;;;1380   				else
;;;1381   				{
;;;1382   					mtCOVERAGE_TEST_MARKER();
;;;1383   				}
;;;1384   			}
;;;1385   			else
;;;1386   			{
;;;1387   				/* The queue contains data again.  Loop back to try and read the
;;;1388   				data. */
;;;1389   				prvUnlockQueue( pxQueue );
;;;1390   				( void ) xTaskResumeAll();
;;;1391   			}
;;;1392   		}
;;;1393   		else
;;;1394   		{
;;;1395   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1396   			back and attempt to read the data. */
;;;1397   			prvUnlockQueue( pxQueue );
;;;1398   			( void ) xTaskResumeAll();
;;;1399   
;;;1400   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1401   			{
;;;1402   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1403   				return errQUEUE_EMPTY;
;;;1404   			}
;;;1405   			else
;;;1406   			{
;;;1407   				mtCOVERAGE_TEST_MARKER();
;;;1408   			}
;;;1409   		}
;;;1410   	} /*lint -restore */
;;;1411   }
000052  b006              ADD      sp,sp,#0x18
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L21.88|
000058  9805              LDR      r0,[sp,#0x14]         ;1336
00005a  b918              CBNZ     r0,|L21.100|
00005c  f7fffffe          BL       vPortExitCritical
000060  2000              MOVS     r0,#0                 ;1342
000062  e7f6              B        |L21.82|
                  |L21.100|
000064  f1b80f00          CMP      r8,#0                 ;1344
000068  d104              BNE      |L21.116|
00006a  a801              ADD      r0,sp,#4              ;1348
00006c  f7fffffe          BL       vTaskInternalSetTimeOutState
000070  f04f0801          MOV      r8,#1                 ;1349
                  |L21.116|
000074  f7fffffe          BL       vPortExitCritical
000078  f7fffffe          BL       vTaskSuspendAll
00007c  f7fffffe          BL       vPortEnterCritical
000080  f9940044          LDRSB    r0,[r4,#0x44]         ;1364
000084  1c40              ADDS     r0,r0,#1              ;1364
000086  b910              CBNZ     r0,|L21.142|
000088  2000              MOVS     r0,#0                 ;1364
00008a  f8840044          STRB     r0,[r4,#0x44]         ;1364
                  |L21.142|
00008e  f9940045          LDRSB    r0,[r4,#0x45]         ;1364
000092  1c40              ADDS     r0,r0,#1              ;1364
000094  b910              CBNZ     r0,|L21.156|
000096  2000              MOVS     r0,#0                 ;1364
000098  f8840045          STRB     r0,[r4,#0x45]         ;1364
                  |L21.156|
00009c  f7fffffe          BL       vPortExitCritical
0000a0  a905              ADD      r1,sp,#0x14           ;1367
0000a2  a801              ADD      r0,sp,#4              ;1367
0000a4  f7fffffe          BL       xTaskCheckForTimeOut
0000a8  b9f0              CBNZ     r0,|L21.232|
0000aa  4620              MOV      r0,r4                 ;1371
0000ac  f7fffffe          BL       prvIsQueueEmpty
0000b0  b1a0              CBZ      r0,|L21.220|
0000b2  f1040024          ADD      r0,r4,#0x24           ;1374
0000b6  9905              LDR      r1,[sp,#0x14]         ;1374
0000b8  f7fffffe          BL       vTaskPlaceOnEventList
0000bc  4620              MOV      r0,r4                 ;1375
0000be  f7fffffe          BL       prvUnlockQueue
0000c2  f7fffffe          BL       xTaskResumeAll
0000c6  2800              CMP      r0,#0                 ;1376
0000c8  d1a3              BNE      |L21.18|
0000ca  f04f5080          MOV      r0,#0x10000000        ;1378
0000ce  490c              LDR      r1,|L21.256|
0000d0  6008              STR      r0,[r1,#0]            ;1378
0000d2  f3bf8f4f          DSB                            ;1378
0000d6  f3bf8f6f          ISB                            ;1378
0000da  e79a              B        |L21.18|
                  |L21.220|
0000dc  4620              MOV      r0,r4                 ;1389
0000de  f7fffffe          BL       prvUnlockQueue
0000e2  f7fffffe          BL       xTaskResumeAll
0000e6  e794              B        |L21.18|
                  |L21.232|
0000e8  4620              MOV      r0,r4                 ;1397
0000ea  f7fffffe          BL       prvUnlockQueue
0000ee  f7fffffe          BL       xTaskResumeAll
0000f2  4620              MOV      r0,r4                 ;1400
0000f4  f7fffffe          BL       prvIsQueueEmpty
0000f8  2800              CMP      r0,#0                 ;1400
0000fa  d08a              BEQ      |L21.18|
0000fc  2000              MOVS     r0,#0                 ;1403
0000fe  e7a8              B        |L21.82|
;;;1412   /*-----------------------------------------------------------*/
                          ENDP

                  |L21.256|
                          DCD      0xe000ed04

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1780   
;;;1781   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1782   {
000004  4605              MOV      r5,r0
000006  468a              MOV      r10,r1
000008  4616              MOV      r6,r2
;;;1783   BaseType_t xReturn;
;;;1784   UBaseType_t uxSavedInterruptStatus;
;;;1785   Queue_t * const pxQueue = xQueue;
00000a  462c              MOV      r4,r5
;;;1786   
;;;1787   	configASSERT( pxQueue );
;;;1788   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1789   
;;;1790   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1791   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1792   	above the maximum system call priority are kept permanently enabled, even
;;;1793   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1794   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1795   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1796   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1797   	assigned a priority above the configured maximum system call priority.
;;;1798   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1799   	that have been assigned a priority at or (logically) below the maximum
;;;1800   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1801   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1802   	More information (albeit Cortex-M specific) is provided on the following
;;;1803   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1804   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1805   
;;;1806   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000c  bf00              NOP      
00000e  21bf              MOVS     r1,#0xbf
000010  f3ef8011          MRS      r0,BASEPRI
000014  f3818811          MSR      BASEPRI,r1
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  4680              MOV      r8,r0
;;;1807   	{
;;;1808   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000024  f8d49038          LDR      r9,[r4,#0x38]
;;;1809   
;;;1810   		/* Cannot block in an ISR, so check there is data available. */
;;;1811   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000028  f1b90f00          CMP      r9,#0
00002c  d021              BEQ      |L22.114|
;;;1812   		{
;;;1813   			const int8_t cRxLock = pxQueue->cRxLock;
00002e  f994b044          LDRSB    r11,[r4,#0x44]
;;;1814   
;;;1815   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1816   
;;;1817   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000032  4651              MOV      r1,r10
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       prvCopyDataFromQueue
;;;1818   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00003a  f1a90001          SUB      r0,r9,#1
00003e  63a0              STR      r0,[r4,#0x38]
;;;1819   
;;;1820   			/* If the queue is locked the event list will not be modified.
;;;1821   			Instead update the lock count so the task that unlocks the queue
;;;1822   			will know that an ISR has removed data while the queue was
;;;1823   			locked. */
;;;1824   			if( cRxLock == queueUNLOCKED )
000040  f10b0001          ADD      r0,r11,#1
000044  b970              CBNZ     r0,|L22.100|
;;;1825   			{
;;;1826   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000046  6920              LDR      r0,[r4,#0x10]
000048  b908              CBNZ     r0,|L22.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L22.80|
                  |L22.78|
00004e  2000              MOVS     r0,#0
                  |L22.80|
000050  b968              CBNZ     r0,|L22.110|
;;;1827   				{
;;;1828   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000052  f1040010          ADD      r0,r4,#0x10
000056  f7fffffe          BL       xTaskRemoveFromEventList
00005a  b140              CBZ      r0,|L22.110|
;;;1829   					{
;;;1830   						/* The task waiting has a higher priority than us so
;;;1831   						force a context switch. */
;;;1832   						if( pxHigherPriorityTaskWoken != NULL )
00005c  b13e              CBZ      r6,|L22.110|
;;;1833   						{
;;;1834   							*pxHigherPriorityTaskWoken = pdTRUE;
00005e  2001              MOVS     r0,#1
000060  6030              STR      r0,[r6,#0]
000062  e004              B        |L22.110|
                  |L22.100|
;;;1835   						}
;;;1836   						else
;;;1837   						{
;;;1838   							mtCOVERAGE_TEST_MARKER();
;;;1839   						}
;;;1840   					}
;;;1841   					else
;;;1842   					{
;;;1843   						mtCOVERAGE_TEST_MARKER();
;;;1844   					}
;;;1845   				}
;;;1846   				else
;;;1847   				{
;;;1848   					mtCOVERAGE_TEST_MARKER();
;;;1849   				}
;;;1850   			}
;;;1851   			else
;;;1852   			{
;;;1853   				/* Increment the lock count so the task that unlocks the queue
;;;1854   				knows that data was removed while it was locked. */
;;;1855   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
000064  f10b0001          ADD      r0,r11,#1
000068  b240              SXTB     r0,r0
00006a  f8840044          STRB     r0,[r4,#0x44]
                  |L22.110|
;;;1856   			}
;;;1857   
;;;1858   			xReturn = pdPASS;
00006e  2701              MOVS     r7,#1
;;;1859   		}
000070  e000              B        |L22.116|
                  |L22.114|
;;;1860   		else
;;;1861   		{
;;;1862   			xReturn = pdFAIL;
000072  2700              MOVS     r7,#0
                  |L22.116|
;;;1863   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1864   		}
;;;1865   	}
;;;1866   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000074  bf00              NOP      
000076  f3888811          MSR      BASEPRI,r8
00007a  bf00              NOP      
;;;1867   
;;;1868   	return xReturn;
00007c  4638              MOV      r0,r7
;;;1869   }
00007e  e8bd9ff0          POP      {r4-r12,pc}
;;;1870   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=2

                  xQueueSemaphoreTake PROC
;;;1413   
;;;1414   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;1415   {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
;;;1416   BaseType_t xEntryTimeSet = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1417   TimeOut_t xTimeOut;
;;;1418   Queue_t * const pxQueue = xQueue;
000008  462c              MOV      r4,r5
;;;1419   
;;;1420   #if( configUSE_MUTEXES == 1 )
;;;1421   	BaseType_t xInheritanceOccurred = pdFALSE;
;;;1422   #endif
;;;1423   
;;;1424   	/* Check the queue pointer is not NULL. */
;;;1425   	configASSERT( ( pxQueue ) );
;;;1426   
;;;1427   	/* Check this really is a semaphore, in which case the item size will be
;;;1428   	0. */
;;;1429   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1430   
;;;1431   	/* Cannot block if the scheduler is suspended. */
;;;1432   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1433   	{
;;;1434   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1435   	}
;;;1436   	#endif
;;;1437   
;;;1438   
;;;1439   	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
;;;1440   	statements within the function itself.  This is done in the interest
;;;1441   	of execution time efficiency. */
;;;1442   	for( ;; )
00000a  bf00              NOP      
                  |L23.12|
;;;1443   	{
;;;1444   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;1445   		{
;;;1446   			/* Semaphores are queues with an item size of 0, and where the
;;;1447   			number of messages in the queue is the semaphore's count value. */
;;;1448   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
000010  6ba6              LDR      r6,[r4,#0x38]
;;;1449   
;;;1450   			/* Is there data in the queue now?  To be running the calling task
;;;1451   			must be the highest priority task wanting to access the queue. */
;;;1452   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
000012  b1ce              CBZ      r6,|L23.72|
;;;1453   			{
;;;1454   				traceQUEUE_RECEIVE( pxQueue );
;;;1455   
;;;1456   				/* Semaphores are queues with a data size of zero and where the
;;;1457   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1458   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
000014  1e70              SUBS     r0,r6,#1
000016  63a0              STR      r0,[r4,#0x38]
;;;1459   
;;;1460   				#if ( configUSE_MUTEXES == 1 )
;;;1461   				{
;;;1462   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1463   					{
;;;1464   						/* Record the information required to implement
;;;1465   						priority inheritance should it become necessary. */
;;;1466   						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
;;;1467   					}
;;;1468   					else
;;;1469   					{
;;;1470   						mtCOVERAGE_TEST_MARKER();
;;;1471   					}
;;;1472   				}
;;;1473   				#endif /* configUSE_MUTEXES */
;;;1474   
;;;1475   				/* Check to see if other tasks are blocked waiting to give the
;;;1476   				semaphore, and if so, unblock the highest priority such task. */
;;;1477   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000018  6920              LDR      r0,[r4,#0x10]
00001a  b908              CBNZ     r0,|L23.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L23.34|
                  |L23.32|
000020  2000              MOVS     r0,#0
                  |L23.34|
000022  b960              CBNZ     r0,|L23.62|
;;;1478   				{
;;;1479   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000024  f1040010          ADD      r0,r4,#0x10
000028  f7fffffe          BL       xTaskRemoveFromEventList
00002c  b138              CBZ      r0,|L23.62|
;;;1480   					{
;;;1481   						queueYIELD_IF_USING_PREEMPTION();
00002e  f04f5080          MOV      r0,#0x10000000
000032  492e              LDR      r1,|L23.236|
000034  6008              STR      r0,[r1,#0]
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
                  |L23.62|
;;;1482   					}
;;;1483   					else
;;;1484   					{
;;;1485   						mtCOVERAGE_TEST_MARKER();
;;;1486   					}
;;;1487   				}
;;;1488   				else
;;;1489   				{
;;;1490   					mtCOVERAGE_TEST_MARKER();
;;;1491   				}
;;;1492   
;;;1493   				taskEXIT_CRITICAL();
00003e  f7fffffe          BL       vPortExitCritical
;;;1494   				return pdPASS;
000042  2001              MOVS     r0,#1
                  |L23.68|
;;;1495   			}
;;;1496   			else
;;;1497   			{
;;;1498   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1499   				{
;;;1500   					/* For inheritance to have occurred there must have been an
;;;1501   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1502   					if it were 0 the function would have exited. */
;;;1503   					#if( configUSE_MUTEXES == 1 )
;;;1504   					{
;;;1505   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1506   					}
;;;1507   					#endif /* configUSE_MUTEXES */
;;;1508   
;;;1509   					/* The semaphore count was 0 and no block time is specified
;;;1510   					(or the block time has expired) so exit now. */
;;;1511   					taskEXIT_CRITICAL();
;;;1512   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1513   					return errQUEUE_EMPTY;
;;;1514   				}
;;;1515   				else if( xEntryTimeSet == pdFALSE )
;;;1516   				{
;;;1517   					/* The semaphore count was 0 and a block time was specified
;;;1518   					so configure the timeout structure ready to block. */
;;;1519   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1520   					xEntryTimeSet = pdTRUE;
;;;1521   				}
;;;1522   				else
;;;1523   				{
;;;1524   					/* Entry time was already set. */
;;;1525   					mtCOVERAGE_TEST_MARKER();
;;;1526   				}
;;;1527   			}
;;;1528   		}
;;;1529   		taskEXIT_CRITICAL();
;;;1530   
;;;1531   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1532   		now the critical section has been exited. */
;;;1533   
;;;1534   		vTaskSuspendAll();
;;;1535   		prvLockQueue( pxQueue );
;;;1536   
;;;1537   		/* Update the timeout state to see if it has expired yet. */
;;;1538   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1539   		{
;;;1540   			/* A block time is specified and not expired.  If the semaphore
;;;1541   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1542   			become available.  As semaphores are implemented with queues the
;;;1543   			queue being empty is equivalent to the semaphore count being 0. */
;;;1544   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1545   			{
;;;1546   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1547   
;;;1548   				#if ( configUSE_MUTEXES == 1 )
;;;1549   				{
;;;1550   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1551   					{
;;;1552   						taskENTER_CRITICAL();
;;;1553   						{
;;;1554   							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;1555   						}
;;;1556   						taskEXIT_CRITICAL();
;;;1557   					}
;;;1558   					else
;;;1559   					{
;;;1560   						mtCOVERAGE_TEST_MARKER();
;;;1561   					}
;;;1562   				}
;;;1563   				#endif
;;;1564   
;;;1565   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1566   				prvUnlockQueue( pxQueue );
;;;1567   				if( xTaskResumeAll() == pdFALSE )
;;;1568   				{
;;;1569   					portYIELD_WITHIN_API();
;;;1570   				}
;;;1571   				else
;;;1572   				{
;;;1573   					mtCOVERAGE_TEST_MARKER();
;;;1574   				}
;;;1575   			}
;;;1576   			else
;;;1577   			{
;;;1578   				/* There was no timeout and the semaphore count was not 0, so
;;;1579   				attempt to take the semaphore again. */
;;;1580   				prvUnlockQueue( pxQueue );
;;;1581   				( void ) xTaskResumeAll();
;;;1582   			}
;;;1583   		}
;;;1584   		else
;;;1585   		{
;;;1586   			/* Timed out. */
;;;1587   			prvUnlockQueue( pxQueue );
;;;1588   			( void ) xTaskResumeAll();
;;;1589   
;;;1590   			/* If the semaphore count is 0 exit now as the timeout has
;;;1591   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1592   			known to be available.  As semaphores are implemented by queues the
;;;1593   			queue being empty is equivalent to the semaphore count being 0. */
;;;1594   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1595   			{
;;;1596   				#if ( configUSE_MUTEXES == 1 )
;;;1597   				{
;;;1598   					/* xInheritanceOccurred could only have be set if
;;;1599   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1600   					test the mutex type again to check it is actually a mutex. */
;;;1601   					if( xInheritanceOccurred != pdFALSE )
;;;1602   					{
;;;1603   						taskENTER_CRITICAL();
;;;1604   						{
;;;1605   							UBaseType_t uxHighestWaitingPriority;
;;;1606   
;;;1607   							/* This task blocking on the mutex caused another
;;;1608   							task to inherit this task's priority.  Now this task
;;;1609   							has timed out the priority should be disinherited
;;;1610   							again, but only as low as the next highest priority
;;;1611   							task that is waiting for the same mutex. */
;;;1612   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1613   							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
;;;1614   						}
;;;1615   						taskEXIT_CRITICAL();
;;;1616   					}
;;;1617   				}
;;;1618   				#endif /* configUSE_MUTEXES */
;;;1619   
;;;1620   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1621   				return errQUEUE_EMPTY;
;;;1622   			}
;;;1623   			else
;;;1624   			{
;;;1625   				mtCOVERAGE_TEST_MARKER();
;;;1626   			}
;;;1627   		}
;;;1628   	} /*lint -restore */
;;;1629   }
000044  b005              ADD      sp,sp,#0x14
000046  bdf0              POP      {r4-r7,pc}
                  |L23.72|
000048  9804              LDR      r0,[sp,#0x10]         ;1498
00004a  b918              CBNZ     r0,|L23.84|
00004c  f7fffffe          BL       vPortExitCritical
000050  2000              MOVS     r0,#0                 ;1513
000052  e7f7              B        |L23.68|
                  |L23.84|
000054  b91f              CBNZ     r7,|L23.94|
000056  a801              ADD      r0,sp,#4              ;1519
000058  f7fffffe          BL       vTaskInternalSetTimeOutState
00005c  2701              MOVS     r7,#1                 ;1520
                  |L23.94|
00005e  f7fffffe          BL       vPortExitCritical
000062  f7fffffe          BL       vTaskSuspendAll
000066  f7fffffe          BL       vPortEnterCritical
00006a  f9940044          LDRSB    r0,[r4,#0x44]         ;1535
00006e  1c40              ADDS     r0,r0,#1              ;1535
000070  b910              CBNZ     r0,|L23.120|
000072  2000              MOVS     r0,#0                 ;1535
000074  f8840044          STRB     r0,[r4,#0x44]         ;1535
                  |L23.120|
000078  f9940045          LDRSB    r0,[r4,#0x45]         ;1535
00007c  1c40              ADDS     r0,r0,#1              ;1535
00007e  b910              CBNZ     r0,|L23.134|
000080  2000              MOVS     r0,#0                 ;1535
000082  f8840045          STRB     r0,[r4,#0x45]         ;1535
                  |L23.134|
000086  f7fffffe          BL       vPortExitCritical
00008a  a904              ADD      r1,sp,#0x10           ;1538
00008c  a801              ADD      r0,sp,#4              ;1538
00008e  f7fffffe          BL       xTaskCheckForTimeOut
000092  b9f0              CBNZ     r0,|L23.210|
000094  4620              MOV      r0,r4                 ;1544
000096  f7fffffe          BL       prvIsQueueEmpty
00009a  b1a0              CBZ      r0,|L23.198|
00009c  f1040024          ADD      r0,r4,#0x24           ;1565
0000a0  9904              LDR      r1,[sp,#0x10]         ;1565
0000a2  f7fffffe          BL       vTaskPlaceOnEventList
0000a6  4620              MOV      r0,r4                 ;1566
0000a8  f7fffffe          BL       prvUnlockQueue
0000ac  f7fffffe          BL       xTaskResumeAll
0000b0  2800              CMP      r0,#0                 ;1567
0000b2  d1ab              BNE      |L23.12|
0000b4  f04f5080          MOV      r0,#0x10000000        ;1569
0000b8  490c              LDR      r1,|L23.236|
0000ba  6008              STR      r0,[r1,#0]            ;1569
0000bc  f3bf8f4f          DSB                            ;1569
0000c0  f3bf8f6f          ISB                            ;1569
0000c4  e7a2              B        |L23.12|
                  |L23.198|
0000c6  4620              MOV      r0,r4                 ;1580
0000c8  f7fffffe          BL       prvUnlockQueue
0000cc  f7fffffe          BL       xTaskResumeAll
0000d0  e79c              B        |L23.12|
                  |L23.210|
0000d2  4620              MOV      r0,r4                 ;1587
0000d4  f7fffffe          BL       prvUnlockQueue
0000d8  f7fffffe          BL       xTaskResumeAll
0000dc  4620              MOV      r0,r4                 ;1594
0000de  f7fffffe          BL       prvIsQueueEmpty
0000e2  2800              CMP      r0,#0                 ;1594
0000e4  d092              BEQ      |L23.12|
0000e6  2000              MOVS     r0,#0                 ;1621
0000e8  e7ac              B        |L23.68|
;;;1630   /*-----------------------------------------------------------*/
                          ENDP

0000ea  0000              DCW      0x0000
                  |L23.236|
                          DCD      0xe000ed04
