; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\diskio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\FreeRTOS\include -I.\FreeRTOS\portable\RVDS\ARM_CM3 -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\diskio.crf fatfs\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;26     
;;;27     DSTATUS disk_initialize (
000000  b510              PUSH     {r4,lr}
;;;28     	BYTE drv				/* Physical drive nmuber (0..) */
;;;29     )
;;;30     {
000002  4604              MOV      r4,r0
;;;31     	if (SD_Init() == SD_OK)
000004  f7fffffe          BL       SD_Init
000008  282a              CMP      r0,#0x2a
00000a  d104              BNE      |L1.22|
;;;32     	{
;;;33     			printf("Init success\n");
00000c  a003              ADR      r0,|L1.28|
00000e  f7fffffe          BL       __2printf
;;;34     	  	return STA_OK;           //初始化成功
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;35     	}
;;;36     	
;;;37     	return STA_NOINIT;
;;;38     }
000014  bd10              POP      {r4,pc}
                  |L1.22|
000016  2001              MOVS     r0,#1                 ;37
000018  e7fc              B        |L1.20|
;;;39     
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
00001c  496e6974          DCB      "Init success\n",0
000020  20737563
000024  63657373
000028  0a00    
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;148    
;;;149    DRESULT disk_ioctl (
000000  4603              MOV      r3,r0
;;;150    	BYTE drv,		/* Physical drive nmuber (0..) */
;;;151    	BYTE ctrl,		/* Control code */
;;;152    	void *buff		/* Buffer to send/receive control data */
;;;153    )
;;;154    {
;;;155    	return RES_OK;
000002  2000              MOVS     r0,#0
;;;156    }
000004  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;63     
;;;64     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;65     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;66     	BYTE *buff,		/* Data buffer to store read data */
;;;67     	DWORD sector,	/* Sector address (LBA) */
;;;68     	BYTE count		/* Number of sectors to read (1..255) */
;;;69     )
;;;70     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;71     	SD_Error res = SD_OK;
00000c  f04f082a          MOV      r8,#0x2a
;;;72     
;;;73     	if (drv || !count)
000010  b906              CBNZ     r6,|L3.20|
000012  b915              CBNZ     r5,|L3.26|
                  |L3.20|
;;;74         {    
;;;75             return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
000014  2004              MOVS     r0,#4
                  |L3.22|
;;;76         }
;;;77     		
;;;78     	if(count==1)
;;;79         {
;;;80     		res = SD_ReadBlock(buff,sector << 9  ,SECTOR_SIZE);        
;;;81     	}
;;;82     	else
;;;83         {
;;;84     		res =  SD_ReadMultiBlocks(buff,sector << 9 ,SECTOR_SIZE,count);        
;;;85     	} 
;;;86     	
;;;87     	if(res == SD_OK)
;;;88         {
;;;89             return RES_OK;
;;;90         }
;;;91         else
;;;92         {
;;;93             return RES_ERROR;
;;;94         } 
;;;95     
;;;96     	//return RES_PARERR;
;;;97     }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L3.26|
00001a  2d01              CMP      r5,#1                 ;78
00001c  d106              BNE      |L3.44|
00001e  0261              LSLS     r1,r4,#9              ;80
000020  026a              LSLS     r2,r5,#9              ;80
000022  4638              MOV      r0,r7                 ;80
000024  f7fffffe          BL       SD_ReadBlock
000028  4680              MOV      r8,r0                 ;80
00002a  e007              B        |L3.60|
                  |L3.44|
00002c  0261              LSLS     r1,r4,#9              ;84
00002e  462b              MOV      r3,r5                 ;84
000030  f44f7200          MOV      r2,#0x200             ;84
000034  4638              MOV      r0,r7                 ;84
000036  f7fffffe          BL       SD_ReadMultiBlocks
00003a  4680              MOV      r8,r0                 ;84
                  |L3.60|
00003c  f1b80f2a          CMP      r8,#0x2a              ;87
000040  d101              BNE      |L3.70|
000042  2000              MOVS     r0,#0                 ;89
000044  e7e7              B        |L3.22|
                  |L3.70|
000046  2001              MOVS     r0,#1                 ;93
000048  e7e5              B        |L3.22|
;;;98     
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=2

                  disk_status PROC
;;;44     
;;;45     DSTATUS disk_status (
000000  b510              PUSH     {r4,lr}
;;;46     	BYTE drv		/* Physical drive nmuber (0..) */
;;;47     )
;;;48     {
000002  4604              MOV      r4,r0
;;;49     	if(drv)
000004  b124              CBZ      r4,|L4.16|
;;;50     	{
;;;51     		printf("Only support drv 0\n");
000006  a003              ADR      r0,|L4.20|
000008  f7fffffe          BL       __2printf
;;;52     		return STA_NOINIT;
00000c  2001              MOVS     r0,#1
                  |L4.14|
;;;53     	}	
;;;54     
;;;55     	return 0;
;;;56     //	return STA_NOINIT;
;;;57     }
00000e  bd10              POP      {r4,pc}
                  |L4.16|
000010  2000              MOVS     r0,#0                 ;55
000012  e7fc              B        |L4.14|
;;;58     
                          ENDP

                  |L4.20|
000014  4f6e6c79          DCB      "Only support drv 0\n",0
000018  20737570
00001c  706f7274
000020  20647276
000024  20300a00

                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;104    #if _READONLY == 0
;;;105    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;106    	BYTE drv,			/* Physical drive nmuber (0..) */
;;;107    	const BYTE *buff,	/* Data to be written */
;;;108    	DWORD sector,		/* Sector address (LBA) */
;;;109    	BYTE count			/* Number of sectors to write (1..255) */
;;;110    )
;;;111    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;112    	SD_Error res = SD_OK;
00000c  f04f082a          MOV      r8,#0x2a
;;;113    
;;;114        if (drv || !count)
000010  b906              CBNZ     r6,|L5.20|
000012  b915              CBNZ     r5,|L5.26|
                  |L5.20|
;;;115        {    
;;;116            return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
000014  2004              MOVS     r0,#4
                  |L5.22|
;;;117        }
;;;118    
;;;119    //		printf("begin write\n");
;;;120    
;;;121    		if(count==1)
;;;122    		{          
;;;123    				res = SD_WriteBlock((u8 *)buff,sector << 9 ,SECTOR_SIZE);
;;;124    		}
;;;125    		else
;;;126    		{          
;;;127    				res = SD_WriteMultiBlocks((u8 *)buff,sector <<9 ,SECTOR_SIZE,count);
;;;128    		}
;;;129            
;;;130      	if(res == SD_OK)
;;;131        {
;;;132    //				printf("write_ok\n");
;;;133            return RES_OK;
;;;134        }
;;;135        else
;;;136        {
;;;137            return RES_ERROR;
;;;138        }
;;;139    
;;;140    	//return RES_PARERR;
;;;141    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  2d01              CMP      r5,#1                 ;121
00001c  d106              BNE      |L5.44|
00001e  0261              LSLS     r1,r4,#9              ;123
000020  026a              LSLS     r2,r5,#9              ;123
000022  4638              MOV      r0,r7                 ;123
000024  f7fffffe          BL       SD_WriteBlock
000028  4680              MOV      r8,r0                 ;123
00002a  e007              B        |L5.60|
                  |L5.44|
00002c  0261              LSLS     r1,r4,#9              ;127
00002e  462b              MOV      r3,r5                 ;127
000030  f44f7200          MOV      r2,#0x200             ;127
000034  4638              MOV      r0,r7                 ;127
000036  f7fffffe          BL       SD_WriteMultiBlocks
00003a  4680              MOV      r8,r0                 ;127
                  |L5.60|
00003c  f1b80f2a          CMP      r8,#0x2a              ;130
000040  d101              BNE      |L5.70|
000042  2000              MOVS     r0,#0                 ;133
000044  e7e7              B        |L5.22|
                  |L5.70|
000046  2001              MOVS     r0,#1                 ;137
000048  e7e5              B        |L5.22|
;;;142    #endif /* _READONLY */
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;173    
;;;174    DWORD get_fattime(void)
000000  2000              MOVS     r0,#0
;;;175    {
;;;176    	return 0;
;;;177    }
000002  4770              BX       lr
                          ENDP

