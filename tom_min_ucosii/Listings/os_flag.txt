; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\os_flag.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\UCOSII\CORE -I.\UCOSII\PORTS -I.\UCOSII\CONFIG -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\os_flag.crf UCOSII\CORE\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagAccept||, CODE, READONLY, ALIGN=1

                  OSFlagAccept PROC
;;;93     #if OS_FLAG_ACCEPT_EN > 0u
;;;94     OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;95                             OS_FLAGS      flags,
;;;96                             INT8U         wait_type,
;;;97                             INT8U        *perr)
;;;98     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;99         OS_FLAGS      flags_rdy;
;;;100        INT8U         result;
;;;101        BOOLEAN       consume;
;;;102    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;103        OS_CPU_SR     cpu_sr = 0u;
00000c  f04f0b00          MOV      r11,#0
;;;104    #endif
;;;105    
;;;106    
;;;107    
;;;108    #ifdef OS_SAFETY_CRITICAL
;;;109        if (perr == (INT8U *)0) {
;;;110            OS_SAFETY_CRITICAL_EXCEPTION();
;;;111            return ((OS_FLAGS)0);
;;;112        }
;;;113    #endif
;;;114    
;;;115    #if OS_ARG_CHK_EN > 0u
;;;116        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;117            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;118            return ((OS_FLAGS)0);
;;;119        }
;;;120    #endif
;;;121        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L1.32|
;;;122            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;123            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L1.28|
;;;124        }
;;;125        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;126        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;127            wait_type &= ~OS_FLAG_CONSUME;
;;;128            consume    = OS_TRUE;
;;;129        } else {
;;;130            consume    = OS_FALSE;
;;;131        }
;;;132    /*$PAGE*/
;;;133        *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
;;;134        OS_ENTER_CRITICAL();
;;;135        switch (wait_type) {
;;;136            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;137                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;138                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;139                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;140                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
;;;141                     }
;;;142                 } else {
;;;143                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;144                 }
;;;145                 OS_EXIT_CRITICAL();
;;;146                 break;
;;;147    
;;;148            case OS_FLAG_WAIT_SET_ANY:
;;;149                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
;;;150                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;151                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;152                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
;;;153                     }
;;;154                 } else {
;;;155                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;156                 }
;;;157                 OS_EXIT_CRITICAL();
;;;158                 break;
;;;159    
;;;160    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;161            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;162                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;163                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;164                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;165                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;166                     }
;;;167                 } else {
;;;168                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;169                 }
;;;170                 OS_EXIT_CRITICAL();
;;;171                 break;
;;;172    
;;;173            case OS_FLAG_WAIT_CLR_ANY:
;;;174                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;175                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;176                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;177                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;178                     }
;;;179                 } else {
;;;180                     *perr = OS_ERR_FLAG_NOT_RDY;
;;;181                 }
;;;182                 OS_EXIT_CRITICAL();
;;;183                 break;
;;;184    #endif
;;;185    
;;;186            default:
;;;187                 OS_EXIT_CRITICAL();
;;;188                 flags_rdy = (OS_FLAGS)0;
;;;189                 *perr     = OS_ERR_FLAG_WAIT_TYPE;
;;;190                 break;
;;;191        }
;;;192        return (flags_rdy);
;;;193    }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.32|
000020  f0090a80          AND      r10,r9,#0x80          ;125
000024  f1ba0f00          CMP      r10,#0                ;126
000028  d004              BEQ      |L1.52|
00002a  f0290980          BIC      r9,r9,#0x80           ;127
00002e  f04f0801          MOV      r8,#1                 ;128
000032  e001              B        |L1.56|
                  |L1.52|
000034  f04f0800          MOV      r8,#0                 ;130
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;133
00003a  7030              STRB     r0,[r6,#0]            ;133
00003c  f7fffffe          BL       OS_CPU_SR_Save
000040  4683              MOV      r11,r0                ;134
000042  f1b90f00          CMP      r9,#0                 ;135
000046  d02c              BEQ      |L1.162|
000048  f1b90f01          CMP      r9,#1                 ;135
00004c  d03b              BEQ      |L1.198|
00004e  f1b90f02          CMP      r9,#2                 ;135
000052  d003              BEQ      |L1.92|
000054  f1b90f03          CMP      r9,#3                 ;135
000058  d146              BNE      |L1.232|
00005a  e011              B        |L1.128|
                  |L1.92|
00005c  8920              LDRH     r0,[r4,#8]            ;137
00005e  ea000507          AND      r5,r0,r7              ;137
000062  42bd              CMP      r5,r7                 ;138
000064  d106              BNE      |L1.116|
000066  f1b80f01          CMP      r8,#1                 ;139
00006a  d105              BNE      |L1.120|
00006c  8920              LDRH     r0,[r4,#8]            ;140
00006e  43a8              BICS     r0,r0,r5              ;140
000070  8120              STRH     r0,[r4,#8]            ;140
000072  e001              B        |L1.120|
                  |L1.116|
000074  2070              MOVS     r0,#0x70              ;143
000076  7030              STRB     r0,[r6,#0]            ;143
                  |L1.120|
000078  4658              MOV      r0,r11                ;145
00007a  f7fffffe          BL       OS_CPU_SR_Restore
00007e  e03a              B        |L1.246|
                  |L1.128|
000080  8920              LDRH     r0,[r4,#8]            ;149
000082  ea000507          AND      r5,r0,r7              ;149
000086  b135              CBZ      r5,|L1.150|
000088  f1b80f01          CMP      r8,#1                 ;151
00008c  d105              BNE      |L1.154|
00008e  8920              LDRH     r0,[r4,#8]            ;152
000090  43a8              BICS     r0,r0,r5              ;152
000092  8120              STRH     r0,[r4,#8]            ;152
000094  e001              B        |L1.154|
                  |L1.150|
000096  2070              MOVS     r0,#0x70              ;155
000098  7030              STRB     r0,[r6,#0]            ;155
                  |L1.154|
00009a  4658              MOV      r0,r11                ;157
00009c  f7fffffe          BL       OS_CPU_SR_Restore
0000a0  e029              B        |L1.246|
                  |L1.162|
0000a2  8920              LDRH     r0,[r4,#8]            ;162
0000a4  ea270500          BIC      r5,r7,r0              ;162
0000a8  42bd              CMP      r5,r7                 ;163
0000aa  d106              BNE      |L1.186|
0000ac  f1b80f01          CMP      r8,#1                 ;164
0000b0  d105              BNE      |L1.190|
0000b2  8920              LDRH     r0,[r4,#8]            ;165
0000b4  4328              ORRS     r0,r0,r5              ;165
0000b6  8120              STRH     r0,[r4,#8]            ;165
0000b8  e001              B        |L1.190|
                  |L1.186|
0000ba  2070              MOVS     r0,#0x70              ;168
0000bc  7030              STRB     r0,[r6,#0]            ;168
                  |L1.190|
0000be  4658              MOV      r0,r11                ;170
0000c0  f7fffffe          BL       OS_CPU_SR_Restore
0000c4  e017              B        |L1.246|
                  |L1.198|
0000c6  8920              LDRH     r0,[r4,#8]            ;174
0000c8  ea270500          BIC      r5,r7,r0              ;174
0000cc  b135              CBZ      r5,|L1.220|
0000ce  f1b80f01          CMP      r8,#1                 ;176
0000d2  d105              BNE      |L1.224|
0000d4  8920              LDRH     r0,[r4,#8]            ;177
0000d6  4328              ORRS     r0,r0,r5              ;177
0000d8  8120              STRH     r0,[r4,#8]            ;177
0000da  e001              B        |L1.224|
                  |L1.220|
0000dc  2070              MOVS     r0,#0x70              ;180
0000de  7030              STRB     r0,[r6,#0]            ;180
                  |L1.224|
0000e0  4658              MOV      r0,r11                ;182
0000e2  f7fffffe          BL       OS_CPU_SR_Restore
0000e6  e006              B        |L1.246|
                  |L1.232|
0000e8  4658              MOV      r0,r11                ;187
0000ea  f7fffffe          BL       OS_CPU_SR_Restore
0000ee  2500              MOVS     r5,#0                 ;188
0000f0  206f              MOVS     r0,#0x6f              ;189
0000f2  7030              STRB     r0,[r6,#0]            ;189
0000f4  bf00              NOP                            ;190
                  |L1.246|
0000f6  bf00              NOP                            ;146
0000f8  4628              MOV      r0,r5                 ;192
0000fa  e78f              B        |L1.28|
;;;194    #endif
                          ENDP


                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;216    
;;;217    OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;218                                INT8U    *perr)
;;;219    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;220        OS_FLAG_GRP *pgrp;
;;;221    #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
;;;222        OS_CPU_SR    cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;223    #endif
;;;224    
;;;225    
;;;226    
;;;227    #ifdef OS_SAFETY_CRITICAL
;;;228        if (perr == (INT8U *)0) {
;;;229            OS_SAFETY_CRITICAL_EXCEPTION();
;;;230            return ((OS_FLAG_GRP *)0);
;;;231        }
;;;232    #endif
;;;233    
;;;234    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;235        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;236            OS_SAFETY_CRITICAL_EXCEPTION();
;;;237            return ((OS_FLAG_GRP *)0);
;;;238        }
;;;239    #endif
;;;240    
;;;241        if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00000a  4813              LDR      r0,|L2.88|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000e  b120              CBZ      r0,|L2.26|
;;;242            *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
000010  2010              MOVS     r0,#0x10
000012  7028              STRB     r0,[r5,#0]
;;;243            return ((OS_FLAG_GRP *)0);
000014  2000              MOVS     r0,#0
                  |L2.22|
;;;244        }
;;;245        OS_ENTER_CRITICAL();
;;;246        pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
;;;247        if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
;;;248                                                        /* Adjust free list                                */
;;;249            OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
;;;250            pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
;;;251            pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
;;;252            pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
;;;253    #if OS_FLAG_NAME_EN > 0u
;;;254            pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;255    #endif
;;;256            OS_EXIT_CRITICAL();
;;;257            *perr                = OS_ERR_NONE;
;;;258        } else {
;;;259            OS_EXIT_CRITICAL();
;;;260            *perr                = OS_ERR_FLAG_GRP_DEPLETED;
;;;261        }
;;;262        return (pgrp);                                  /* Return pointer to event flag group              */
;;;263    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L2.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;245
000020  480e              LDR      r0,|L2.92|
000022  6804              LDR      r4,[r0,#0]            ;246  ; OSFlagFreeList
000024  b184              CBZ      r4,|L2.72|
000026  6800              LDR      r0,[r0,#0]            ;249  ; OSFlagFreeList
000028  6840              LDR      r0,[r0,#4]            ;249
00002a  490c              LDR      r1,|L2.92|
00002c  6008              STR      r0,[r1,#0]            ;249  ; OSFlagFreeList
00002e  2005              MOVS     r0,#5                 ;250
000030  7020              STRB     r0,[r4,#0]            ;250
000032  8126              STRH     r6,[r4,#8]            ;251
000034  2000              MOVS     r0,#0                 ;252
000036  6060              STR      r0,[r4,#4]            ;252
000038  a009              ADR      r0,|L2.96|
00003a  60e0              STR      r0,[r4,#0xc]          ;254
00003c  4638              MOV      r0,r7                 ;256
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2000              MOVS     r0,#0                 ;257
000044  7028              STRB     r0,[r5,#0]            ;257
000046  e004              B        |L2.82|
                  |L2.72|
000048  4638              MOV      r0,r7                 ;259
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2072              MOVS     r0,#0x72              ;260
000050  7028              STRB     r0,[r5,#0]            ;260
                  |L2.82|
000052  4620              MOV      r0,r4                 ;262
000054  e7df              B        |L2.22|
;;;264    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      OSIntNesting
                  |L2.92|
                          DCD      OSFlagFreeList
                  |L2.96|
000060  3f00              DCB      "?",0
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;304    #if OS_FLAG_DEL_EN > 0u
;;;305    OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;306                             INT8U         opt,
;;;307                             INT8U        *perr)
;;;308    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;309        BOOLEAN       tasks_waiting;
;;;310        OS_FLAG_NODE *pnode;
;;;311        OS_FLAG_GRP  *pgrp_return;
;;;312    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;313        OS_CPU_SR     cpu_sr = 0u;
00000a  f04f0a00          MOV      r10,#0
;;;314    #endif
;;;315    
;;;316    
;;;317    
;;;318    #ifdef OS_SAFETY_CRITICAL
;;;319        if (perr == (INT8U *)0) {
;;;320            OS_SAFETY_CRITICAL_EXCEPTION();
;;;321            return ((OS_FLAG_GRP *)0);
;;;322        }
;;;323    #endif
;;;324    
;;;325    #if OS_ARG_CHK_EN > 0u
;;;326        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;327            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;328            return (pgrp);
;;;329        }
;;;330    #endif
;;;331        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00000e  4832              LDR      r0,|L3.216|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b120              CBZ      r0,|L3.30|
;;;332            *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000014  200f              MOVS     r0,#0xf
000016  7028              STRB     r0,[r5,#0]
;;;333            return (pgrp);
000018  4620              MOV      r0,r4
                  |L3.26|
;;;334        }
;;;335        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
;;;336            *perr = OS_ERR_EVENT_TYPE;
;;;337            return (pgrp);
;;;338        }
;;;339        OS_ENTER_CRITICAL();
;;;340        if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
;;;341            tasks_waiting = OS_TRUE;                           /* Yes                                      */
;;;342        } else {
;;;343            tasks_waiting = OS_FALSE;                          /* No                                       */
;;;344        }
;;;345        switch (opt) {
;;;346            case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
;;;347                 if (tasks_waiting == OS_FALSE) {
;;;348    #if OS_FLAG_NAME_EN > 0u
;;;349                     pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;350    #endif
;;;351                     pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;352                     pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
;;;353                     pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;354                     OSFlagFreeList       = pgrp;
;;;355                     OS_EXIT_CRITICAL();
;;;356                     *perr                = OS_ERR_NONE;
;;;357                     pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
;;;358                 } else {
;;;359                     OS_EXIT_CRITICAL();
;;;360                     *perr                = OS_ERR_TASK_WAITING;
;;;361                     pgrp_return          = pgrp;
;;;362                 }
;;;363                 break;
;;;364    
;;;365            case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
;;;366                 pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;367                 while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
;;;368                     (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
;;;369                     pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
;;;370                 }
;;;371    #if OS_FLAG_NAME_EN > 0u
;;;372                 pgrp->OSFlagName     = (INT8U *)(void *)"?";
;;;373    #endif
;;;374                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;375                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
;;;376                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
;;;377                 OSFlagFreeList       = pgrp;
;;;378                 OS_EXIT_CRITICAL();
;;;379                 if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
;;;380                     OS_Sched();                               /* Find highest priority task ready to run  */
;;;381                 }
;;;382                 *perr = OS_ERR_NONE;
;;;383                 pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
;;;384                 break;
;;;385    
;;;386            default:
;;;387                 OS_EXIT_CRITICAL();
;;;388                 *perr                = OS_ERR_INVALID_OPT;
;;;389                 pgrp_return          = pgrp;
;;;390                 break;
;;;391        }
;;;392        return (pgrp_return);
;;;393    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L3.30|
00001e  7820              LDRB     r0,[r4,#0]            ;335
000020  2805              CMP      r0,#5                 ;335
000022  d003              BEQ      |L3.44|
000024  2001              MOVS     r0,#1                 ;336
000026  7028              STRB     r0,[r5,#0]            ;336
000028  4620              MOV      r0,r4                 ;337
00002a  e7f6              B        |L3.26|
                  |L3.44|
00002c  f7fffffe          BL       OS_CPU_SR_Save
000030  4682              MOV      r10,r0                ;339
000032  6860              LDR      r0,[r4,#4]            ;340
000034  b108              CBZ      r0,|L3.58|
000036  2701              MOVS     r7,#1                 ;341
000038  e000              B        |L3.60|
                  |L3.58|
00003a  2700              MOVS     r7,#0                 ;343
                  |L3.60|
00003c  f1b90f00          CMP      r9,#0                 ;345
000040  d003              BEQ      |L3.74|
000042  f1b90f01          CMP      r9,#1                 ;345
000046  d13d              BNE      |L3.196|
000048  e019              B        |L3.126|
                  |L3.74|
00004a  b98f              CBNZ     r7,|L3.112|
00004c  a023              ADR      r0,|L3.220|
00004e  60e0              STR      r0,[r4,#0xc]          ;349
000050  2000              MOVS     r0,#0                 ;351
000052  7020              STRB     r0,[r4,#0]            ;351
000054  4822              LDR      r0,|L3.224|
000056  6800              LDR      r0,[r0,#0]            ;352  ; OSFlagFreeList
000058  6060              STR      r0,[r4,#4]            ;352
00005a  2000              MOVS     r0,#0                 ;353
00005c  8120              STRH     r0,[r4,#8]            ;353
00005e  4820              LDR      r0,|L3.224|
000060  6004              STR      r4,[r0,#0]            ;354  ; OSFlagFreeList
000062  4650              MOV      r0,r10                ;355
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  2000              MOVS     r0,#0                 ;356
00006a  7028              STRB     r0,[r5,#0]            ;356
00006c  2600              MOVS     r6,#0                 ;357
00006e  e005              B        |L3.124|
                  |L3.112|
000070  4650              MOV      r0,r10                ;359
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  2049              MOVS     r0,#0x49              ;360
000078  7028              STRB     r0,[r5,#0]            ;360
00007a  4626              MOV      r6,r4                 ;361
                  |L3.124|
00007c  e029              B        |L3.210|
                  |L3.126|
00007e  f8d48004          LDR      r8,[r4,#4]            ;366
000082  e006              B        |L3.146|
                  |L3.132|
000084  2202              MOVS     r2,#2                 ;368
000086  2100              MOVS     r1,#0                 ;368
000088  4640              MOV      r0,r8                 ;368
00008a  f7fffffe          BL       OS_FlagTaskRdy
00008e  f8d88000          LDR      r8,[r8,#0]            ;369
                  |L3.146|
000092  f1b80f00          CMP      r8,#0                 ;367
000096  d1f5              BNE      |L3.132|
000098  a010              ADR      r0,|L3.220|
00009a  60e0              STR      r0,[r4,#0xc]          ;372
00009c  2000              MOVS     r0,#0                 ;374
00009e  7020              STRB     r0,[r4,#0]            ;374
0000a0  480f              LDR      r0,|L3.224|
0000a2  6800              LDR      r0,[r0,#0]            ;375  ; OSFlagFreeList
0000a4  6060              STR      r0,[r4,#4]            ;375
0000a6  2000              MOVS     r0,#0                 ;376
0000a8  8120              STRH     r0,[r4,#8]            ;376
0000aa  480d              LDR      r0,|L3.224|
0000ac  6004              STR      r4,[r0,#0]            ;377  ; OSFlagFreeList
0000ae  4650              MOV      r0,r10                ;378
0000b0  f7fffffe          BL       OS_CPU_SR_Restore
0000b4  2f01              CMP      r7,#1                 ;379
0000b6  d101              BNE      |L3.188|
0000b8  f7fffffe          BL       OS_Sched
                  |L3.188|
0000bc  2000              MOVS     r0,#0                 ;382
0000be  7028              STRB     r0,[r5,#0]            ;382
0000c0  2600              MOVS     r6,#0                 ;383
0000c2  e006              B        |L3.210|
                  |L3.196|
0000c4  4650              MOV      r0,r10                ;387
0000c6  f7fffffe          BL       OS_CPU_SR_Restore
0000ca  2007              MOVS     r0,#7                 ;388
0000cc  7028              STRB     r0,[r5,#0]            ;388
0000ce  4626              MOV      r6,r4                 ;389
0000d0  bf00              NOP                            ;390
                  |L3.210|
0000d2  bf00              NOP                            ;363
0000d4  4630              MOV      r0,r6                 ;392
0000d6  e7a0              B        |L3.26|
;;;394    #endif
                          ENDP

                  |L3.216|
                          DCD      OSIntNesting
                  |L3.220|
0000dc  3f00              DCB      "?",0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L3.224|
                          DCD      OSFlagFreeList

                          AREA ||i.OSFlagNameGet||, CODE, READONLY, ALIGN=2

                  OSFlagNameGet PROC
;;;419    #if OS_FLAG_NAME_EN > 0u
;;;420    INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;421                          INT8U        **pname,
;;;422                          INT8U         *perr)
;;;423    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;424        INT8U      len;
;;;425    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;426        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;427    #endif
;;;428    
;;;429    
;;;430    
;;;431    #ifdef OS_SAFETY_CRITICAL
;;;432        if (perr == (INT8U *)0) {
;;;433            OS_SAFETY_CRITICAL_EXCEPTION();
;;;434            return (0u);
;;;435        }
;;;436    #endif
;;;437    
;;;438    #if OS_ARG_CHK_EN > 0u
;;;439        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;440            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;441            return (0u);
;;;442        }
;;;443        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;444            *perr = OS_ERR_PNAME_NULL;
;;;445            return (0u);
;;;446        }
;;;447    #endif
;;;448        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4810              LDR      r0,|L4.80|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b120              CBZ      r0,|L4.28|
;;;449            *perr = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
000014  7020              STRB     r0,[r4,#0]
;;;450            return (0u);
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;451        }
;;;452        OS_ENTER_CRITICAL();
;;;453        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;454            OS_EXIT_CRITICAL();
;;;455            *perr = OS_ERR_EVENT_TYPE;
;;;456            return (0u);
;;;457        }
;;;458        *pname = pgrp->OSFlagName;
;;;459        len    = OS_StrLen(*pname);
;;;460        OS_EXIT_CRITICAL();
;;;461        *perr  = OS_ERR_NONE;
;;;462        return (len);
;;;463    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L4.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;452
000022  7828              LDRB     r0,[r5,#0]            ;453
000024  2805              CMP      r0,#5                 ;453
000026  d006              BEQ      |L4.54|
000028  4638              MOV      r0,r7                 ;454
00002a  f7fffffe          BL       OS_CPU_SR_Restore
00002e  2001              MOVS     r0,#1                 ;455
000030  7020              STRB     r0,[r4,#0]            ;455
000032  2000              MOVS     r0,#0                 ;456
000034  e7f0              B        |L4.24|
                  |L4.54|
000036  68e8              LDR      r0,[r5,#0xc]          ;458
000038  6030              STR      r0,[r6,#0]            ;458
00003a  6830              LDR      r0,[r6,#0]            ;459
00003c  f7fffffe          BL       OS_StrLen
000040  4680              MOV      r8,r0                 ;459
000042  4638              MOV      r0,r7                 ;460
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2000              MOVS     r0,#0                 ;461
00004a  7020              STRB     r0,[r4,#0]            ;461
00004c  4640              MOV      r0,r8                 ;462
00004e  e7e3              B        |L4.24|
;;;464    #endif
                          ENDP

                  |L4.80|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagNameSet||, CODE, READONLY, ALIGN=2

                  OSFlagNameSet PROC
;;;490    #if OS_FLAG_NAME_EN > 0u
;;;491    void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;492                         INT8U        *pname,
;;;493                         INT8U        *perr)
;;;494    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;495    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;496        OS_CPU_SR  cpu_sr = 0u;
00000a  2700              MOVS     r7,#0
;;;497    #endif
;;;498    
;;;499    
;;;500    
;;;501    #ifdef OS_SAFETY_CRITICAL
;;;502        if (perr == (INT8U *)0) {
;;;503            OS_SAFETY_CRITICAL_EXCEPTION();
;;;504            return;
;;;505        }
;;;506    #endif
;;;507    
;;;508    #if OS_ARG_CHK_EN > 0u
;;;509        if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
;;;510            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;511            return;
;;;512        }
;;;513        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;514            *perr = OS_ERR_PNAME_NULL;
;;;515            return;
;;;516        }
;;;517    #endif
;;;518        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  480d              LDR      r0,|L5.68|
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000010  b118              CBZ      r0,|L5.26|
;;;519            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
000014  7020              STRB     r0,[r4,#0]
                  |L5.22|
;;;520            return;
;;;521        }
;;;522        OS_ENTER_CRITICAL();
;;;523        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
;;;524            OS_EXIT_CRITICAL();
;;;525            *perr = OS_ERR_EVENT_TYPE;
;;;526            return;
;;;527        }
;;;528        pgrp->OSFlagName = pname;
;;;529        OS_EXIT_CRITICAL();
;;;530        *perr            = OS_ERR_NONE;
;;;531        return;
;;;532    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L5.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;522
000020  7828              LDRB     r0,[r5,#0]            ;523
000022  2805              CMP      r0,#5                 ;523
000024  d005              BEQ      |L5.50|
000026  4638              MOV      r0,r7                 ;524
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  2001              MOVS     r0,#1                 ;525
00002e  7020              STRB     r0,[r4,#0]            ;525
000030  e7f1              B        |L5.22|
                  |L5.50|
000032  60ee              STR      r6,[r5,#0xc]          ;528
000034  4638              MOV      r0,r7                 ;529
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2000              MOVS     r0,#0                 ;530
00003c  7020              STRB     r0,[r4,#0]            ;530
00003e  bf00              NOP                            ;531
000040  e7e9              B        |L5.22|
;;;533    #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      OSIntNesting

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;589    
;;;590    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;591                          OS_FLAGS      flags,
;;;592                          INT8U         wait_type,
;;;593                          INT32U        timeout,
;;;594                          INT8U        *perr)
;;;595    {
000004  b089              SUB      sp,sp,#0x24
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
00000a  4691              MOV      r9,r2
00000c  469a              MOV      r10,r3
00000e  9e12              LDR      r6,[sp,#0x48]
;;;596        OS_FLAG_NODE  node;
;;;597        OS_FLAGS      flags_rdy;
;;;598        INT8U         result;
;;;599        INT8U         pend_stat;
;;;600        BOOLEAN       consume;
;;;601    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;602        OS_CPU_SR     cpu_sr = 0u;
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
;;;603    #endif
;;;604    
;;;605    
;;;606    
;;;607    #ifdef OS_SAFETY_CRITICAL
;;;608        if (perr == (INT8U *)0) {
;;;609            OS_SAFETY_CRITICAL_EXCEPTION();
;;;610            return ((OS_FLAGS)0);
;;;611        }
;;;612    #endif
;;;613    
;;;614    #if OS_ARG_CHK_EN > 0u
;;;615        if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
;;;616            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;617            return ((OS_FLAGS)0);
;;;618        }
;;;619    #endif
;;;620        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000014  488c              LDR      r0,|L6.584|
000016  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000018  b128              CBZ      r0,|L6.38|
;;;621            *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001a  2002              MOVS     r0,#2
00001c  7030              STRB     r0,[r6,#0]
;;;622            return ((OS_FLAGS)0);
00001e  2000              MOVS     r0,#0
                  |L6.32|
;;;623        }
;;;624        if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
;;;625            *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
;;;626            return ((OS_FLAGS)0);
;;;627        }
;;;628        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
;;;629            *perr = OS_ERR_EVENT_TYPE;
;;;630            return ((OS_FLAGS)0);
;;;631        }
;;;632        result = (INT8U)(wait_type & OS_FLAG_CONSUME);
;;;633        if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
;;;634            wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
;;;635            consume    = OS_TRUE;
;;;636        } else {
;;;637            consume    = OS_FALSE;
;;;638        }
;;;639    /*$PAGE*/
;;;640        OS_ENTER_CRITICAL();
;;;641        switch (wait_type) {
;;;642            case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
;;;643                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
;;;644                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;645                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;646                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
;;;647                     }
;;;648                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;649                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;650                     *perr                   = OS_ERR_NONE;
;;;651                     return (flags_rdy);
;;;652                 } else {                                      /* Block task until events occur or timeout */
;;;653                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;654                     OS_EXIT_CRITICAL();
;;;655                 }
;;;656                 break;
;;;657    
;;;658            case OS_FLAG_WAIT_SET_ANY:
;;;659                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
;;;660                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
;;;661                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;662                         pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
;;;663                     }
;;;664                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;665                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;666                     *perr                   = OS_ERR_NONE;
;;;667                     return (flags_rdy);
;;;668                 } else {                                      /* Block task until events occur or timeout */
;;;669                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;670                     OS_EXIT_CRITICAL();
;;;671                 }
;;;672                 break;
;;;673    
;;;674    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;675            case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
;;;676                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
;;;677                 if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
;;;678                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;679                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
;;;680                     }
;;;681                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;682                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;683                     *perr                   = OS_ERR_NONE;
;;;684                     return (flags_rdy);
;;;685                 } else {                                      /* Block task until events occur or timeout */
;;;686                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;687                     OS_EXIT_CRITICAL();
;;;688                 }
;;;689                 break;
;;;690    
;;;691            case OS_FLAG_WAIT_CLR_ANY:
;;;692                 flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
;;;693                 if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
;;;694                     if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
;;;695                         pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
;;;696                     }
;;;697                     OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
;;;698                     OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
;;;699                     *perr                   = OS_ERR_NONE;
;;;700                     return (flags_rdy);
;;;701                 } else {                                      /* Block task until events occur or timeout */
;;;702                     OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
;;;703                     OS_EXIT_CRITICAL();
;;;704                 }
;;;705                 break;
;;;706    #endif
;;;707    
;;;708            default:
;;;709                 OS_EXIT_CRITICAL();
;;;710                 flags_rdy = (OS_FLAGS)0;
;;;711                 *perr      = OS_ERR_FLAG_WAIT_TYPE;
;;;712                 return (flags_rdy);
;;;713        }
;;;714    /*$PAGE*/
;;;715        OS_Sched();                                            /* Find next HPT ready to run               */
;;;716        OS_ENTER_CRITICAL();
;;;717        if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
;;;718            pend_stat                = OSTCBCur->OSTCBStatPend;
;;;719            OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;720            OS_FlagUnlink(&node);
;;;721            OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
;;;722            OS_EXIT_CRITICAL();
;;;723            flags_rdy                = (OS_FLAGS)0;
;;;724            switch (pend_stat) {
;;;725                case OS_STAT_PEND_ABORT:
;;;726                     *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
;;;727                     break;
;;;728    
;;;729                case OS_STAT_PEND_TO:
;;;730                default:
;;;731                     *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
;;;732                     break;
;;;733            }
;;;734            return (flags_rdy);
;;;735        }
;;;736        flags_rdy = OSTCBCur->OSTCBFlagsRdy;
;;;737        if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
;;;738            switch (wait_type) {
;;;739                case OS_FLAG_WAIT_SET_ALL:
;;;740                case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
;;;741                     pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
;;;742                     break;
;;;743    
;;;744    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;745                case OS_FLAG_WAIT_CLR_ALL:
;;;746                case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
;;;747                     pgrp->OSFlagFlags |=  flags_rdy;
;;;748                     break;
;;;749    #endif
;;;750                default:
;;;751                     OS_EXIT_CRITICAL();
;;;752                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;753                     return ((OS_FLAGS)0);
;;;754            }
;;;755        }
;;;756        OS_EXIT_CRITICAL();
;;;757        *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
;;;758        return (flags_rdy);
;;;759    }
000020  b009              ADD      sp,sp,#0x24
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.38|
000026  4889              LDR      r0,|L6.588|
000028  7800              LDRB     r0,[r0,#0]            ;624  ; OSLockNesting
00002a  b118              CBZ      r0,|L6.52|
00002c  200d              MOVS     r0,#0xd               ;625
00002e  7030              STRB     r0,[r6,#0]            ;625
000030  2000              MOVS     r0,#0                 ;626
000032  e7f5              B        |L6.32|
                  |L6.52|
000034  7828              LDRB     r0,[r5,#0]            ;628
000036  2805              CMP      r0,#5                 ;628
000038  d003              BEQ      |L6.66|
00003a  2001              MOVS     r0,#1                 ;629
00003c  7030              STRB     r0,[r6,#0]            ;629
00003e  2000              MOVS     r0,#0                 ;630
000040  e7ee              B        |L6.32|
                  |L6.66|
000042  f0090b80          AND      r11,r9,#0x80          ;632
000046  f1bb0f00          CMP      r11,#0                ;633
00004a  d004              BEQ      |L6.86|
00004c  f009097f          AND      r9,r9,#0x7f           ;634
000050  f04f0801          MOV      r8,#1                 ;635
000054  e001              B        |L6.90|
                  |L6.86|
000056  f04f0800          MOV      r8,#0                 ;637
                  |L6.90|
00005a  f7fffffe          BL       OS_CPU_SR_Save
00005e  9002              STR      r0,[sp,#8]            ;640
000060  f1b90f00          CMP      r9,#0                 ;641
000064  d04a              BEQ      |L6.252|
000066  f1b90f01          CMP      r9,#1                 ;641
00006a  d068              BEQ      |L6.318|
00006c  f1b90f02          CMP      r9,#2                 ;641
000070  d003              BEQ      |L6.122|
000072  f1b90f03          CMP      r9,#3                 ;641
000076  d176              BNE      |L6.358|
000078  e020              B        |L6.188|
                  |L6.122|
00007a  8928              LDRH     r0,[r5,#8]            ;643
00007c  ea000407          AND      r4,r0,r7              ;643
000080  42bc              CMP      r4,r7                 ;644
000082  d10f              BNE      |L6.164|
000084  f1b80f01          CMP      r8,#1                 ;645
000088  d102              BNE      |L6.144|
00008a  8928              LDRH     r0,[r5,#8]            ;646
00008c  43a0              BICS     r0,r0,r4              ;646
00008e  8128              STRH     r0,[r5,#8]            ;646
                  |L6.144|
000090  486f              LDR      r0,|L6.592|
000092  6800              LDR      r0,[r0,#0]            ;648  ; OSTCBCur
000094  8504              STRH     r4,[r0,#0x28]         ;648
000096  9802              LDR      r0,[sp,#8]            ;649
000098  f7fffffe          BL       OS_CPU_SR_Restore
00009c  2000              MOVS     r0,#0                 ;650
00009e  7030              STRB     r0,[r6,#0]            ;650
0000a0  4620              MOV      r0,r4                 ;651
0000a2  e7bd              B        |L6.32|
                  |L6.164|
0000a4  464b              MOV      r3,r9                 ;653
0000a6  463a              MOV      r2,r7                 ;653
0000a8  a904              ADD      r1,sp,#0x10           ;653
0000aa  4628              MOV      r0,r5                 ;653
0000ac  f8cda000          STR      r10,[sp,#0]           ;653
0000b0  f7fffffe          BL       OS_FlagBlock
0000b4  9802              LDR      r0,[sp,#8]            ;654
0000b6  f7fffffe          BL       OS_CPU_SR_Restore
0000ba  e069              B        |L6.400|
                  |L6.188|
0000bc  8928              LDRH     r0,[r5,#8]            ;659
0000be  ea000407          AND      r4,r0,r7              ;659
0000c2  b17c              CBZ      r4,|L6.228|
0000c4  f1b80f01          CMP      r8,#1                 ;661
0000c8  d102              BNE      |L6.208|
0000ca  8928              LDRH     r0,[r5,#8]            ;662
0000cc  43a0              BICS     r0,r0,r4              ;662
0000ce  8128              STRH     r0,[r5,#8]            ;662
                  |L6.208|
0000d0  485f              LDR      r0,|L6.592|
0000d2  6800              LDR      r0,[r0,#0]            ;664  ; OSTCBCur
0000d4  8504              STRH     r4,[r0,#0x28]         ;664
0000d6  9802              LDR      r0,[sp,#8]            ;665
0000d8  f7fffffe          BL       OS_CPU_SR_Restore
0000dc  2000              MOVS     r0,#0                 ;666
0000de  7030              STRB     r0,[r6,#0]            ;666
0000e0  4620              MOV      r0,r4                 ;667
0000e2  e79d              B        |L6.32|
                  |L6.228|
0000e4  464b              MOV      r3,r9                 ;669
0000e6  463a              MOV      r2,r7                 ;669
0000e8  a904              ADD      r1,sp,#0x10           ;669
0000ea  4628              MOV      r0,r5                 ;669
0000ec  f8cda000          STR      r10,[sp,#0]           ;669
0000f0  f7fffffe          BL       OS_FlagBlock
0000f4  9802              LDR      r0,[sp,#8]            ;670
0000f6  f7fffffe          BL       OS_CPU_SR_Restore
0000fa  e049              B        |L6.400|
                  |L6.252|
0000fc  8928              LDRH     r0,[r5,#8]            ;676
0000fe  ea270400          BIC      r4,r7,r0              ;676
000102  42bc              CMP      r4,r7                 ;677
000104  d10f              BNE      |L6.294|
000106  f1b80f01          CMP      r8,#1                 ;678
00010a  d102              BNE      |L6.274|
00010c  8928              LDRH     r0,[r5,#8]            ;679
00010e  4320              ORRS     r0,r0,r4              ;679
000110  8128              STRH     r0,[r5,#8]            ;679
                  |L6.274|
000112  484f              LDR      r0,|L6.592|
000114  6800              LDR      r0,[r0,#0]            ;681  ; OSTCBCur
000116  8504              STRH     r4,[r0,#0x28]         ;681
000118  9802              LDR      r0,[sp,#8]            ;682
00011a  f7fffffe          BL       OS_CPU_SR_Restore
00011e  2000              MOVS     r0,#0                 ;683
000120  7030              STRB     r0,[r6,#0]            ;683
000122  4620              MOV      r0,r4                 ;684
000124  e77c              B        |L6.32|
                  |L6.294|
000126  464b              MOV      r3,r9                 ;686
000128  463a              MOV      r2,r7                 ;686
00012a  a904              ADD      r1,sp,#0x10           ;686
00012c  4628              MOV      r0,r5                 ;686
00012e  f8cda000          STR      r10,[sp,#0]           ;686
000132  f7fffffe          BL       OS_FlagBlock
000136  9802              LDR      r0,[sp,#8]            ;687
000138  f7fffffe          BL       OS_CPU_SR_Restore
00013c  e028              B        |L6.400|
                  |L6.318|
00013e  8928              LDRH     r0,[r5,#8]            ;692
000140  ea270400          BIC      r4,r7,r0              ;692
000144  b184              CBZ      r4,|L6.360|
000146  f1b80f01          CMP      r8,#1                 ;694
00014a  d102              BNE      |L6.338|
00014c  8928              LDRH     r0,[r5,#8]            ;695
00014e  4320              ORRS     r0,r0,r4              ;695
000150  8128              STRH     r0,[r5,#8]            ;695
                  |L6.338|
000152  483f              LDR      r0,|L6.592|
000154  6800              LDR      r0,[r0,#0]            ;697  ; OSTCBCur
000156  8504              STRH     r4,[r0,#0x28]         ;697
000158  9802              LDR      r0,[sp,#8]            ;698
00015a  f7fffffe          BL       OS_CPU_SR_Restore
00015e  2000              MOVS     r0,#0                 ;699
000160  7030              STRB     r0,[r6,#0]            ;699
000162  4620              MOV      r0,r4                 ;700
000164  e75c              B        |L6.32|
                  |L6.358|
000166  e00b              B        |L6.384|
                  |L6.360|
000168  464b              MOV      r3,r9                 ;702
00016a  463a              MOV      r2,r7                 ;702
00016c  a904              ADD      r1,sp,#0x10           ;702
00016e  4628              MOV      r0,r5                 ;702
000170  f8cda000          STR      r10,[sp,#0]           ;702
000174  f7fffffe          BL       OS_FlagBlock
000178  9802              LDR      r0,[sp,#8]            ;703
00017a  f7fffffe          BL       OS_CPU_SR_Restore
00017e  e007              B        |L6.400|
                  |L6.384|
000180  9802              LDR      r0,[sp,#8]            ;709
000182  f7fffffe          BL       OS_CPU_SR_Restore
000186  2400              MOVS     r4,#0                 ;710
000188  206f              MOVS     r0,#0x6f              ;711
00018a  7030              STRB     r0,[r6,#0]            ;711
00018c  4620              MOV      r0,r4                 ;712
00018e  e747              B        |L6.32|
                  |L6.400|
000190  bf00              NOP                            ;656
000192  f7fffffe          BL       OS_Sched
000196  f7fffffe          BL       OS_CPU_SR_Save
00019a  9002              STR      r0,[sp,#8]            ;716
00019c  482c              LDR      r0,|L6.592|
00019e  6800              LDR      r0,[r0,#0]            ;717  ; OSTCBCur
0001a0  f8900031          LDRB     r0,[r0,#0x31]         ;717
0001a4  b320              CBZ      r0,|L6.496|
0001a6  482a              LDR      r0,|L6.592|
0001a8  6800              LDR      r0,[r0,#0]            ;718  ; OSTCBCur
0001aa  f8900031          LDRB     r0,[r0,#0x31]         ;718
0001ae  9003              STR      r0,[sp,#0xc]          ;718
0001b0  2000              MOVS     r0,#0                 ;719
0001b2  4927              LDR      r1,|L6.592|
0001b4  6809              LDR      r1,[r1,#0]            ;719  ; OSTCBCur
0001b6  f8810031          STRB     r0,[r1,#0x31]         ;719
0001ba  a804              ADD      r0,sp,#0x10           ;720
0001bc  f7fffffe          BL       OS_FlagUnlink
0001c0  2000              MOVS     r0,#0                 ;721
0001c2  4923              LDR      r1,|L6.592|
0001c4  6809              LDR      r1,[r1,#0]            ;721  ; OSTCBCur
0001c6  f8810030          STRB     r0,[r1,#0x30]         ;721
0001ca  9802              LDR      r0,[sp,#8]            ;722
0001cc  f7fffffe          BL       OS_CPU_SR_Restore
0001d0  2400              MOVS     r4,#0                 ;723
0001d2  9803              LDR      r0,[sp,#0xc]          ;724
0001d4  2801              CMP      r0,#1                 ;724
0001d6  d005              BEQ      |L6.484|
0001d8  2802              CMP      r0,#2                 ;724
0001da  d102              BNE      |L6.482|
0001dc  200e              MOVS     r0,#0xe               ;726
0001de  7030              STRB     r0,[r6,#0]            ;726
0001e0  e003              B        |L6.490|
                  |L6.482|
0001e2  bf00              NOP                            ;729
                  |L6.484|
0001e4  200a              MOVS     r0,#0xa               ;731
0001e6  7030              STRB     r0,[r6,#0]            ;731
0001e8  bf00              NOP                            ;732
                  |L6.490|
0001ea  bf00              NOP                            ;727
0001ec  4620              MOV      r0,r4                 ;734
0001ee  e717              B        |L6.32|
                  |L6.496|
0001f0  4817              LDR      r0,|L6.592|
0001f2  6800              LDR      r0,[r0,#0]            ;736  ; OSTCBCur
0001f4  8d04              LDRH     r4,[r0,#0x28]         ;736
0001f6  f1b80f01          CMP      r8,#1                 ;737
0001fa  d11e              BNE      |L6.570|
0001fc  f1b90f00          CMP      r9,#0                 ;738
000200  d00e              BEQ      |L6.544|
000202  f1b90f01          CMP      r9,#1                 ;738
000206  d00c              BEQ      |L6.546|
000208  f1b90f02          CMP      r9,#2                 ;738
00020c  d003              BEQ      |L6.534|
00020e  f1b90f03          CMP      r9,#3                 ;738
000212  d10a              BNE      |L6.554|
000214  e000              B        |L6.536|
                  |L6.534|
000216  bf00              NOP                            ;740
                  |L6.536|
000218  8928              LDRH     r0,[r5,#8]            ;741
00021a  43a0              BICS     r0,r0,r4              ;741
00021c  8128              STRH     r0,[r5,#8]            ;741
00021e  e00b              B        |L6.568|
                  |L6.544|
000220  bf00              NOP                            ;746
                  |L6.546|
000222  8928              LDRH     r0,[r5,#8]            ;747
000224  4320              ORRS     r0,r0,r4              ;747
000226  8128              STRH     r0,[r5,#8]            ;747
000228  e006              B        |L6.568|
                  |L6.554|
00022a  9802              LDR      r0,[sp,#8]            ;751
00022c  f7fffffe          BL       OS_CPU_SR_Restore
000230  206f              MOVS     r0,#0x6f              ;752
000232  7030              STRB     r0,[r6,#0]            ;752
000234  2000              MOVS     r0,#0                 ;753
000236  e6f3              B        |L6.32|
                  |L6.568|
000238  bf00              NOP                            ;742
                  |L6.570|
00023a  9802              LDR      r0,[sp,#8]            ;756
00023c  f7fffffe          BL       OS_CPU_SR_Restore
000240  2000              MOVS     r0,#0                 ;757
000242  7030              STRB     r0,[r6,#0]            ;757
000244  4620              MOV      r0,r4                 ;758
000246  e6eb              B        |L6.32|
;;;760    /*$PAGE*/
                          ENDP

                  |L6.584|
                          DCD      OSIntNesting
                  |L6.588|
                          DCD      OSLockNesting
                  |L6.592|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;775    
;;;776    OS_FLAGS  OSFlagPendGetFlagsRdy (void)
000000  b570              PUSH     {r4-r6,lr}
;;;777    {
;;;778        OS_FLAGS      flags;
;;;779    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;780        OS_CPU_SR     cpu_sr = 0u;
000002  2500              MOVS     r5,#0
;;;781    #endif
;;;782    
;;;783    
;;;784    
;;;785        OS_ENTER_CRITICAL();
000004  f7fffffe          BL       OS_CPU_SR_Save
000008  4605              MOV      r5,r0
;;;786        flags = OSTCBCur->OSTCBFlagsRdy;
00000a  4804              LDR      r0,|L7.28|
00000c  6800              LDR      r0,[r0,#0]  ; OSTCBCur
00000e  8d04              LDRH     r4,[r0,#0x28]
;;;787        OS_EXIT_CRITICAL();
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;788        return (flags);
000016  4620              MOV      r0,r4
;;;789    }
000018  bd70              POP      {r4-r6,pc}
;;;790    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      OSTCBCur

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=1

                  OSFlagPost PROC
;;;832    */
;;;833    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;834                          OS_FLAGS      flags,
;;;835                          INT8U         opt,
;;;836                          INT8U        *perr)
;;;837    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
00000a  461e              MOV      r6,r3
;;;838        OS_FLAG_NODE *pnode;
;;;839        BOOLEAN       sched;
;;;840        OS_FLAGS      flags_cur;
;;;841        OS_FLAGS      flags_rdy;
;;;842        BOOLEAN       rdy;
;;;843    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;844        OS_CPU_SR     cpu_sr = 0u;
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;845    #endif
;;;846    
;;;847    
;;;848    
;;;849    #ifdef OS_SAFETY_CRITICAL
;;;850        if (perr == (INT8U *)0) {
;;;851            OS_SAFETY_CRITICAL_EXCEPTION();
;;;852            return ((OS_FLAGS)0);
;;;853        }
;;;854    #endif
;;;855    
;;;856    #if OS_ARG_CHK_EN > 0u
;;;857        if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
;;;858            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;859            return ((OS_FLAGS)0);
;;;860        }
;;;861    #endif
;;;862        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
000010  7820              LDRB     r0,[r4,#0]
000012  2805              CMP      r0,#5
000014  d004              BEQ      |L8.32|
;;;863            *perr = OS_ERR_EVENT_TYPE;
000016  2001              MOVS     r0,#1
000018  7030              STRB     r0,[r6,#0]
;;;864            return ((OS_FLAGS)0);
00001a  2000              MOVS     r0,#0
                  |L8.28|
;;;865        }
;;;866    /*$PAGE*/
;;;867        OS_ENTER_CRITICAL();
;;;868        switch (opt) {
;;;869            case OS_FLAG_CLR:
;;;870                 pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
;;;871                 break;
;;;872    
;;;873            case OS_FLAG_SET:
;;;874                 pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
;;;875                 break;
;;;876    
;;;877            default:
;;;878                 OS_EXIT_CRITICAL();                     /* INVALID option                                 */
;;;879                 *perr = OS_ERR_FLAG_INVALID_OPT;
;;;880                 return ((OS_FLAGS)0);
;;;881        }
;;;882        sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
;;;883        pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
;;;884        while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
;;;885            switch (pnode->OSFlagNodeWaitType) {
;;;886                case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
;;;887                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;888                     if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
;;;889                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;890                         if (rdy == OS_TRUE) {
;;;891                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;892                         }
;;;893                     }
;;;894                     break;
;;;895    
;;;896                case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
;;;897                     flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
;;;898                     if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
;;;899                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;900                         if (rdy == OS_TRUE) {
;;;901                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;902                         }
;;;903                     }
;;;904                     break;
;;;905    
;;;906    #if OS_FLAG_WAIT_CLR_EN > 0u
;;;907                case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
;;;908                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;909                     if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
;;;910                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;911                         if (rdy == OS_TRUE) {
;;;912                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;913                         }
;;;914                     }
;;;915                     break;
;;;916    
;;;917                case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
;;;918                     flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
;;;919                     if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
;;;920                         rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);  
;;;921                         if (rdy == OS_TRUE) {
;;;922                             sched = OS_TRUE;                     /* When done we will reschedule          */
;;;923                         }
;;;924                     }
;;;925                     break;
;;;926    #endif
;;;927                default:
;;;928                     OS_EXIT_CRITICAL();
;;;929                     *perr = OS_ERR_FLAG_WAIT_TYPE;
;;;930                     return ((OS_FLAGS)0);
;;;931            }
;;;932            pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
;;;933        }
;;;934        OS_EXIT_CRITICAL();
;;;935        if (sched == OS_TRUE) {
;;;936            OS_Sched();
;;;937        }
;;;938        OS_ENTER_CRITICAL();
;;;939        flags_cur = pgrp->OSFlagFlags;
;;;940        OS_EXIT_CRITICAL();
;;;941        *perr     = OS_ERR_NONE;
;;;942        return (flags_cur);
;;;943    }
00001c  e8bd9ffc          POP      {r2-r12,pc}
                  |L8.32|
000020  f7fffffe          BL       OS_CPU_SR_Save
000024  9000              STR      r0,[sp,#0]            ;867
000026  f1ba0f00          CMP      r10,#0                ;868
00002a  d003              BEQ      |L8.52|
00002c  f1ba0f01          CMP      r10,#1                ;868
000030  d10a              BNE      |L8.72|
000032  e004              B        |L8.62|
                  |L8.52|
000034  8920              LDRH     r0,[r4,#8]            ;870
000036  ea200009          BIC      r0,r0,r9              ;870
00003a  8120              STRH     r0,[r4,#8]            ;870
00003c  e00b              B        |L8.86|
                  |L8.62|
00003e  8920              LDRH     r0,[r4,#8]            ;874
000040  ea400009          ORR      r0,r0,r9              ;874
000044  8120              STRH     r0,[r4,#8]            ;874
000046  e006              B        |L8.86|
                  |L8.72|
000048  9800              LDR      r0,[sp,#0]            ;878
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2071              MOVS     r0,#0x71              ;879
000050  7030              STRB     r0,[r6,#0]            ;879
000052  2000              MOVS     r0,#0                 ;880
000054  e7e2              B        |L8.28|
                  |L8.86|
000056  bf00              NOP                            ;871
000058  f04f0b00          MOV      r11,#0                ;882
00005c  6865              LDR      r5,[r4,#4]            ;883
00005e  e059              B        |L8.276|
                  |L8.96|
000060  7ca8              LDRB     r0,[r5,#0x12]         ;885
000062  b350              CBZ      r0,|L8.186|
000064  2801              CMP      r0,#1                 ;885
000066  d03b              BEQ      |L8.224|
000068  2802              CMP      r0,#2                 ;885
00006a  d002              BEQ      |L8.114|
00006c  2803              CMP      r0,#3                 ;885
00006e  d148              BNE      |L8.258|
000070  e012              B        |L8.152|
                  |L8.114|
000072  8920              LDRH     r0,[r4,#8]            ;887
000074  8a29              LDRH     r1,[r5,#0x10]         ;887
000076  ea000701          AND      r7,r0,r1              ;887
00007a  8a28              LDRH     r0,[r5,#0x10]         ;888
00007c  42b8              CMP      r0,r7                 ;888
00007e  d10a              BNE      |L8.150|
000080  2200              MOVS     r2,#0                 ;889
000082  4639              MOV      r1,r7                 ;889
000084  4628              MOV      r0,r5                 ;889
000086  f7fffffe          BL       OS_FlagTaskRdy
00008a  4680              MOV      r8,r0                 ;889
00008c  f1b80f01          CMP      r8,#1                 ;890
000090  d101              BNE      |L8.150|
000092  f04f0b01          MOV      r11,#1                ;891
                  |L8.150|
000096  e03b              B        |L8.272|
                  |L8.152|
000098  8920              LDRH     r0,[r4,#8]            ;897
00009a  8a29              LDRH     r1,[r5,#0x10]         ;897
00009c  ea000701          AND      r7,r0,r1              ;897
0000a0  b157              CBZ      r7,|L8.184|
0000a2  2200              MOVS     r2,#0                 ;899
0000a4  4639              MOV      r1,r7                 ;899
0000a6  4628              MOV      r0,r5                 ;899
0000a8  f7fffffe          BL       OS_FlagTaskRdy
0000ac  4680              MOV      r8,r0                 ;899
0000ae  f1b80f01          CMP      r8,#1                 ;900
0000b2  d101              BNE      |L8.184|
0000b4  f04f0b01          MOV      r11,#1                ;901
                  |L8.184|
0000b8  e02a              B        |L8.272|
                  |L8.186|
0000ba  8a28              LDRH     r0,[r5,#0x10]         ;908
0000bc  8921              LDRH     r1,[r4,#8]            ;908
0000be  ea200701          BIC      r7,r0,r1              ;908
0000c2  8a28              LDRH     r0,[r5,#0x10]         ;909
0000c4  42b8              CMP      r0,r7                 ;909
0000c6  d10a              BNE      |L8.222|
0000c8  2200              MOVS     r2,#0                 ;910
0000ca  4639              MOV      r1,r7                 ;910
0000cc  4628              MOV      r0,r5                 ;910
0000ce  f7fffffe          BL       OS_FlagTaskRdy
0000d2  4680              MOV      r8,r0                 ;910
0000d4  f1b80f01          CMP      r8,#1                 ;911
0000d8  d101              BNE      |L8.222|
0000da  f04f0b01          MOV      r11,#1                ;912
                  |L8.222|
0000de  e017              B        |L8.272|
                  |L8.224|
0000e0  8a28              LDRH     r0,[r5,#0x10]         ;918
0000e2  8921              LDRH     r1,[r4,#8]            ;918
0000e4  ea200701          BIC      r7,r0,r1              ;918
0000e8  b157              CBZ      r7,|L8.256|
0000ea  2200              MOVS     r2,#0                 ;920
0000ec  4639              MOV      r1,r7                 ;920
0000ee  4628              MOV      r0,r5                 ;920
0000f0  f7fffffe          BL       OS_FlagTaskRdy
0000f4  4680              MOV      r8,r0                 ;920
0000f6  f1b80f01          CMP      r8,#1                 ;921
0000fa  d101              BNE      |L8.256|
0000fc  f04f0b01          MOV      r11,#1                ;922
                  |L8.256|
000100  e006              B        |L8.272|
                  |L8.258|
000102  9800              LDR      r0,[sp,#0]            ;928
000104  f7fffffe          BL       OS_CPU_SR_Restore
000108  206f              MOVS     r0,#0x6f              ;929
00010a  7030              STRB     r0,[r6,#0]            ;929
00010c  2000              MOVS     r0,#0                 ;930
00010e  e785              B        |L8.28|
                  |L8.272|
000110  bf00              NOP                            ;894
000112  682d              LDR      r5,[r5,#0]            ;932
                  |L8.276|
000114  2d00              CMP      r5,#0                 ;884
000116  d1a3              BNE      |L8.96|
000118  9800              LDR      r0,[sp,#0]            ;934
00011a  f7fffffe          BL       OS_CPU_SR_Restore
00011e  f1bb0f01          CMP      r11,#1                ;935
000122  d101              BNE      |L8.296|
000124  f7fffffe          BL       OS_Sched
                  |L8.296|
000128  f7fffffe          BL       OS_CPU_SR_Save
00012c  9000              STR      r0,[sp,#0]            ;938
00012e  8920              LDRH     r0,[r4,#8]            ;939
000130  9001              STR      r0,[sp,#4]            ;939
000132  9800              LDR      r0,[sp,#0]            ;940
000134  f7fffffe          BL       OS_CPU_SR_Restore
000138  2000              MOVS     r0,#0                 ;941
00013a  7030              STRB     r0,[r6,#0]            ;941
00013c  9801              LDR      r0,[sp,#4]            ;942
00013e  e76d              B        |L8.28|
;;;944    /*$PAGE*/
                          ENDP


                          AREA ||i.OSFlagQuery||, CODE, READONLY, ALIGN=1

                  OSFlagQuery PROC
;;;964    #if OS_FLAG_QUERY_EN > 0u
;;;965    OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;966                           INT8U        *perr)
;;;967    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;968        OS_FLAGS   flags;
;;;969    #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
;;;970        OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;971    #endif
;;;972    
;;;973    
;;;974    
;;;975    #ifdef OS_SAFETY_CRITICAL
;;;976        if (perr == (INT8U *)0) {
;;;977            OS_SAFETY_CRITICAL_EXCEPTION();
;;;978            return ((OS_FLAGS)0);
;;;979        }
;;;980    #endif
;;;981    
;;;982    #if OS_ARG_CHK_EN > 0u
;;;983        if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
;;;984            *perr = OS_ERR_FLAG_INVALID_PGRP;
;;;985            return ((OS_FLAGS)0);
;;;986        }
;;;987    #endif
;;;988        if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2805              CMP      r0,#5
00000e  d004              BEQ      |L9.26|
;;;989            *perr = OS_ERR_EVENT_TYPE;
000010  2001              MOVS     r0,#1
000012  7028              STRB     r0,[r5,#0]
;;;990            return ((OS_FLAGS)0);
000014  2000              MOVS     r0,#0
                  |L9.22|
;;;991        }
;;;992        OS_ENTER_CRITICAL();
;;;993        flags = pgrp->OSFlagFlags;
;;;994        OS_EXIT_CRITICAL();
;;;995        *perr = OS_ERR_NONE;
;;;996        return (flags);                               /* Return the current value of the event flags       */
;;;997    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L9.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  4607              MOV      r7,r0                 ;992
000020  8926              LDRH     r6,[r4,#8]            ;993
000022  4638              MOV      r0,r7                 ;994
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2000              MOVS     r0,#0                 ;995
00002a  7028              STRB     r0,[r5,#0]            ;995
00002c  4630              MOV      r0,r6                 ;996
00002e  e7f2              B        |L9.22|
;;;998    #endif
                          ENDP


                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;1037   
;;;1038   static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1039                               OS_FLAG_NODE *pnode,
;;;1040                               OS_FLAGS      flags,
;;;1041                               INT8U         wait_type,
;;;1042                               INT32U        timeout)
;;;1043   {
000002  4614              MOV      r4,r2
000004  9e05              LDR      r6,[sp,#0x14]
;;;1044       OS_FLAG_NODE  *pnode_next;
;;;1045       INT8U          y;
;;;1046   
;;;1047   
;;;1048       OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
000006  4f24              LDR      r7,|L10.152|
000008  683f              LDR      r7,[r7,#0]  ; OSTCBCur
00000a  f8977030          LDRB     r7,[r7,#0x30]
00000e  f0470720          ORR      r7,r7,#0x20
000012  f8dfc084          LDR      r12,|L10.152|
000016  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
00001a  f88c7030          STRB     r7,[r12,#0x30]
;;;1049       OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
00001e  2700              MOVS     r7,#0
000020  f8dfc074          LDR      r12,|L10.152|
000024  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000028  f88c7031          STRB     r7,[r12,#0x31]
;;;1050       OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002c  4f1a              LDR      r7,|L10.152|
00002e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000030  62fe              STR      r6,[r7,#0x2c]
;;;1051   #if OS_TASK_DEL_EN > 0u
;;;1052       OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
000032  4f19              LDR      r7,|L10.152|
000034  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000036  6279              STR      r1,[r7,#0x24]
;;;1053   #endif
;;;1054       pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
000038  820c              STRH     r4,[r1,#0x10]
;;;1055       pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00003a  748b              STRB     r3,[r1,#0x12]
;;;1056       pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00003c  4f16              LDR      r7,|L10.152|
00003e  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000040  608f              STR      r7,[r1,#8]
;;;1057       pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
000042  6847              LDR      r7,[r0,#4]
000044  600f              STR      r7,[r1,#0]
;;;1058       pnode->OSFlagNodePrev     = (void *)0;
000046  2700              MOVS     r7,#0
000048  604f              STR      r7,[r1,#4]
;;;1059       pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
00004a  60c8              STR      r0,[r1,#0xc]
;;;1060       pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00004c  6845              LDR      r5,[r0,#4]
;;;1061       if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
00004e  b105              CBZ      r5,|L10.82|
;;;1062           pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000050  6069              STR      r1,[r5,#4]
                  |L10.82|
;;;1063       }
;;;1064       pgrp->OSFlagWaitList = (void *)pnode;
000052  6041              STR      r1,[r0,#4]
;;;1065   
;;;1066       y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000054  4f10              LDR      r7,|L10.152|
000056  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000058  f8972034          LDRB     r2,[r7,#0x34]
;;;1067       OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00005c  4f0f              LDR      r7,|L10.156|
00005e  5cbf              LDRB     r7,[r7,r2]
000060  f8dfc034          LDR      r12,|L10.152|
000064  f8dcc000          LDR      r12,[r12,#0]  ; OSTCBCur
000068  f89cc035          LDRB     r12,[r12,#0x35]
00006c  ea27070c          BIC      r7,r7,r12
000070  f8dfc028          LDR      r12,|L10.156|
000074  f80c7002          STRB     r7,[r12,r2]
;;;1068       if (OSRdyTbl[y] == 0x00u) {
000078  4667              MOV      r7,r12
00007a  5cbf              LDRB     r7,[r7,r2]
00007c  b95f              CBNZ     r7,|L10.150|
;;;1069           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00007e  4f06              LDR      r7,|L10.152|
000080  683f              LDR      r7,[r7,#0]  ; OSTCBCur
000082  f897c036          LDRB     r12,[r7,#0x36]
000086  4f06              LDR      r7,|L10.160|
000088  783f              LDRB     r7,[r7,#0]  ; OSRdyGrp
00008a  ea27070c          BIC      r7,r7,r12
00008e  f8dfc010          LDR      r12,|L10.160|
000092  f88c7000          STRB     r7,[r12,#0]
                  |L10.150|
;;;1070       }
;;;1071   }
000096  bdf0              POP      {r4-r7,pc}
;;;1072   
                          ENDP

                  |L10.152|
                          DCD      OSTCBCur
                  |L10.156|
                          DCD      OSRdyTbl
                  |L10.160|
                          DCD      OSRdyGrp

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;1088   
;;;1089   void  OS_FlagInit (void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1090   {
;;;1091   #if OS_MAX_FLAGS == 1u
;;;1092       OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
;;;1093       OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
;;;1094       OSFlagFreeList->OSFlagWaitList = (void *)0;
;;;1095       OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
;;;1096   #if OS_FLAG_NAME_EN > 0u
;;;1097       OSFlagFreeList->OSFlagName     = (INT8U *)"?";
;;;1098   #endif
;;;1099   #endif
;;;1100   
;;;1101   #if OS_MAX_FLAGS >= 2u
;;;1102       INT16U        ix;
;;;1103       INT16U        ix_next;
;;;1104       OS_FLAG_GRP  *pgrp1;
;;;1105       OS_FLAG_GRP  *pgrp2;
;;;1106   
;;;1107   
;;;1108       OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
000004  2150              MOVS     r1,#0x50
000006  4811              LDR      r0,|L11.76|
000008  f7fffffe          BL       OS_MemClr
;;;1109       for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00000c  2500              MOVS     r5,#0
00000e  e00d              B        |L11.44|
                  |L11.16|
;;;1110           ix_next = ix + 1u;
000010  1c68              ADDS     r0,r5,#1
000012  b286              UXTH     r6,r0
;;;1111           pgrp1 = &OSFlagTbl[ix];
000014  480d              LDR      r0,|L11.76|
000016  eb001405          ADD      r4,r0,r5,LSL #4
;;;1112           pgrp2 = &OSFlagTbl[ix_next];
00001a  eb001706          ADD      r7,r0,r6,LSL #4
;;;1113           pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001e  2000              MOVS     r0,#0
000020  7020              STRB     r0,[r4,#0]
;;;1114           pgrp1->OSFlagWaitList = (void *)pgrp2;
000022  6067              STR      r7,[r4,#4]
;;;1115   #if OS_FLAG_NAME_EN > 0u
;;;1116           pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
000024  a00a              ADR      r0,|L11.80|
000026  60e0              STR      r0,[r4,#0xc]
000028  1c68              ADDS     r0,r5,#1              ;1109
00002a  b285              UXTH     r5,r0                 ;1109
                  |L11.44|
00002c  2d04              CMP      r5,#4                 ;1109
00002e  d3ef              BCC      |L11.16|
;;;1117   #endif
;;;1118       }
;;;1119       pgrp1                 = &OSFlagTbl[ix];
000030  4806              LDR      r0,|L11.76|
000032  eb001405          ADD      r4,r0,r5,LSL #4
;;;1120       pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000036  2000              MOVS     r0,#0
000038  7020              STRB     r0,[r4,#0]
;;;1121       pgrp1->OSFlagWaitList = (void *)0;
00003a  6060              STR      r0,[r4,#4]
;;;1122   #if OS_FLAG_NAME_EN > 0u
;;;1123       pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00003c  a004              ADR      r0,|L11.80|
00003e  60e0              STR      r0,[r4,#0xc]
;;;1124   #endif
;;;1125       OSFlagFreeList        = &OSFlagTbl[0];
000040  4802              LDR      r0,|L11.76|
000042  4904              LDR      r1,|L11.84|
000044  6008              STR      r0,[r1,#0]  ; OSFlagFreeList
;;;1126   #endif
;;;1127   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1128   
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      OSFlagTbl
                  |L11.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0
                  |L11.84|
                          DCD      OSFlagFreeList

                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_FlagTaskRdy PROC
;;;1155   
;;;1156   static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1157                                    OS_FLAGS      flags_rdy,
;;;1158                                    INT8U         pend_stat)
;;;1159   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;1160       OS_TCB   *ptcb;
;;;1161       BOOLEAN   sched;
;;;1162   
;;;1163   
;;;1164       ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
00000a  68b4              LDR      r4,[r6,#8]
;;;1165       ptcb->OSTCBDly       = 0u;
00000c  2000              MOVS     r0,#0
00000e  f8440f2c          STR      r0,[r4,#0x2c]!
;;;1166       ptcb->OSTCBFlagsRdy  = flags_rdy;
000012  f8248c04          STRH     r8,[r4,#-4]
;;;1167       ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000016  7920              LDRB     r0,[r4,#4]
000018  f00000df          AND      r0,r0,#0xdf
00001c  7120              STRB     r0,[r4,#4]
;;;1168       ptcb->OSTCBStatPend  = pend_stat;
00001e  7167              STRB     r7,[r4,#5]
;;;1169       if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000020  7920              LDRB     r0,[r4,#4]
000022  3c2c              SUBS     r4,r4,#0x2c
000024  b988              CBNZ     r0,|L12.74|
;;;1170           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000026  3434              ADDS     r4,r4,#0x34
000028  78a0              LDRB     r0,[r4,#2]
00002a  490b              LDR      r1,|L12.88|
00002c  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
00002e  4308              ORRS     r0,r0,r1
000030  4909              LDR      r1,|L12.88|
000032  7008              STRB     r0,[r1,#0]
;;;1171           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000034  7820              LDRB     r0,[r4,#0]
000036  4909              LDR      r1,|L12.92|
000038  5c08              LDRB     r0,[r1,r0]
00003a  7861              LDRB     r1,[r4,#1]
00003c  4308              ORRS     r0,r0,r1
00003e  f8141934          LDRB     r1,[r4],#-0x34
000042  4a06              LDR      r2,|L12.92|
000044  5450              STRB     r0,[r2,r1]
;;;1172           sched                   = OS_TRUE;
000046  2501              MOVS     r5,#1
000048  e000              B        |L12.76|
                  |L12.74|
;;;1173       } else {
;;;1174           sched                   = OS_FALSE;
00004a  2500              MOVS     r5,#0
                  |L12.76|
;;;1175       }
;;;1176       OS_FlagUnlink(pnode);
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       OS_FlagUnlink
;;;1177       return (sched);
000052  4628              MOV      r0,r5
;;;1178   }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;1179   
                          ENDP

                  |L12.88|
                          DCD      OSRdyGrp
                  |L12.92|
                          DCD      OSRdyTbl

                          AREA ||i.OS_FlagUnlink||, CODE, READONLY, ALIGN=1

                  OS_FlagUnlink PROC
;;;1201   
;;;1202   void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
000000  b530              PUSH     {r4,r5,lr}
;;;1203   {
000002  4601              MOV      r1,r0
;;;1204   #if OS_TASK_DEL_EN > 0u
;;;1205       OS_TCB       *ptcb;
;;;1206   #endif
;;;1207       OS_FLAG_GRP  *pgrp;
;;;1208       OS_FLAG_NODE *pnode_prev;
;;;1209       OS_FLAG_NODE *pnode_next;
;;;1210   
;;;1211   
;;;1212       pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
000004  684a              LDR      r2,[r1,#4]
;;;1213       pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
000006  6808              LDR      r0,[r1,#0]
;;;1214       if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
000008  b92a              CBNZ     r2,|L13.22|
;;;1215           pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00000a  68cc              LDR      r4,[r1,#0xc]
;;;1216           pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
00000c  6060              STR      r0,[r4,#4]
;;;1217           if (pnode_next != (OS_FLAG_NODE *)0) {
00000e  b128              CBZ      r0,|L13.28|
;;;1218               pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
000010  2500              MOVS     r5,#0
000012  6045              STR      r5,[r0,#4]
000014  e002              B        |L13.28|
                  |L13.22|
;;;1219           }
;;;1220       } else {                                                    /* No,  A node somewhere in the list   */
;;;1221           pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
000016  6010              STR      r0,[r2,#0]
;;;1222           if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
000018  b100              CBZ      r0,|L13.28|
;;;1223               pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00001a  6042              STR      r2,[r0,#4]
                  |L13.28|
;;;1224           }
;;;1225       }
;;;1226   #if OS_TASK_DEL_EN > 0u
;;;1227       ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
00001c  688b              LDR      r3,[r1,#8]
;;;1228       ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00001e  2500              MOVS     r5,#0
000020  625d              STR      r5,[r3,#0x24]
;;;1229   #endif
;;;1230   }
000022  bd30              POP      {r4,r5,pc}
;;;1231   #endif
                          ENDP

