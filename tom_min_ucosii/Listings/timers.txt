; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\timers.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timers.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\FreeRTOS\include -I.\FreeRTOS\portable\RVDS\ARM_CM3 -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\timers.crf FreeRTOS\timers.c]
                          THUMB

                          AREA ||i.pcTimerGetName||, CODE, READONLY, ALIGN=1

                  pcTimerGetName PROC
;;;472    
;;;473    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;474    {
;;;475    Timer_t *pxTimer = xTimer;
000002  460a              MOV      r2,r1
;;;476    
;;;477    	configASSERT( xTimer );
;;;478    	return pxTimer->pcTimerName;
000004  6810              LDR      r0,[r2,#0]
;;;479    }
000006  4770              BX       lr
;;;480    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCheckForValidListAndQueue||, CODE, READONLY, ALIGN=2

                  prvCheckForValidListAndQueue PROC
;;;915    
;;;916    static void prvCheckForValidListAndQueue( void )
000000  b510              PUSH     {r4,lr}
;;;917    {
;;;918    	/* Check that the list from which active timers are referenced, and the
;;;919    	queue used to communicate with the timer service, have been
;;;920    	initialised. */
;;;921    	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;922    	{
;;;923    		if( xTimerQueue == NULL )
000006  480c              LDR      r0,|L2.56|
000008  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000a  b990              CBNZ     r0,|L2.50|
;;;924    		{
;;;925    			vListInitialise( &xActiveTimerList1 );
00000c  480b              LDR      r0,|L2.60|
00000e  f7fffffe          BL       vListInitialise
;;;926    			vListInitialise( &xActiveTimerList2 );
000012  480b              LDR      r0,|L2.64|
000014  f7fffffe          BL       vListInitialise
;;;927    			pxCurrentTimerList = &xActiveTimerList1;
000018  4808              LDR      r0,|L2.60|
00001a  490a              LDR      r1,|L2.68|
00001c  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;928    			pxOverflowTimerList = &xActiveTimerList2;
00001e  4808              LDR      r0,|L2.64|
000020  4909              LDR      r1,|L2.72|
000022  6008              STR      r0,[r1,#0]  ; pxOverflowTimerList
;;;929    
;;;930    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;931    			{
;;;932    				/* The timer queue is allocated statically in case
;;;933    				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
;;;934    				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;935    				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
;;;936    
;;;937    				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
;;;938    			}
;;;939    			#else
;;;940    			{
;;;941    				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
000024  2200              MOVS     r2,#0
000026  210c              MOVS     r1,#0xc
000028  2004              MOVS     r0,#4
00002a  f7fffffe          BL       xQueueGenericCreate
00002e  4902              LDR      r1,|L2.56|
000030  6008              STR      r0,[r1,#0]  ; xTimerQueue
                  |L2.50|
;;;942    			}
;;;943    			#endif
;;;944    
;;;945    			#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;946    			{
;;;947    				if( xTimerQueue != NULL )
;;;948    				{
;;;949    					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
;;;950    				}
;;;951    				else
;;;952    				{
;;;953    					mtCOVERAGE_TEST_MARKER();
;;;954    				}
;;;955    			}
;;;956    			#endif /* configQUEUE_REGISTRY_SIZE */
;;;957    		}
;;;958    		else
;;;959    		{
;;;960    			mtCOVERAGE_TEST_MARKER();
;;;961    		}
;;;962    	}
;;;963    	taskEXIT_CRITICAL();
000032  f7fffffe          BL       vPortExitCritical
;;;964    }
000036  bd10              POP      {r4,pc}
;;;965    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.56|
                          DCD      xTimerQueue
                  |L2.60|
                          DCD      xActiveTimerList1
                  |L2.64|
                          DCD      xActiveTimerList2
                  |L2.68|
                          DCD      pxCurrentTimerList
                  |L2.72|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvGetNextExpireTime||, CODE, READONLY, ALIGN=2

                  prvGetNextExpireTime PROC
;;;618    
;;;619    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
000000  4601              MOV      r1,r0
;;;620    {
;;;621    TickType_t xNextExpireTime;
;;;622    
;;;623    	/* Timers are listed in expiry time order, with the head of the list
;;;624    	referencing the task that will expire first.  Obtain the time at which
;;;625    	the timer with the nearest expiry time will expire.  If there are no
;;;626    	active timers then just set the next expire time to 0.  That will cause
;;;627    	this task to unblock when the tick count overflows, at which point the
;;;628    	timer lists will be switched and the next expiry time can be
;;;629    	re-assessed.  */
;;;630    	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
000002  4a08              LDR      r2,|L3.36|
000004  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
000006  6812              LDR      r2,[r2,#0]
000008  b90a              CBNZ     r2,|L3.14|
00000a  2201              MOVS     r2,#1
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  2200              MOVS     r2,#0
                  |L3.16|
000010  600a              STR      r2,[r1,#0]
;;;631    	if( *pxListWasEmpty == pdFALSE )
000012  680a              LDR      r2,[r1,#0]
000014  b922              CBNZ     r2,|L3.32|
;;;632    	{
;;;633    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000016  4a03              LDR      r2,|L3.36|
000018  6812              LDR      r2,[r2,#0]  ; pxCurrentTimerList
00001a  68d2              LDR      r2,[r2,#0xc]
00001c  6810              LDR      r0,[r2,#0]
00001e  e000              B        |L3.34|
                  |L3.32|
;;;634    	}
;;;635    	else
;;;636    	{
;;;637    		/* Ensure the task unblocks when the tick count rolls over. */
;;;638    		xNextExpireTime = ( TickType_t ) 0U;
000020  2000              MOVS     r0,#0
                  |L3.34|
;;;639    	}
;;;640    
;;;641    	return xNextExpireTime;
;;;642    }
000022  4770              BX       lr
;;;643    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.36|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvInitialiseNewTimer||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTimer PROC
;;;348    
;;;349    static void prvInitialiseNewTimer(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;350    									const TickType_t xTimerPeriodInTicks,
;;;351    									const UBaseType_t uxAutoReload,
;;;352    									void * const pvTimerID,
;;;353    									TimerCallbackFunction_t pxCallbackFunction,
;;;354    									Timer_t *pxNewTimer )
;;;355    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9408          LDRD     r9,r4,[sp,#0x20]
;;;356    	/* 0 is not a valid value for xTimerPeriodInTicks. */
;;;357    	configASSERT( ( xTimerPeriodInTicks > 0 ) );
;;;358    
;;;359    	if( pxNewTimer != NULL )
000010  b18c              CBZ      r4,|L4.54|
;;;360    	{
;;;361    		/* Ensure the infrastructure used by the timer service task has been
;;;362    		created/initialised. */
;;;363    		prvCheckForValidListAndQueue();
000012  f7fffffe          BL       prvCheckForValidListAndQueue
;;;364    
;;;365    		/* Initialise the timer structure members using the function
;;;366    		parameters. */
;;;367    		pxNewTimer->pcTimerName = pcTimerName;
000016  6025              STR      r5,[r4,#0]
;;;368    		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
000018  61a6              STR      r6,[r4,#0x18]
;;;369    		pxNewTimer->pvTimerID = pvTimerID;
00001a  f8c4801c          STR      r8,[r4,#0x1c]
;;;370    		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
00001e  f8c49020          STR      r9,[r4,#0x20]
;;;371    		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       vListInitialiseItem
;;;372    		if( uxAutoReload != pdFALSE )
000028  b12f              CBZ      r7,|L4.54|
;;;373    		{
;;;374    			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
00002a  f8940024          LDRB     r0,[r4,#0x24]
00002e  f0400004          ORR      r0,r0,#4
000032  f8840024          STRB     r0,[r4,#0x24]
                  |L4.54|
;;;375    		}
;;;376    		traceTIMER_CREATE( pxNewTimer );
;;;377    	}
;;;378    }
000036  e8bd87f0          POP      {r4-r10,pc}
;;;379    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInsertTimerInActiveList||, CODE, READONLY, ALIGN=2

                  prvInsertTimerInActiveList PROC
;;;667    
;;;668    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;669    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;670    BaseType_t xProcessTimerNow = pdFALSE;
00000c  f04f0800          MOV      r8,#0
;;;671    
;;;672    	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
000010  6065              STR      r5,[r4,#4]
;;;673    	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000012  6124              STR      r4,[r4,#0x10]
;;;674    
;;;675    	if( xNextExpiryTime <= xTimeNow )
000014  42b5              CMP      r5,r6
000016  d80c              BHI      |L5.50|
;;;676    	{
;;;677    		/* Has the expiry time elapsed between the command to start/reset a
;;;678    		timer was issued, and the time the command was processed? */
;;;679    		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000018  1bf0              SUBS     r0,r6,r7
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4288              CMP      r0,r1
00001e  d302              BCC      |L5.38|
;;;680    		{
;;;681    			/* The time between a command being issued and the command being
;;;682    			processed actually exceeds the timers period.  */
;;;683    			xProcessTimerNow = pdTRUE;
000020  f04f0801          MOV      r8,#1
000024  e011              B        |L5.74|
                  |L5.38|
;;;684    		}
;;;685    		else
;;;686    		{
;;;687    			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4809              LDR      r0,|L5.80|
00002a  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
00002c  f7fffffe          BL       vListInsert
000030  e00b              B        |L5.74|
                  |L5.50|
;;;688    		}
;;;689    	}
;;;690    	else
;;;691    	{
;;;692    		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
000032  42be              CMP      r6,r7
000034  d204              BCS      |L5.64|
000036  42bd              CMP      r5,r7
000038  d302              BCC      |L5.64|
;;;693    		{
;;;694    			/* If, since the command was issued, the tick count has overflowed
;;;695    			but the expiry time has not, then the timer must have already passed
;;;696    			its expiry time and should be processed immediately. */
;;;697    			xProcessTimerNow = pdTRUE;
00003a  f04f0801          MOV      r8,#1
00003e  e004              B        |L5.74|
                  |L5.64|
;;;698    		}
;;;699    		else
;;;700    		{
;;;701    			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000040  1d21              ADDS     r1,r4,#4
000042  4804              LDR      r0,|L5.84|
000044  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000046  f7fffffe          BL       vListInsert
                  |L5.74|
;;;702    		}
;;;703    	}
;;;704    
;;;705    	return xProcessTimerNow;
00004a  4640              MOV      r0,r8
;;;706    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;707    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.80|
                          DCD      pxOverflowTimerList
                  |L5.84|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessExpiredTimer||, CODE, READONLY, ALIGN=2

                  prvProcessExpiredTimer PROC
;;;481    
;;;482    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
000000  b5f8              PUSH     {r3-r7,lr}
;;;483    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;484    BaseType_t xResult;
;;;485    Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
000006  4814              LDR      r0,|L6.88|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  68c4              LDR      r4,[r0,#0xc]
;;;486    
;;;487    	/* Remove the timer from the list of active timers.  A check has already
;;;488    	been performed to ensure the list is not empty. */
;;;489    	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       uxListRemove
;;;490    	traceTIMER_EXPIRED( pxTimer );
;;;491    
;;;492    	/* If the timer is an auto reload timer then calculate the next
;;;493    	expiry time and re-insert the timer in the list of active timers. */
;;;494    	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
000014  f8940024          LDRB     r0,[r4,#0x24]
000018  f0000004          AND      r0,r0,#4
00001c  b188              CBZ      r0,|L6.66|
;;;495    	{
;;;496    		/* The timer is inserted into a list using a time relative to anything
;;;497    		other than the current time.  It will therefore be inserted into the
;;;498    		correct list relative to the time this task thinks it is now. */
;;;499    		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
00001e  69a0              LDR      r0,[r4,#0x18]
000020  1941              ADDS     r1,r0,r5
000022  462b              MOV      r3,r5
000024  4632              MOV      r2,r6
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       prvInsertTimerInActiveList
00002c  b178              CBZ      r0,|L6.78|
;;;500    		{
;;;501    			/* The timer expired before it was added to the active timer
;;;502    			list.  Reload it now.  */
;;;503    			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
00002e  2000              MOVS     r0,#0
000030  4603              MOV      r3,r0
000032  462a              MOV      r2,r5
000034  4601              MOV      r1,r0
000036  9000              STR      r0,[sp,#0]
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       xTimerGenericCommand
00003e  4607              MOV      r7,r0
;;;504    			configASSERT( xResult );
;;;505    			( void ) xResult;
000040  e005              B        |L6.78|
                  |L6.66|
;;;506    		}
;;;507    		else
;;;508    		{
;;;509    			mtCOVERAGE_TEST_MARKER();
;;;510    		}
;;;511    	}
;;;512    	else
;;;513    	{
;;;514    		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
000042  f8940024          LDRB     r0,[r4,#0x24]
000046  f0200001          BIC      r0,r0,#1
00004a  f8840024          STRB     r0,[r4,#0x24]
                  |L6.78|
;;;515    		mtCOVERAGE_TEST_MARKER();
;;;516    	}
;;;517    
;;;518    	/* Call the timer callback. */
;;;519    	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00004e  4620              MOV      r0,r4
000050  6a21              LDR      r1,[r4,#0x20]
000052  4788              BLX      r1
;;;520    }
000054  bdf8              POP      {r3-r7,pc}
;;;521    /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      pxCurrentTimerList

                          AREA ||i.prvProcessReceivedCommands||, CODE, READONLY, ALIGN=2

                  prvProcessReceivedCommands PROC
;;;708    
;;;709    static void	prvProcessReceivedCommands( void )
000000  b570              PUSH     {r4-r6,lr}
;;;710    {
000002  b086              SUB      sp,sp,#0x18
;;;711    DaemonTaskMessage_t xMessage;
;;;712    Timer_t *pxTimer;
;;;713    BaseType_t xTimerListsWereSwitched, xResult;
;;;714    TickType_t xTimeNow;
;;;715    
;;;716    	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
000004  e06d              B        |L7.226|
                  |L7.6|
;;;717    	{
;;;718    		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
;;;719    		{
;;;720    			/* Negative commands are pended function calls rather than timer
;;;721    			commands. */
;;;722    			if( xMessage.xMessageID < ( BaseType_t ) 0 )
;;;723    			{
;;;724    				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
;;;725    
;;;726    				/* The timer uses the xCallbackParameters member to request a
;;;727    				callback be executed.  Check the callback is not NULL. */
;;;728    				configASSERT( pxCallback );
;;;729    
;;;730    				/* Call the function. */
;;;731    				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
;;;732    			}
;;;733    			else
;;;734    			{
;;;735    				mtCOVERAGE_TEST_MARKER();
;;;736    			}
;;;737    		}
;;;738    		#endif /* INCLUDE_xTimerPendFunctionCall */
;;;739    
;;;740    		/* Commands that are positive are timer commands rather than pended
;;;741    		function calls. */
;;;742    		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
000006  9803              LDR      r0,[sp,#0xc]
000008  2800              CMP      r0,#0
00000a  db6a              BLT      |L7.226|
;;;743    		{
;;;744    			/* The messages uses the xTimerParameters member to work on a
;;;745    			software timer. */
;;;746    			pxTimer = xMessage.u.xTimerParameters.pxTimer;
00000c  9c05              LDR      r4,[sp,#0x14]
;;;747    
;;;748    			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
00000e  6960              LDR      r0,[r4,#0x14]
000010  b908              CBNZ     r0,|L7.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L7.24|
                  |L7.22|
000016  2000              MOVS     r0,#0
                  |L7.24|
000018  b910              CBNZ     r0,|L7.32|
;;;749    			{
;;;750    				/* The timer is in a list, remove it. */
;;;751    				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00001a  1d20              ADDS     r0,r4,#4
00001c  f7fffffe          BL       uxListRemove
                  |L7.32|
;;;752    			}
;;;753    			else
;;;754    			{
;;;755    				mtCOVERAGE_TEST_MARKER();
;;;756    			}
;;;757    
;;;758    			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
;;;759    
;;;760    			/* In this case the xTimerListsWereSwitched parameter is not used, but
;;;761    			it must be present in the function call.  prvSampleTimeNow() must be
;;;762    			called after the message is received from xTimerQueue so there is no
;;;763    			possibility of a higher priority task adding a message to the message
;;;764    			queue with a time that is ahead of the timer daemon task (because it
;;;765    			pre-empted the timer daemon task after the xTimeNow value was set). */
;;;766    			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       prvSampleTimeNow
000026  4605              MOV      r5,r0
;;;767    
;;;768    			switch( xMessage.xMessageID )
000028  9803              LDR      r0,[sp,#0xc]
00002a  280a              CMP      r0,#0xa
00002c  d257              BCS      |L7.222|
00002e  e8dff000          TBB      [pc,r0]
000032  0905              DCB      0x09,0x05
000034  072d3546          DCB      0x07,0x2d,0x35,0x46
000038  06082e36          DCB      0x06,0x08,0x2e,0x36
;;;769    			{
;;;770    				case tmrCOMMAND_START :
;;;771    				case tmrCOMMAND_START_FROM_ISR :
00003c  bf00              NOP      
;;;772    				case tmrCOMMAND_RESET :
00003e  bf00              NOP      
;;;773    				case tmrCOMMAND_RESET_FROM_ISR :
000040  bf00              NOP      
;;;774    				case tmrCOMMAND_START_DONT_TRACE :
000042  bf00              NOP      
;;;775    					/* Start or restart a timer. */
;;;776    					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
000044  f8940024          LDRB     r0,[r4,#0x24]
000048  f0400001          ORR      r0,r0,#1
00004c  f8840024          STRB     r0,[r4,#0x24]
;;;777    					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
000050  9804              LDR      r0,[sp,#0x10]
000052  69a2              LDR      r2,[r4,#0x18]
000054  1881              ADDS     r1,r0,r2
000056  4603              MOV      r3,r0
000058  462a              MOV      r2,r5
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       prvInsertTimerInActiveList
000060  b198              CBZ      r0,|L7.138|
;;;778    					{
;;;779    						/* The timer expired before it was added to the active
;;;780    						timer list.  Process it now. */
;;;781    						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
000062  4620              MOV      r0,r4
000064  6a21              LDR      r1,[r4,#0x20]
000066  4788              BLX      r1
;;;782    						traceTIMER_EXPIRED( pxTimer );
;;;783    
;;;784    						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
000068  f8940024          LDRB     r0,[r4,#0x24]
00006c  f0000004          AND      r0,r0,#4
000070  b158              CBZ      r0,|L7.138|
;;;785    						{
;;;786    							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
000072  2000              MOVS     r0,#0
000074  9000              STR      r0,[sp,#0]
000076  9804              LDR      r0,[sp,#0x10]
000078  69a1              LDR      r1,[r4,#0x18]
00007a  1842              ADDS     r2,r0,r1
00007c  2300              MOVS     r3,#0
00007e  4619              MOV      r1,r3
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       xTimerGenericCommand
000086  4606              MOV      r6,r0
;;;787    							configASSERT( xResult );
;;;788    							( void ) xResult;
000088  bf00              NOP      
                  |L7.138|
;;;789    						}
;;;790    						else
;;;791    						{
;;;792    							mtCOVERAGE_TEST_MARKER();
;;;793    						}
;;;794    					}
;;;795    					else
;;;796    					{
;;;797    						mtCOVERAGE_TEST_MARKER();
;;;798    					}
;;;799    					break;
00008a  e029              B        |L7.224|
;;;800    
;;;801    				case tmrCOMMAND_STOP :
;;;802    				case tmrCOMMAND_STOP_FROM_ISR :
00008c  bf00              NOP      
;;;803    					/* The timer has already been removed from the active list. */
;;;804    					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
00008e  f8940024          LDRB     r0,[r4,#0x24]
000092  f0200001          BIC      r0,r0,#1
000096  f8840024          STRB     r0,[r4,#0x24]
;;;805    					break;
00009a  e021              B        |L7.224|
;;;806    
;;;807    				case tmrCOMMAND_CHANGE_PERIOD :
;;;808    				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
00009c  bf00              NOP      
;;;809    					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
00009e  f8940024          LDRB     r0,[r4,#0x24]
0000a2  f0400001          ORR      r0,r0,#1
0000a6  f8840024          STRB     r0,[r4,#0x24]
;;;810    					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
0000aa  9804              LDR      r0,[sp,#0x10]
0000ac  61a0              STR      r0,[r4,#0x18]
;;;811    					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
;;;812    
;;;813    					/* The new period does not really have a reference, and can
;;;814    					be longer or shorter than the old one.  The command time is
;;;815    					therefore set to the current time, and as the period cannot
;;;816    					be zero the next expiry time can only be in the future,
;;;817    					meaning (unlike for the xTimerStart() case above) there is
;;;818    					no fail case that needs to be handled here. */
;;;819    					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
0000ae  69a0              LDR      r0,[r4,#0x18]
0000b0  1941              ADDS     r1,r0,r5
0000b2  462b              MOV      r3,r5
0000b4  462a              MOV      r2,r5
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       prvInsertTimerInActiveList
;;;820    					break;
0000bc  e010              B        |L7.224|
;;;821    
;;;822    				case tmrCOMMAND_DELETE :
;;;823    					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;824    					{
;;;825    						/* The timer has already been removed from the active list,
;;;826    						just free up the memory if the memory was dynamically
;;;827    						allocated. */
;;;828    						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
0000be  f8940024          LDRB     r0,[r4,#0x24]
0000c2  f0000002          AND      r0,r0,#2
0000c6  b918              CBNZ     r0,|L7.208|
;;;829    						{
;;;830    							vPortFree( pxTimer );
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       vPortFree
0000ce  e005              B        |L7.220|
                  |L7.208|
;;;831    						}
;;;832    						else
;;;833    						{
;;;834    							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
0000d0  f8940024          LDRB     r0,[r4,#0x24]
0000d4  f0200001          BIC      r0,r0,#1
0000d8  f8840024          STRB     r0,[r4,#0x24]
                  |L7.220|
;;;835    						}
;;;836    					}
;;;837    					#else
;;;838    					{
;;;839    						/* If dynamic allocation is not enabled, the memory
;;;840    						could not have been dynamically allocated. So there is
;;;841    						no need to free the memory - just mark the timer as
;;;842    						"not active". */
;;;843    						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
;;;844    					}
;;;845    					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;846    					break;
0000dc  e000              B        |L7.224|
                  |L7.222|
;;;847    
;;;848    				default	:
;;;849    					/* Don't expect to get here. */
;;;850    					break;
0000de  bf00              NOP      
                  |L7.224|
0000e0  bf00              NOP                            ;799
                  |L7.226|
0000e2  2200              MOVS     r2,#0                 ;716
0000e4  a903              ADD      r1,sp,#0xc            ;716
0000e6  4804              LDR      r0,|L7.248|
0000e8  6800              LDR      r0,[r0,#0]            ;716  ; xTimerQueue
0000ea  f7fffffe          BL       xQueueReceive
0000ee  2800              CMP      r0,#0                 ;716
0000f0  d189              BNE      |L7.6|
;;;851    			}
;;;852    		}
;;;853    	}
;;;854    }
0000f2  b006              ADD      sp,sp,#0x18
0000f4  bd70              POP      {r4-r6,pc}
;;;855    /*-----------------------------------------------------------*/
                          ENDP

0000f6  0000              DCW      0x0000
                  |L7.248|
                          DCD      xTimerQueue

                          AREA ||i.prvProcessTimerOrBlockTask||, CODE, READONLY, ALIGN=2

                  prvProcessTimerOrBlockTask PROC
;;;558    
;;;559    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
000000  b5f8              PUSH     {r3-r7,lr}
;;;560    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;561    TickType_t xTimeNow;
;;;562    BaseType_t xTimerListsWereSwitched;
;;;563    
;;;564    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;565    	{
;;;566    		/* Obtain the time now to make an assessment as to whether the timer
;;;567    		has expired or not.  If obtaining the time causes the lists to switch
;;;568    		then don't process this timer as any timers that remained in the list
;;;569    		when the lists were switched will have been processed within the
;;;570    		prvSampleTimeNow() function. */
;;;571    		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       prvSampleTimeNow
000010  4606              MOV      r6,r0
;;;572    		if( xTimerListsWereSwitched == pdFALSE )
000012  9800              LDR      r0,[sp,#0]
000014  bb20              CBNZ     r0,|L8.96|
;;;573    		{
;;;574    			/* The tick count has not overflowed, has the timer expired? */
;;;575    			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
000016  b944              CBNZ     r4,|L8.42|
000018  42b5              CMP      r5,r6
00001a  d806              BHI      |L8.42|
;;;576    			{
;;;577    				( void ) xTaskResumeAll();
00001c  f7fffffe          BL       xTaskResumeAll
;;;578    				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       prvProcessExpiredTimer
000028  e01c              B        |L8.100|
                  |L8.42|
;;;579    			}
;;;580    			else
;;;581    			{
;;;582    				/* The tick count has not overflowed, and the next expire
;;;583    				time has not been reached yet.  This task should therefore
;;;584    				block to wait for the next expire time or a command to be
;;;585    				received - whichever comes first.  The following line cannot
;;;586    				be reached unless xNextExpireTime > xTimeNow, except in the
;;;587    				case when the current timer list is empty. */
;;;588    				if( xListWasEmpty != pdFALSE )
00002a  b13c              CBZ      r4,|L8.60|
;;;589    				{
;;;590    					/* The current timer list is empty - is the overflow list
;;;591    					also empty? */
;;;592    					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
00002c  480e              LDR      r0,|L8.104|
00002e  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000030  6800              LDR      r0,[r0,#0]
000032  b908              CBNZ     r0,|L8.56|
000034  2001              MOVS     r0,#1
000036  e000              B        |L8.58|
                  |L8.56|
000038  2000              MOVS     r0,#0
                  |L8.58|
00003a  4604              MOV      r4,r0
                  |L8.60|
;;;593    				}
;;;594    
;;;595    				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
00003c  1ba9              SUBS     r1,r5,r6
00003e  4622              MOV      r2,r4
000040  480a              LDR      r0,|L8.108|
000042  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000044  f7fffffe          BL       vQueueWaitForMessageRestricted
;;;596    
;;;597    				if( xTaskResumeAll() == pdFALSE )
000048  f7fffffe          BL       xTaskResumeAll
00004c  b950              CBNZ     r0,|L8.100|
;;;598    				{
;;;599    					/* Yield to wait for either a command to arrive, or the
;;;600    					block time to expire.  If a command arrived between the
;;;601    					critical section being exited and this yield then the yield
;;;602    					will not cause the task to block. */
;;;603    					portYIELD_WITHIN_API();
00004e  f04f5080          MOV      r0,#0x10000000
000052  4907              LDR      r1,|L8.112|
000054  6008              STR      r0,[r1,#0]
000056  f3bf8f4f          DSB      
00005a  f3bf8f6f          ISB      
00005e  e001              B        |L8.100|
                  |L8.96|
;;;604    				}
;;;605    				else
;;;606    				{
;;;607    					mtCOVERAGE_TEST_MARKER();
;;;608    				}
;;;609    			}
;;;610    		}
;;;611    		else
;;;612    		{
;;;613    			( void ) xTaskResumeAll();
000060  f7fffffe          BL       xTaskResumeAll
                  |L8.100|
;;;614    		}
;;;615    	}
;;;616    }
000064  bdf8              POP      {r3-r7,pc}
;;;617    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      pxOverflowTimerList
                  |L8.108|
                          DCD      xTimerQueue
                  |L8.112|
                          DCD      0xe000ed04

                          AREA ||i.prvSampleTimeNow||, CODE, READONLY, ALIGN=2

                  prvSampleTimeNow PROC
;;;644    
;;;645    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
000000  b570              PUSH     {r4-r6,lr}
;;;646    {
000002  4604              MOV      r4,r0
;;;647    TickType_t xTimeNow;
;;;648    PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
;;;649    
;;;650    	xTimeNow = xTaskGetTickCount();
000004  f7fffffe          BL       xTaskGetTickCount
000008  4605              MOV      r5,r0
;;;651    
;;;652    	if( xTimeNow < xLastTime )
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]  ; xLastTime
00000e  4285              CMP      r5,r0
000010  d204              BCS      |L9.28|
;;;653    	{
;;;654    		prvSwitchTimerLists();
000012  f7fffffe          BL       prvSwitchTimerLists
;;;655    		*pxTimerListsWereSwitched = pdTRUE;
000016  2001              MOVS     r0,#1
000018  6020              STR      r0,[r4,#0]
00001a  e001              B        |L9.32|
                  |L9.28|
;;;656    	}
;;;657    	else
;;;658    	{
;;;659    		*pxTimerListsWereSwitched = pdFALSE;
00001c  2000              MOVS     r0,#0
00001e  6020              STR      r0,[r4,#0]
                  |L9.32|
;;;660    	}
;;;661    
;;;662    	xLastTime = xTimeNow;
000020  4801              LDR      r0,|L9.40|
000022  6005              STR      r5,[r0,#0]  ; xLastTime
;;;663    
;;;664    	return xTimeNow;
000024  4628              MOV      r0,r5
;;;665    }
000026  bd70              POP      {r4-r6,pc}
;;;666    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.40|
                          DCD      xLastTime

                          AREA ||i.prvSwitchTimerLists||, CODE, READONLY, ALIGN=2

                  prvSwitchTimerLists PROC
;;;856    
;;;857    static void prvSwitchTimerLists( void )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;858    {
;;;859    TickType_t xNextExpireTime, xReloadTime;
;;;860    List_t *pxTemp;
;;;861    Timer_t *pxTimer;
;;;862    BaseType_t xResult;
;;;863    
;;;864    	/* The tick count has overflowed.  The timer lists must be switched.
;;;865    	If there are any timers still referenced from the current timer list
;;;866    	then they must have expired and should be processed before the lists
;;;867    	are switched. */
;;;868    	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
000004  e028              B        |L10.88|
                  |L10.6|
;;;869    	{
;;;870    		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
000006  481e              LDR      r0,|L10.128|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  6805              LDR      r5,[r0,#0]
;;;871    
;;;872    		/* Remove the timer from the list. */
;;;873    		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
00000e  481c              LDR      r0,|L10.128|
000010  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
000012  68c0              LDR      r0,[r0,#0xc]
000014  68c4              LDR      r4,[r0,#0xc]
;;;874    		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;875    		traceTIMER_EXPIRED( pxTimer );
;;;876    
;;;877    		/* Execute its callback, then send a command to restart the timer if
;;;878    		it is an auto-reload timer.  It cannot be restarted here as the lists
;;;879    		have not yet been switched. */
;;;880    		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
00001c  4620              MOV      r0,r4
00001e  6a21              LDR      r1,[r4,#0x20]
000020  4788              BLX      r1
;;;881    
;;;882    		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
000022  f8940024          LDRB     r0,[r4,#0x24]
000026  f0000004          AND      r0,r0,#4
00002a  b1a8              CBZ      r0,|L10.88|
;;;883    		{
;;;884    			/* Calculate the reload value, and if the reload value results in
;;;885    			the timer going into the same timer list then it has already expired
;;;886    			and the timer should be re-inserted into the current list so it is
;;;887    			processed again within this loop.  Otherwise a command should be sent
;;;888    			to restart the timer to ensure it is only inserted into a list after
;;;889    			the lists have been swapped. */
;;;890    			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
00002c  69a0              LDR      r0,[r4,#0x18]
00002e  1946              ADDS     r6,r0,r5
;;;891    			if( xReloadTime > xNextExpireTime )
000030  42ae              CMP      r6,r5
000032  d907              BLS      |L10.68|
;;;892    			{
;;;893    				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
000034  6066              STR      r6,[r4,#4]
;;;894    				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
000036  6124              STR      r4,[r4,#0x10]
;;;895    				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
000038  1d21              ADDS     r1,r4,#4
00003a  4811              LDR      r0,|L10.128|
00003c  6800              LDR      r0,[r0,#0]  ; pxCurrentTimerList
00003e  f7fffffe          BL       vListInsert
000042  e009              B        |L10.88|
                  |L10.68|
;;;896    			}
;;;897    			else
;;;898    			{
;;;899    				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
000044  2000              MOVS     r0,#0
000046  4603              MOV      r3,r0
000048  462a              MOV      r2,r5
00004a  4601              MOV      r1,r0
00004c  9000              STR      r0,[sp,#0]
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       xTimerGenericCommand
000054  4680              MOV      r8,r0
;;;900    				configASSERT( xResult );
;;;901    				( void ) xResult;
000056  bf00              NOP      
                  |L10.88|
000058  4809              LDR      r0,|L10.128|
00005a  6800              LDR      r0,[r0,#0]            ;868  ; pxCurrentTimerList
00005c  6800              LDR      r0,[r0,#0]            ;868
00005e  b908              CBNZ     r0,|L10.100|
000060  2001              MOVS     r0,#1                 ;868
000062  e000              B        |L10.102|
                  |L10.100|
000064  2000              MOVS     r0,#0                 ;868
                  |L10.102|
000066  2800              CMP      r0,#0                 ;868
000068  d0cd              BEQ      |L10.6|
;;;902    			}
;;;903    		}
;;;904    		else
;;;905    		{
;;;906    			mtCOVERAGE_TEST_MARKER();
;;;907    		}
;;;908    	}
;;;909    
;;;910    	pxTemp = pxCurrentTimerList;
00006a  4805              LDR      r0,|L10.128|
00006c  6807              LDR      r7,[r0,#0]  ; pxCurrentTimerList
;;;911    	pxCurrentTimerList = pxOverflowTimerList;
00006e  4805              LDR      r0,|L10.132|
000070  6800              LDR      r0,[r0,#0]  ; pxOverflowTimerList
000072  4903              LDR      r1,|L10.128|
000074  6008              STR      r0,[r1,#0]  ; pxCurrentTimerList
;;;912    	pxOverflowTimerList = pxTemp;
000076  4803              LDR      r0,|L10.132|
000078  6007              STR      r7,[r0,#0]  ; pxOverflowTimerList
;;;913    }
00007a  e8bd83f8          POP      {r3-r9,pc}
;;;914    /*-----------------------------------------------------------*/
                          ENDP

00007e  0000              DCW      0x0000
                  |L10.128|
                          DCD      pxCurrentTimerList
                  |L10.132|
                          DCD      pxOverflowTimerList

                          AREA ||i.prvTimerTask||, CODE, READONLY, ALIGN=1

                  prvTimerTask PROC
;;;522    
;;;523    static portTASK_FUNCTION( prvTimerTask, pvParameters )
000000  b508              PUSH     {r3,lr}
;;;524    {
;;;525    TickType_t xNextExpireTime;
;;;526    BaseType_t xListWasEmpty;
;;;527    
;;;528    	/* Just to avoid compiler warnings. */
;;;529    	( void ) pvParameters;
;;;530    
;;;531    	#if( configUSE_DAEMON_TASK_STARTUP_HOOK == 1 )
;;;532    	{
;;;533    		extern void vApplicationDaemonTaskStartupHook( void );
;;;534    
;;;535    		/* Allow the application writer to execute some code in the context of
;;;536    		this task at the point the task starts executing.  This is useful if the
;;;537    		application includes initialisation code that would benefit from
;;;538    		executing after the scheduler has been started. */
;;;539    		vApplicationDaemonTaskStartupHook();
;;;540    	}
;;;541    	#endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */
;;;542    
;;;543    	for( ;; )
000002  bf00              NOP      
                  |L11.4|
;;;544    	{
;;;545    		/* Query the timers list to see if it contains any timers, and if so,
;;;546    		obtain the time at which the next timer will expire. */
;;;547    		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       prvGetNextExpireTime
00000a  4604              MOV      r4,r0
;;;548    
;;;549    		/* If a timer has expired, process it.  Otherwise, block this task
;;;550    		until either a timer does expire, or a command is received. */
;;;551    		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
00000c  4620              MOV      r0,r4
00000e  9900              LDR      r1,[sp,#0]
000010  f7fffffe          BL       prvProcessTimerOrBlockTask
;;;552    
;;;553    		/* Empty the command queue. */
;;;554    		prvProcessReceivedCommands();
000014  f7fffffe          BL       prvProcessReceivedCommands
000018  e7f4              B        |L11.4|
;;;555    	}
;;;556    }
;;;557    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pvTimerGetTimerID||, CODE, READONLY, ALIGN=1

                  pvTimerGetTimerID PROC
;;;991    
;;;992    void *pvTimerGetTimerID( const TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;993    {
000002  4604              MOV      r4,r0
;;;994    Timer_t * const pxTimer = xTimer;
000004  4626              MOV      r6,r4
;;;995    void *pvReturn;
;;;996    
;;;997    	configASSERT( xTimer );
;;;998    
;;;999    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1000   	{
;;;1001   		pvReturn = pxTimer->pvTimerID;
00000a  69f5              LDR      r5,[r6,#0x1c]
;;;1002   	}
;;;1003   	taskEXIT_CRITICAL();
00000c  f7fffffe          BL       vPortExitCritical
;;;1004   
;;;1005   	return pvReturn;
000010  4628              MOV      r0,r5
;;;1006   }
000012  bd70              POP      {r4-r6,pc}
;;;1007   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetReloadMode||, CODE, READONLY, ALIGN=1

                  vTimerSetReloadMode PROC
;;;441    
;;;442    void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;444    Timer_t * pxTimer =  xTimer;
000006  4634              MOV      r4,r6
;;;445    
;;;446    	configASSERT( xTimer );
;;;447    	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;448    	{
;;;449    		if( uxAutoReload != pdFALSE )
00000c  b135              CBZ      r5,|L13.28|
;;;450    		{
;;;451    			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
00000e  f8940024          LDRB     r0,[r4,#0x24]
000012  f0400004          ORR      r0,r0,#4
000016  f8840024          STRB     r0,[r4,#0x24]
00001a  e005              B        |L13.40|
                  |L13.28|
;;;452    		}
;;;453    		else
;;;454    		{
;;;455    			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
00001c  f8940024          LDRB     r0,[r4,#0x24]
000020  f0200004          BIC      r0,r0,#4
000024  f8840024          STRB     r0,[r4,#0x24]
                  |L13.40|
;;;456    		}
;;;457    	}
;;;458    	taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;459    }
00002c  bd70              POP      {r4-r6,pc}
;;;460    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vTimerSetTimerID||, CODE, READONLY, ALIGN=1

                  vTimerSetTimerID PROC
;;;1008   
;;;1009   void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
000000  b570              PUSH     {r4-r6,lr}
;;;1010   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1011   Timer_t * const pxTimer = xTimer;
000006  4626              MOV      r6,r4
;;;1012   
;;;1013   	configASSERT( xTimer );
;;;1014   
;;;1015   	taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;1016   	{
;;;1017   		pxTimer->pvTimerID = pvNewID;
00000c  61f5              STR      r5,[r6,#0x1c]
;;;1018   	}
;;;1019   	taskEXIT_CRITICAL();
00000e  f7fffffe          BL       vPortExitCritical
;;;1020   }
000012  bd70              POP      {r4-r6,pc}
;;;1021   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerCreate||, CODE, READONLY, ALIGN=1

                  xTimerCreate PROC
;;;281    
;;;282    	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;283    								const TickType_t xTimerPeriodInTicks,
;;;284    								const UBaseType_t uxAutoReload,
;;;285    								void * const pvTimerID,
;;;286    								TimerCallbackFunction_t pxCallbackFunction )
;;;287    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;288    	Timer_t *pxNewTimer;
;;;289    
;;;290    		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
000010  2028              MOVS     r0,#0x28
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;291    
;;;292    		if( pxNewTimer != NULL )
000018  b154              CBZ      r4,|L15.48|
;;;293    		{
;;;294    			/* Status is thus far zero as the timer is not created statically
;;;295    			and has not been started.  The autoreload bit may get set in
;;;296    			prvInitialiseNewTimer. */
;;;297    			pxNewTimer->ucStatus = 0x00;
00001a  2000              MOVS     r0,#0
00001c  f8840024          STRB     r0,[r4,#0x24]
;;;298    			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
000020  4643              MOV      r3,r8
000022  463a              MOV      r2,r7
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  e9cd9400          STRD     r9,r4,[sp,#0]
00002c  f7fffffe          BL       prvInitialiseNewTimer
                  |L15.48|
;;;299    		}
;;;300    
;;;301    		return pxNewTimer;
000030  4620              MOV      r0,r4
;;;302    	}
000032  e8bd87fc          POP      {r2-r10,pc}
;;;303    
                          ENDP


                          AREA ||i.xTimerCreateTimerTask||, CODE, READONLY, ALIGN=2

                  xTimerCreateTimerTask PROC
;;;226    
;;;227    BaseType_t xTimerCreateTimerTask( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;228    {
;;;229    BaseType_t xReturn = pdFAIL;
000002  2400              MOVS     r4,#0
;;;230    
;;;231    	/* This function is called when the scheduler is started if
;;;232    	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
;;;233    	timer service task has been created/initialised.  If timers have already
;;;234    	been created then the initialisation will already have been performed. */
;;;235    	prvCheckForValidListAndQueue();
000004  f7fffffe          BL       prvCheckForValidListAndQueue
;;;236    
;;;237    	if( xTimerQueue != NULL )
000008  4807              LDR      r0,|L16.40|
00000a  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00000c  b150              CBZ      r0,|L16.36|
;;;238    	{
;;;239    		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;240    		{
;;;241    			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
;;;242    			StackType_t *pxTimerTaskStackBuffer = NULL;
;;;243    			uint32_t ulTimerTaskStackSize;
;;;244    
;;;245    			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
;;;246    			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
;;;247    													configTIMER_SERVICE_TASK_NAME,
;;;248    													ulTimerTaskStackSize,
;;;249    													NULL,
;;;250    													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;251    													pxTimerTaskStackBuffer,
;;;252    													pxTimerTaskTCBBuffer );
;;;253    
;;;254    			if( xTimerTaskHandle != NULL )
;;;255    			{
;;;256    				xReturn = pdPASS;
;;;257    			}
;;;258    		}
;;;259    		#else
;;;260    		{
;;;261    			xReturn = xTaskCreate(	prvTimerTask,
00000e  4807              LDR      r0,|L16.44|
000010  2102              MOVS     r1,#2
000012  2300              MOVS     r3,#0
000014  020a              LSLS     r2,r1,#8
000016  e9cd1000          STRD     r1,r0,[sp,#0]
00001a  a105              ADR      r1,|L16.48|
00001c  4806              LDR      r0,|L16.56|
00001e  f7fffffe          BL       xTaskCreate
000022  4604              MOV      r4,r0
                  |L16.36|
;;;262    									configTIMER_SERVICE_TASK_NAME,
;;;263    									configTIMER_TASK_STACK_DEPTH,
;;;264    									NULL,
;;;265    									( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
;;;266    									&xTimerTaskHandle );
;;;267    		}
;;;268    		#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;269    	}
;;;270    	else
;;;271    	{
;;;272    		mtCOVERAGE_TEST_MARKER();
;;;273    	}
;;;274    
;;;275    	configASSERT( xReturn );
;;;276    	return xReturn;
000024  4620              MOV      r0,r4
;;;277    }
000026  bd1c              POP      {r2-r4,pc}
;;;278    /*-----------------------------------------------------------*/
                          ENDP

                  |L16.40|
                          DCD      xTimerQueue
                  |L16.44|
                          DCD      xTimerTaskHandle
                  |L16.48|
000030  546d7220          DCB      "Tmr Svc",0
000034  53766300
                  |L16.56|
                          DCD      prvTimerTask

                          AREA ||i.xTimerGenericCommand||, CODE, READONLY, ALIGN=2

                  xTimerGenericCommand PROC
;;;380    
;;;381    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;382    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;383    BaseType_t xReturn = pdFAIL;
000010  f04f0900          MOV      r9,#0
;;;384    DaemonTaskMessage_t xMessage;
;;;385    
;;;386    	configASSERT( xTimer );
;;;387    
;;;388    	/* Send a message to the timer service task to perform a particular action
;;;389    	on a particular timer definition. */
;;;390    	if( xTimerQueue != NULL )
000014  4814              LDR      r0,|L17.104|
000016  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000018  b310              CBZ      r0,|L17.96|
;;;391    	{
;;;392    		/* Send a command to the timer service task to start the xTimer timer. */
;;;393    		xMessage.xMessageID = xCommandID;
00001a  9400              STR      r4,[sp,#0]
;;;394    		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
00001c  9601              STR      r6,[sp,#4]
;;;395    		xMessage.u.xTimerParameters.pxTimer = xTimer;
00001e  9502              STR      r5,[sp,#8]
;;;396    
;;;397    		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
000020  2c06              CMP      r4,#6
000022  da15              BGE      |L17.80|
;;;398    		{
;;;399    			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
000024  f7fffffe          BL       xTaskGetSchedulerState
000028  2802              CMP      r0,#2
00002a  d108              BNE      |L17.62|
;;;400    			{
;;;401    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
00002c  2300              MOVS     r3,#0
00002e  4642              MOV      r2,r8
000030  4669              MOV      r1,sp
000032  480d              LDR      r0,|L17.104|
000034  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000036  f7fffffe          BL       xQueueGenericSend
00003a  4681              MOV      r9,r0
00003c  e010              B        |L17.96|
                  |L17.62|
;;;402    			}
;;;403    			else
;;;404    			{
;;;405    				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
00003e  2300              MOVS     r3,#0
000040  461a              MOV      r2,r3
000042  4669              MOV      r1,sp
000044  4808              LDR      r0,|L17.104|
000046  6800              LDR      r0,[r0,#0]  ; xTimerQueue
000048  f7fffffe          BL       xQueueGenericSend
00004c  4681              MOV      r9,r0
00004e  e007              B        |L17.96|
                  |L17.80|
;;;406    			}
;;;407    		}
;;;408    		else
;;;409    		{
;;;410    			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
000050  2300              MOVS     r3,#0
000052  463a              MOV      r2,r7
000054  4669              MOV      r1,sp
000056  4804              LDR      r0,|L17.104|
000058  6800              LDR      r0,[r0,#0]  ; xTimerQueue
00005a  f7fffffe          BL       xQueueGenericSendFromISR
00005e  4681              MOV      r9,r0
                  |L17.96|
;;;411    		}
;;;412    
;;;413    		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
;;;414    	}
;;;415    	else
;;;416    	{
;;;417    		mtCOVERAGE_TEST_MARKER();
;;;418    	}
;;;419    
;;;420    	return xReturn;
000060  4648              MOV      r0,r9
;;;421    }
000062  e8bd83fe          POP      {r1-r9,pc}
;;;422    /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L17.104|
                          DCD      xTimerQueue

                          AREA ||i.xTimerGetExpiryTime||, CODE, READONLY, ALIGN=1

                  xTimerGetExpiryTime PROC
;;;461    
;;;462    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
000000  4601              MOV      r1,r0
;;;463    {
;;;464    Timer_t * pxTimer =  xTimer;
000002  460a              MOV      r2,r1
;;;465    TickType_t xReturn;
;;;466    
;;;467    	configASSERT( xTimer );
;;;468    	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
000004  6850              LDR      r0,[r2,#4]
;;;469    	return xReturn;
;;;470    }
000006  4770              BX       lr
;;;471    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetPeriod||, CODE, READONLY, ALIGN=1

                  xTimerGetPeriod PROC
;;;432    
;;;433    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
000000  4601              MOV      r1,r0
;;;434    {
;;;435    Timer_t *pxTimer = xTimer;
000002  460a              MOV      r2,r1
;;;436    
;;;437    	configASSERT( xTimer );
;;;438    	return pxTimer->xTimerPeriodInTicks;
000004  6990              LDR      r0,[r2,#0x18]
;;;439    }
000006  4770              BX       lr
;;;440    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xTimerGetTimerDaemonTaskHandle||, CODE, READONLY, ALIGN=2

                  xTimerGetTimerDaemonTaskHandle PROC
;;;423    
;;;424    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
000000  4801              LDR      r0,|L20.8|
;;;425    {
;;;426    	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
;;;427    	started, then xTimerTaskHandle will be NULL. */
;;;428    	configASSERT( ( xTimerTaskHandle != NULL ) );
;;;429    	return xTimerTaskHandle;
000002  6800              LDR      r0,[r0,#0]  ; xTimerTaskHandle
;;;430    }
000004  4770              BX       lr
;;;431    /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      xTimerTaskHandle

                          AREA ||i.xTimerIsTimerActive||, CODE, READONLY, ALIGN=1

                  xTimerIsTimerActive PROC
;;;966    
;;;967    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
000000  b570              PUSH     {r4-r6,lr}
;;;968    {
000002  4604              MOV      r4,r0
;;;969    BaseType_t xReturn;
;;;970    Timer_t *pxTimer = xTimer;
000004  4626              MOV      r6,r4
;;;971    
;;;972    	configASSERT( xTimer );
;;;973    
;;;974    	/* Is the timer in the list of active timers? */
;;;975    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;976    	{
;;;977    		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
00000a  f8960024          LDRB     r0,[r6,#0x24]
00000e  f0000001          AND      r0,r0,#1
000012  b908              CBNZ     r0,|L21.24|
;;;978    		{
;;;979    			xReturn = pdFALSE;
000014  2500              MOVS     r5,#0
000016  e000              B        |L21.26|
                  |L21.24|
;;;980    		}
;;;981    		else
;;;982    		{
;;;983    			xReturn = pdTRUE;
000018  2501              MOVS     r5,#1
                  |L21.26|
;;;984    		}
;;;985    	}
;;;986    	taskEXIT_CRITICAL();
00001a  f7fffffe          BL       vPortExitCritical
;;;987    
;;;988    	return xReturn;
00001e  4628              MOV      r0,r5
;;;989    } /*lint !e818 Can't be pointer to const due to the typedef. */
000020  bd70              POP      {r4-r6,pc}
;;;990    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xActiveTimerList1
                          %        20
                  xActiveTimerList2
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTimerList
                          DCD      0x00000000
                  pxOverflowTimerList
                          DCD      0x00000000
                  xTimerQueue
                          DCD      0x00000000
                  xTimerTaskHandle
                          DCD      0x00000000
                  xLastTime
                          DCD      0x00000000
