; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\os_task.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\os_task.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Libraries\CMSIS\CM3\CoreSupport -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I.\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I.\Libraries\STM32F10x_StdPeriph_Driver\inc -I.\main -I.\User -I.\User\include -I.\fatfs -I.\Utilities\STM32_EVAL -I.\Utilities\STM32_EVAL\Common -I.\Utilities\STM32_EVAL\STM3210E_EVAL -I.\UCOSII\CORE -I.\UCOSII\PORTS -I.\UCOSII\CONFIG -I.\RTE\_Target_1 -I"D:\program files (x86)\keil5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include" -I"D:\program files (x86)\keil5\ARM\CMSIS\Include" -D__UVISION_VERSION=523 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DUSE_STM3210E_EVAL --omf_browse=.\objects\os_task.crf UCOSII\CORE\os_task.c]
                          THUMB

                          AREA ||i.OSTaskChangePrio||, CODE, READONLY, ALIGN=2

                  OSTaskChangePrio PROC
;;;52     #if OS_TASK_CHANGE_PRIO_EN > 0u
;;;53     INT8U  OSTaskChangePrio (INT8U  oldprio,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;54                              INT8U  newprio)
;;;55     {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
;;;56     #if (OS_EVENT_EN)
;;;57         OS_EVENT  *pevent;
;;;58     #if (OS_EVENT_MULTI_EN > 0u)
;;;59         OS_EVENT **pevents;
;;;60     #endif
;;;61     #endif
;;;62         OS_TCB    *ptcb;
;;;63         INT8U      y_new;
;;;64         INT8U      x_new;
;;;65         INT8U      y_old;
;;;66         OS_PRIO    bity_new;
;;;67         OS_PRIO    bitx_new;
;;;68         OS_PRIO    bity_old;
;;;69         OS_PRIO    bitx_old;
;;;70     #if OS_CRITICAL_METHOD == 3u
;;;71         OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;72     #endif
;;;73     
;;;74     
;;;75     /*$PAGE*/
;;;76     #if OS_ARG_CHK_EN > 0u
;;;77         if (oldprio >= OS_LOWEST_PRIO) {
;;;78             if (oldprio != OS_PRIO_SELF) {
;;;79                 return (OS_ERR_PRIO_INVALID);
;;;80             }
;;;81         }
;;;82         if (newprio >= OS_LOWEST_PRIO) {
;;;83             return (OS_ERR_PRIO_INVALID);
;;;84         }
;;;85     #endif
;;;86         OS_ENTER_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Save
000010  9000              STR      r0,[sp,#0]
;;;87         if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
000012  4848              LDR      r0,|L1.308|
000014  f8500028          LDR      r0,[r0,r8,LSL #2]
000018  b130              CBZ      r0,|L1.40|
;;;88             OS_EXIT_CRITICAL();
00001a  9800              LDR      r0,[sp,#0]
00001c  f7fffffe          BL       OS_CPU_SR_Restore
;;;89             return (OS_ERR_PRIO_EXIST);
000020  2028              MOVS     r0,#0x28
                  |L1.34|
;;;90         }
;;;91         if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
;;;92             oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
;;;93         }
;;;94         ptcb = OSTCBPrioTbl[oldprio];
;;;95         if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
;;;96             OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
;;;97             return (OS_ERR_PRIO);
;;;98         }
;;;99         if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
;;;100            OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
;;;101            return (OS_ERR_TASK_NOT_EXIST);
;;;102        }
;;;103    #if OS_LOWEST_PRIO <= 63u
;;;104        y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
;;;105        x_new                 = (INT8U)(newprio & 0x07u);
;;;106    #else
;;;107        y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
;;;108        x_new                 = (INT8U)(newprio & 0x0Fu);
;;;109    #endif
;;;110        bity_new              = (OS_PRIO)(1uL << y_new);
;;;111        bitx_new              = (OS_PRIO)(1uL << x_new);
;;;112    
;;;113        OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
;;;114        OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
;;;115        y_old                 =  ptcb->OSTCBY;
;;;116        bity_old              =  ptcb->OSTCBBitY;
;;;117        bitx_old              =  ptcb->OSTCBBitX;
;;;118        if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
;;;119             OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
;;;120             if (OSRdyTbl[y_old] == 0u) {
;;;121                 OSRdyGrp &= (OS_PRIO)~bity_old;
;;;122             }
;;;123             OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
;;;124             OSRdyTbl[y_new] |= bitx_new;
;;;125        }
;;;126    
;;;127    #if (OS_EVENT_EN)
;;;128        pevent = ptcb->OSTCBEventPtr;
;;;129        if (pevent != (OS_EVENT *)0) {
;;;130            pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
;;;131            if (pevent->OSEventTbl[y_old] == 0u) {
;;;132                pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
;;;133            }
;;;134            pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
;;;135            pevent->OSEventTbl[y_new] |= bitx_new;
;;;136        }
;;;137    #if (OS_EVENT_MULTI_EN > 0u)
;;;138        if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
;;;139            pevents =  ptcb->OSTCBEventMultiPtr;
;;;140            pevent  = *pevents;
;;;141            while (pevent != (OS_EVENT *)0) {
;;;142                pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
;;;143                if (pevent->OSEventTbl[y_old] == 0u) {
;;;144                    pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
;;;145                }
;;;146                pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
;;;147                pevent->OSEventTbl[y_new] |= bitx_new;
;;;148                pevents++;
;;;149                pevent                     = *pevents;
;;;150            }
;;;151        }
;;;152    #endif
;;;153    #endif
;;;154    
;;;155        ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
;;;156        ptcb->OSTCBY    = y_new;
;;;157        ptcb->OSTCBX    = x_new;
;;;158        ptcb->OSTCBBitY = bity_new;
;;;159        ptcb->OSTCBBitX = bitx_new;
;;;160        OS_EXIT_CRITICAL();
;;;161        if (OSRunning == OS_TRUE) {
;;;162            OS_Sched();                                         /* Find new highest priority task          */
;;;163        }
;;;164        return (OS_ERR_NONE);
;;;165    }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.40|
000028  f1b90fff          CMP      r9,#0xff              ;91
00002c  d103              BNE      |L1.54|
00002e  4842              LDR      r0,|L1.312|
000030  6800              LDR      r0,[r0,#0]            ;92  ; OSTCBCur
000032  f8909032          LDRB     r9,[r0,#0x32]         ;92
                  |L1.54|
000036  483f              LDR      r0,|L1.308|
000038  f8504029          LDR      r4,[r0,r9,LSL #2]     ;94
00003c  b924              CBNZ     r4,|L1.72|
00003e  9800              LDR      r0,[sp,#0]            ;96
000040  f7fffffe          BL       OS_CPU_SR_Restore
000044  2029              MOVS     r0,#0x29              ;97
000046  e7ec              B        |L1.34|
                  |L1.72|
000048  2c01              CMP      r4,#1                 ;99
00004a  d104              BNE      |L1.86|
00004c  9800              LDR      r0,[sp,#0]            ;100
00004e  f7fffffe          BL       OS_CPU_SR_Restore
000052  2043              MOVS     r0,#0x43              ;101
000054  e7e5              B        |L1.34|
                  |L1.86|
000056  ea4f07e8          ASR      r7,r8,#3              ;104
00005a  f0080007          AND      r0,r8,#7              ;105
00005e  9003              STR      r0,[sp,#0xc]          ;105
000060  2001              MOVS     r0,#1                 ;110
000062  40b8              LSLS     r0,r0,r7              ;110
000064  f0000aff          AND      r10,r0,#0xff          ;110
000068  2101              MOVS     r1,#1                 ;111
00006a  9803              LDR      r0,[sp,#0xc]          ;111
00006c  4081              LSLS     r1,r1,r0              ;111
00006e  f0010bff          AND      r11,r1,#0xff          ;111
000072  2000              MOVS     r0,#0                 ;113
000074  492f              LDR      r1,|L1.308|
000076  f8410029          STR      r0,[r1,r9,LSL #2]     ;113
00007a  4608              MOV      r0,r1                 ;114
00007c  f8404028          STR      r4,[r0,r8,LSL #2]     ;114
000080  f8146f34          LDRB     r6,[r4,#0x34]!        ;115
000084  78a0              LDRB     r0,[r4,#2]            ;116
000086  9002              STR      r0,[sp,#8]            ;116
000088  7860              LDRB     r0,[r4,#1]            ;117
00008a  3c34              SUBS     r4,r4,#0x34           ;117
00008c  9001              STR      r0,[sp,#4]            ;117
00008e  482b              LDR      r0,|L1.316|
000090  5d81              LDRB     r1,[r0,r6]            ;118
000092  9801              LDR      r0,[sp,#4]            ;118
000094  4001              ANDS     r1,r1,r0              ;118
000096  b1d1              CBZ      r1,|L1.206|
000098  4828              LDR      r0,|L1.316|
00009a  5d80              LDRB     r0,[r0,r6]            ;119
00009c  9901              LDR      r1,[sp,#4]            ;119
00009e  4388              BICS     r0,r0,r1              ;119
0000a0  4926              LDR      r1,|L1.316|
0000a2  5588              STRB     r0,[r1,r6]            ;119
0000a4  4608              MOV      r0,r1                 ;120
0000a6  5d80              LDRB     r0,[r0,r6]            ;120
0000a8  b928              CBNZ     r0,|L1.182|
0000aa  4825              LDR      r0,|L1.320|
0000ac  7800              LDRB     r0,[r0,#0]            ;121  ; OSRdyGrp
0000ae  9902              LDR      r1,[sp,#8]            ;121
0000b0  4388              BICS     r0,r0,r1              ;121
0000b2  4923              LDR      r1,|L1.320|
0000b4  7008              STRB     r0,[r1,#0]            ;121
                  |L1.182|
0000b6  4822              LDR      r0,|L1.320|
0000b8  7800              LDRB     r0,[r0,#0]            ;123  ; OSRdyGrp
0000ba  ea40000a          ORR      r0,r0,r10             ;123
0000be  4920              LDR      r1,|L1.320|
0000c0  7008              STRB     r0,[r1,#0]            ;123
0000c2  481e              LDR      r0,|L1.316|
0000c4  5dc0              LDRB     r0,[r0,r7]            ;124
0000c6  ea40000b          ORR      r0,r0,r11             ;124
0000ca  491c              LDR      r1,|L1.316|
0000cc  55c8              STRB     r0,[r1,r7]            ;124
                  |L1.206|
0000ce  69e5              LDR      r5,[r4,#0x1c]         ;128
0000d0  b1d5              CBZ      r5,|L1.264|
0000d2  f105000b          ADD      r0,r5,#0xb            ;130
0000d6  5d80              LDRB     r0,[r0,r6]            ;130
0000d8  9901              LDR      r1,[sp,#4]            ;130
0000da  4388              BICS     r0,r0,r1              ;130
0000dc  f105010b          ADD      r1,r5,#0xb            ;130
0000e0  5588              STRB     r0,[r1,r6]            ;130
0000e2  4608              MOV      r0,r1                 ;131
0000e4  5d80              LDRB     r0,[r0,r6]            ;131
0000e6  b918              CBNZ     r0,|L1.240|
0000e8  7aa8              LDRB     r0,[r5,#0xa]          ;132
0000ea  9902              LDR      r1,[sp,#8]            ;132
0000ec  4388              BICS     r0,r0,r1              ;132
0000ee  72a8              STRB     r0,[r5,#0xa]          ;132
                  |L1.240|
0000f0  7aa8              LDRB     r0,[r5,#0xa]          ;134
0000f2  ea40000a          ORR      r0,r0,r10             ;134
0000f6  72a8              STRB     r0,[r5,#0xa]          ;134
0000f8  f105000b          ADD      r0,r5,#0xb            ;135
0000fc  5dc0              LDRB     r0,[r0,r7]            ;135
0000fe  ea40000b          ORR      r0,r0,r11             ;135
000102  f105010b          ADD      r1,r5,#0xb            ;135
000106  55c8              STRB     r0,[r1,r7]            ;135
                  |L1.264|
000108  f8848032          STRB     r8,[r4,#0x32]         ;155
00010c  f8847034          STRB     r7,[r4,#0x34]         ;156
000110  9803              LDR      r0,[sp,#0xc]          ;157
000112  f8840033          STRB     r0,[r4,#0x33]         ;157
000116  f884a036          STRB     r10,[r4,#0x36]        ;158
00011a  f884b035          STRB     r11,[r4,#0x35]        ;159
00011e  9800              LDR      r0,[sp,#0]            ;160
000120  f7fffffe          BL       OS_CPU_SR_Restore
000124  4807              LDR      r0,|L1.324|
000126  7800              LDRB     r0,[r0,#0]            ;161  ; OSRunning
000128  2801              CMP      r0,#1                 ;161
00012a  d101              BNE      |L1.304|
00012c  f7fffffe          BL       OS_Sched
                  |L1.304|
000130  2000              MOVS     r0,#0                 ;164
000132  e776              B        |L1.34|
;;;166    #endif
                          ENDP

                  |L1.308|
                          DCD      OSTCBPrioTbl
                  |L1.312|
                          DCD      OSTCBCur
                  |L1.316|
                          DCD      OSRdyTbl
                  |L1.320|
                          DCD      OSRdyGrp
                  |L1.324|
                          DCD      OSRunning

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;210    #if OS_TASK_CREATE_EN > 0u
;;;211    INT8U  OSTaskCreate (void   (*task)(void *p_arg),
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;212                         void    *p_arg,
;;;213                         OS_STK  *ptos,
;;;214                         INT8U    prio)
;;;215    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;216        OS_STK     *psp;
;;;217        INT8U       err;
;;;218    #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
;;;219        OS_CPU_SR   cpu_sr = 0u;
00000c  f04f0900          MOV      r9,#0
;;;220    #endif
;;;221    
;;;222    
;;;223    
;;;224    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;225        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;226            OS_SAFETY_CRITICAL_EXCEPTION();
;;;227            return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
;;;228        }
;;;229    #endif
;;;230    
;;;231    #if OS_ARG_CHK_EN > 0u
;;;232        if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
;;;233            return (OS_ERR_PRIO_INVALID);
;;;234        }
;;;235    #endif
;;;236        OS_ENTER_CRITICAL();
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4681              MOV      r9,r0
;;;237        if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000016  481f              LDR      r0,|L2.148|
000018  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001a  b128              CBZ      r0,|L2.40|
;;;238            OS_EXIT_CRITICAL();
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       OS_CPU_SR_Restore
;;;239            return (OS_ERR_TASK_CREATE_ISR);
000022  203c              MOVS     r0,#0x3c
                  |L2.36|
;;;240        }
;;;241        if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
;;;242            OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
;;;243                                                 /* ... the same thing until task is created.              */
;;;244            OS_EXIT_CRITICAL();
;;;245            psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
;;;246            err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
;;;247            if (err == OS_ERR_NONE) {
;;;248                if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
;;;249                    OS_Sched();
;;;250                }
;;;251            } else {
;;;252                OS_ENTER_CRITICAL();
;;;253                OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
;;;254                OS_EXIT_CRITICAL();
;;;255            }
;;;256            return (err);
;;;257        }
;;;258        OS_EXIT_CRITICAL();
;;;259        return (OS_ERR_PRIO_EXIST);
;;;260    }
000024  e8bd8ffe          POP      {r1-r11,pc}
                  |L2.40|
000028  481b              LDR      r0,|L2.152|
00002a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;241
00002e  bb60              CBNZ     r0,|L2.138|
000030  2001              MOVS     r0,#1                 ;242
000032  4919              LDR      r1,|L2.152|
000034  f8410024          STR      r0,[r1,r4,LSL #2]     ;242
000038  4648              MOV      r0,r9                 ;244
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2300              MOVS     r3,#0                 ;245
000040  4642              MOV      r2,r8                 ;245
000042  4639              MOV      r1,r7                 ;245
000044  4630              MOV      r0,r6                 ;245
000046  f7fffffe          BL       OSTaskStkInit
00004a  4682              MOV      r10,r0                ;245
00004c  2000              MOVS     r0,#0                 ;246
00004e  9000              STR      r0,[sp,#0]            ;246
000050  9001              STR      r0,[sp,#4]            ;246
000052  4603              MOV      r3,r0                 ;246
000054  4602              MOV      r2,r0                 ;246
000056  4651              MOV      r1,r10                ;246
000058  9002              STR      r0,[sp,#8]            ;246
00005a  4620              MOV      r0,r4                 ;246
00005c  f7fffffe          BL       OS_TCBInit
000060  4605              MOV      r5,r0                 ;246
000062  b935              CBNZ     r5,|L2.114|
000064  480d              LDR      r0,|L2.156|
000066  7800              LDRB     r0,[r0,#0]            ;248  ; OSRunning
000068  2801              CMP      r0,#1                 ;248
00006a  d10c              BNE      |L2.134|
00006c  f7fffffe          BL       OS_Sched
000070  e009              B        |L2.134|
                  |L2.114|
000072  f7fffffe          BL       OS_CPU_SR_Save
000076  4681              MOV      r9,r0                 ;252
000078  2000              MOVS     r0,#0                 ;253
00007a  4907              LDR      r1,|L2.152|
00007c  f8410024          STR      r0,[r1,r4,LSL #2]     ;253
000080  4648              MOV      r0,r9                 ;254
000082  f7fffffe          BL       OS_CPU_SR_Restore
                  |L2.134|
000086  4628              MOV      r0,r5                 ;256
000088  e7cc              B        |L2.36|
                  |L2.138|
00008a  4648              MOV      r0,r9                 ;258
00008c  f7fffffe          BL       OS_CPU_SR_Restore
000090  2028              MOVS     r0,#0x28              ;259
000092  e7c7              B        |L2.36|
;;;261    #endif
                          ENDP

                  |L2.148|
                          DCD      OSIntNesting
                  |L2.152|
                          DCD      OSTCBPrioTbl
                  |L2.156|
                          DCD      OSRunning

                          AREA ||i.OSTaskCreateExt||, CODE, READONLY, ALIGN=2

                  OSTaskCreateExt PROC
;;;335    #if OS_TASK_CREATE_EXT_EN > 0u
;;;336    INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;337                            void    *p_arg,
;;;338                            OS_STK  *ptos,
;;;339                            INT8U    prio,
;;;340                            INT16U   id,
;;;341                            OS_STK  *pbos,
;;;342                            INT32U   stk_size,
;;;343                            void    *pext,
;;;344                            INT16U   opt)
;;;345    {
000004  b085              SUB      sp,sp,#0x14
000006  4681              MOV      r9,r0
000008  468a              MOV      r10,r1
00000a  4693              MOV      r11,r2
00000c  461c              MOV      r4,r3
00000e  e9dd780f          LDRD     r7,r8,[sp,#0x3c]
000012  9d12              LDR      r5,[sp,#0x48]
;;;346        OS_STK     *psp;
;;;347        INT8U       err;
;;;348    #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
;;;349        OS_CPU_SR   cpu_sr = 0u;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;350    #endif
;;;351    
;;;352    
;;;353    
;;;354    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;355        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;356            OS_SAFETY_CRITICAL_EXCEPTION();
;;;357            return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
;;;358        }
;;;359    #endif
;;;360    
;;;361    #if OS_ARG_CHK_EN > 0u
;;;362        if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
;;;363            return (OS_ERR_PRIO_INVALID);
;;;364        }
;;;365    #endif
;;;366        OS_ENTER_CRITICAL();
000018  f7fffffe          BL       OS_CPU_SR_Save
00001c  9003              STR      r0,[sp,#0xc]
;;;367        if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
00001e  4823              LDR      r0,|L3.172|
000020  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000022  b130              CBZ      r0,|L3.50|
;;;368            OS_EXIT_CRITICAL();
000024  9803              LDR      r0,[sp,#0xc]
000026  f7fffffe          BL       OS_CPU_SR_Restore
;;;369            return (OS_ERR_TASK_CREATE_ISR);
00002a  203c              MOVS     r0,#0x3c
                  |L3.44|
;;;370        }
;;;371        if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
;;;372            OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
;;;373                                                 /* ... the same thing until task is created.              */
;;;374            OS_EXIT_CRITICAL();
;;;375    
;;;376    #if (OS_TASK_STAT_STK_CHK_EN > 0u)
;;;377            OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
;;;378    #endif
;;;379    
;;;380            psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
;;;381            err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
;;;382            if (err == OS_ERR_NONE) {
;;;383                if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
;;;384                    OS_Sched();
;;;385                }
;;;386            } else {
;;;387                OS_ENTER_CRITICAL();
;;;388                OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
;;;389                OS_EXIT_CRITICAL();
;;;390            }
;;;391            return (err);
;;;392        }
;;;393        OS_EXIT_CRITICAL();
;;;394        return (OS_ERR_PRIO_EXIST);
;;;395    }
00002c  b005              ADD      sp,sp,#0x14
00002e  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.50|
000032  481f              LDR      r0,|L3.176|
000034  f8500024          LDR      r0,[r0,r4,LSL #2]     ;371
000038  bb88              CBNZ     r0,|L3.158|
00003a  2001              MOVS     r0,#1                 ;372
00003c  491c              LDR      r1,|L3.176|
00003e  f8410024          STR      r0,[r1,r4,LSL #2]     ;372
000042  9803              LDR      r0,[sp,#0xc]          ;374
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  462a              MOV      r2,r5                 ;377
00004a  4641              MOV      r1,r8                 ;377
00004c  4638              MOV      r0,r7                 ;377
00004e  f7fffffe          BL       OS_TaskStkClr
000052  462b              MOV      r3,r5                 ;380
000054  465a              MOV      r2,r11                ;380
000056  4651              MOV      r1,r10                ;380
000058  4648              MOV      r0,r9                 ;380
00005a  f7fffffe          BL       OSTaskStkInit
00005e  9004              STR      r0,[sp,#0x10]         ;380
000060  9811              LDR      r0,[sp,#0x44]         ;381
000062  e9cd8000          STRD     r8,r0,[sp,#0]         ;381
000066  9502              STR      r5,[sp,#8]            ;381
000068  463a              MOV      r2,r7                 ;381
00006a  4620              MOV      r0,r4                 ;381
00006c  9b0e              LDR      r3,[sp,#0x38]         ;381
00006e  9904              LDR      r1,[sp,#0x10]         ;381
000070  f7fffffe          BL       OS_TCBInit
000074  4606              MOV      r6,r0                 ;381
000076  b936              CBNZ     r6,|L3.134|
000078  480e              LDR      r0,|L3.180|
00007a  7800              LDRB     r0,[r0,#0]            ;383  ; OSRunning
00007c  2801              CMP      r0,#1                 ;383
00007e  d10c              BNE      |L3.154|
000080  f7fffffe          BL       OS_Sched
000084  e009              B        |L3.154|
                  |L3.134|
000086  f7fffffe          BL       OS_CPU_SR_Save
00008a  9003              STR      r0,[sp,#0xc]          ;387
00008c  2000              MOVS     r0,#0                 ;388
00008e  4908              LDR      r1,|L3.176|
000090  f8410024          STR      r0,[r1,r4,LSL #2]     ;388
000094  9803              LDR      r0,[sp,#0xc]          ;389
000096  f7fffffe          BL       OS_CPU_SR_Restore
                  |L3.154|
00009a  4630              MOV      r0,r6                 ;391
00009c  e7c6              B        |L3.44|
                  |L3.158|
00009e  e7ff              B        |L3.160|
                  |L3.160|
0000a0  9803              LDR      r0,[sp,#0xc]          ;393
0000a2  f7fffffe          BL       OS_CPU_SR_Restore
0000a6  2028              MOVS     r0,#0x28              ;394
0000a8  e7c0              B        |L3.44|
;;;396    #endif
                          ENDP

0000aa  0000              DCW      0x0000
                  |L3.172|
                          DCD      OSIntNesting
                  |L3.176|
                          DCD      OSTCBPrioTbl
                  |L3.180|
                          DCD      OSRunning

                          AREA ||i.OSTaskDel||, CODE, READONLY, ALIGN=2

                  OSTaskDel PROC
;;;434    #if OS_TASK_DEL_EN > 0u
;;;435    INT8U  OSTaskDel (INT8U prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;436    {
000004  4605              MOV      r5,r0
;;;437    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;438        OS_FLAG_NODE *pnode;
;;;439    #endif
;;;440        OS_TCB       *ptcb;
;;;441    #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
;;;442        OS_CPU_SR     cpu_sr = 0u;
000006  2700              MOVS     r7,#0
;;;443    #endif
;;;444    
;;;445    
;;;446    
;;;447        if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
000008  4847              LDR      r0,|L4.296|
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00000c  b110              CBZ      r0,|L4.20|
;;;448            return (OS_ERR_TASK_DEL_ISR);
00000e  2040              MOVS     r0,#0x40
                  |L4.16|
;;;449        }
;;;450        if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
;;;451            return (OS_ERR_TASK_DEL_IDLE);
;;;452        }
;;;453    #if OS_ARG_CHK_EN > 0u
;;;454        if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
;;;455            if (prio != OS_PRIO_SELF) {
;;;456                return (OS_ERR_PRIO_INVALID);
;;;457            }
;;;458        }
;;;459    #endif
;;;460    
;;;461    /*$PAGE*/
;;;462        OS_ENTER_CRITICAL();
;;;463        if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
;;;464            prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
;;;465        }
;;;466        ptcb = OSTCBPrioTbl[prio];
;;;467        if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
;;;468            OS_EXIT_CRITICAL();
;;;469            return (OS_ERR_TASK_NOT_EXIST);
;;;470        }
;;;471        if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
;;;472            OS_EXIT_CRITICAL();
;;;473            return (OS_ERR_TASK_DEL);
;;;474        }
;;;475    
;;;476        OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
;;;477        if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
;;;478            OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
;;;479        }
;;;480    
;;;481    #if (OS_EVENT_EN)
;;;482        if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
;;;483            OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
;;;484        }
;;;485    #if (OS_EVENT_MULTI_EN > 0u)
;;;486        if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
;;;487            OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;488        }
;;;489    #endif
;;;490    #endif
;;;491    
;;;492    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;493        pnode = ptcb->OSTCBFlagNode;
;;;494        if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
;;;495            OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
;;;496        }
;;;497    #endif
;;;498    
;;;499        ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
;;;500        ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
;;;501        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;502        if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
;;;503            OSLockNesting++;
;;;504        }
;;;505        OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
;;;506        OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
;;;507        OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
;;;508        if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
;;;509            OSLockNesting--;
;;;510        }
;;;511        OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
;;;512        OSTaskCtr--;                                        /* One less task being managed                 */
;;;513        OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
;;;514        if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
;;;515            ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
;;;516            OSTCBList                  = ptcb->OSTCBNext;
;;;517        } else {
;;;518            ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
;;;519            ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
;;;520        }
;;;521        ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
;;;522        OSTCBFreeList       = ptcb;
;;;523    #if OS_TASK_NAME_EN > 0u
;;;524        ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
;;;525    #endif
;;;526        OS_EXIT_CRITICAL();
;;;527        if (OSRunning == OS_TRUE) {
;;;528            OS_Sched();                                     /* Find new highest priority task              */
;;;529        }
;;;530        return (OS_ERR_NONE);
;;;531    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L4.20|
000014  2d3f              CMP      r5,#0x3f              ;450
000016  d101              BNE      |L4.28|
000018  203e              MOVS     r0,#0x3e              ;451
00001a  e7f9              B        |L4.16|
                  |L4.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4607              MOV      r7,r0                 ;462
000022  2dff              CMP      r5,#0xff              ;463
000024  d103              BNE      |L4.46|
000026  4841              LDR      r0,|L4.300|
000028  6800              LDR      r0,[r0,#0]            ;464  ; OSTCBCur
00002a  f8905032          LDRB     r5,[r0,#0x32]         ;464
                  |L4.46|
00002e  4840              LDR      r0,|L4.304|
000030  f8504025          LDR      r4,[r0,r5,LSL #2]     ;466
000034  b924              CBNZ     r4,|L4.64|
000036  4638              MOV      r0,r7                 ;468
000038  f7fffffe          BL       OS_CPU_SR_Restore
00003c  2043              MOVS     r0,#0x43              ;469
00003e  e7e7              B        |L4.16|
                  |L4.64|
000040  2c01              CMP      r4,#1                 ;471
000042  d104              BNE      |L4.78|
000044  4638              MOV      r0,r7                 ;472
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  203d              MOVS     r0,#0x3d              ;473
00004c  e7e0              B        |L4.16|
                  |L4.78|
00004e  f8140f34          LDRB     r0,[r4,#0x34]!        ;476
000052  4938              LDR      r1,|L4.308|
000054  5c08              LDRB     r0,[r1,r0]            ;476
000056  7861              LDRB     r1,[r4,#1]            ;476
000058  4388              BICS     r0,r0,r1              ;476
00005a  7821              LDRB     r1,[r4,#0]            ;476
00005c  4a35              LDR      r2,|L4.308|
00005e  5450              STRB     r0,[r2,r1]            ;476
000060  f8140934          LDRB     r0,[r4],#-0x34        ;477
000064  4611              MOV      r1,r2                 ;477
000066  5c08              LDRB     r0,[r1,r0]            ;477
000068  b930              CBNZ     r0,|L4.120|
00006a  f8941036          LDRB     r1,[r4,#0x36]         ;478
00006e  4832              LDR      r0,|L4.312|
000070  7800              LDRB     r0,[r0,#0]            ;478  ; OSRdyGrp
000072  4388              BICS     r0,r0,r1              ;478
000074  4930              LDR      r1,|L4.312|
000076  7008              STRB     r0,[r1,#0]            ;478
                  |L4.120|
000078  69e0              LDR      r0,[r4,#0x1c]         ;482
00007a  b118              CBZ      r0,|L4.132|
00007c  4620              MOV      r0,r4                 ;483
00007e  69e1              LDR      r1,[r4,#0x1c]         ;483
000080  f7fffffe          BL       OS_EventTaskRemove
                  |L4.132|
000084  6a66              LDR      r6,[r4,#0x24]         ;493
000086  b116              CBZ      r6,|L4.142|
000088  4630              MOV      r0,r6                 ;495
00008a  f7fffffe          BL       OS_FlagUnlink
                  |L4.142|
00008e  2000              MOVS     r0,#0                 ;499
000090  62e0              STR      r0,[r4,#0x2c]         ;499
000092  f8840030          STRB     r0,[r4,#0x30]         ;500
000096  f8840031          STRB     r0,[r4,#0x31]         ;501
00009a  4828              LDR      r0,|L4.316|
00009c  7800              LDRB     r0,[r0,#0]            ;502  ; OSLockNesting
00009e  28ff              CMP      r0,#0xff              ;502
0000a0  d204              BCS      |L4.172|
0000a2  4826              LDR      r0,|L4.316|
0000a4  7800              LDRB     r0,[r0,#0]            ;503  ; OSLockNesting
0000a6  1c40              ADDS     r0,r0,#1              ;503
0000a8  4924              LDR      r1,|L4.316|
0000aa  7008              STRB     r0,[r1,#0]            ;503
                  |L4.172|
0000ac  4638              MOV      r0,r7                 ;505
0000ae  f7fffffe          BL       OS_CPU_SR_Restore
0000b2  f7fffffe          BL       OS_Dummy
0000b6  f7fffffe          BL       OS_CPU_SR_Save
0000ba  4607              MOV      r7,r0                 ;507
0000bc  481f              LDR      r0,|L4.316|
0000be  7800              LDRB     r0,[r0,#0]            ;508  ; OSLockNesting
0000c0  b120              CBZ      r0,|L4.204|
0000c2  481e              LDR      r0,|L4.316|
0000c4  7800              LDRB     r0,[r0,#0]            ;509  ; OSLockNesting
0000c6  1e40              SUBS     r0,r0,#1              ;509
0000c8  491c              LDR      r1,|L4.316|
0000ca  7008              STRB     r0,[r1,#0]            ;509
                  |L4.204|
0000cc  4620              MOV      r0,r4                 ;511
0000ce  f7fffffe          BL       OSTaskDelHook
0000d2  481b              LDR      r0,|L4.320|
0000d4  7800              LDRB     r0,[r0,#0]            ;512  ; OSTaskCtr
0000d6  1e40              SUBS     r0,r0,#1              ;512
0000d8  4919              LDR      r1,|L4.320|
0000da  7008              STRB     r0,[r1,#0]            ;512
0000dc  2000              MOVS     r0,#0                 ;513
0000de  4914              LDR      r1,|L4.304|
0000e0  f8410025          STR      r0,[r1,r5,LSL #2]     ;513
0000e4  69a0              LDR      r0,[r4,#0x18]         ;514
0000e6  b930              CBNZ     r0,|L4.246|
0000e8  2000              MOVS     r0,#0                 ;515
0000ea  6961              LDR      r1,[r4,#0x14]         ;515
0000ec  6188              STR      r0,[r1,#0x18]         ;515
0000ee  4915              LDR      r1,|L4.324|
0000f0  6960              LDR      r0,[r4,#0x14]         ;516
0000f2  6008              STR      r0,[r1,#0]            ;516  ; OSTCBList
0000f4  e005              B        |L4.258|
                  |L4.246|
0000f6  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;518
0000fa  6148              STR      r0,[r1,#0x14]         ;518
0000fc  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;519
000100  6188              STR      r0,[r1,#0x18]         ;519
                  |L4.258|
000102  4811              LDR      r0,|L4.328|
000104  6800              LDR      r0,[r0,#0]            ;521  ; OSTCBFreeList
000106  6160              STR      r0,[r4,#0x14]         ;521
000108  480f              LDR      r0,|L4.328|
00010a  6004              STR      r4,[r0,#0]            ;522  ; OSTCBFreeList
00010c  a00f              ADR      r0,|L4.332|
00010e  64e0              STR      r0,[r4,#0x4c]         ;524
000110  4638              MOV      r0,r7                 ;526
000112  f7fffffe          BL       OS_CPU_SR_Restore
000116  480e              LDR      r0,|L4.336|
000118  7800              LDRB     r0,[r0,#0]            ;527  ; OSRunning
00011a  2801              CMP      r0,#1                 ;527
00011c  d101              BNE      |L4.290|
00011e  f7fffffe          BL       OS_Sched
                  |L4.290|
000122  2000              MOVS     r0,#0                 ;530
000124  e774              B        |L4.16|
;;;532    #endif
                          ENDP

000126  0000              DCW      0x0000
                  |L4.296|
                          DCD      OSIntNesting
                  |L4.300|
                          DCD      OSTCBCur
                  |L4.304|
                          DCD      OSTCBPrioTbl
                  |L4.308|
                          DCD      OSRdyTbl
                  |L4.312|
                          DCD      OSRdyGrp
                  |L4.316|
                          DCD      OSLockNesting
                  |L4.320|
                          DCD      OSTaskCtr
                  |L4.324|
                          DCD      OSTCBList
                  |L4.328|
                          DCD      OSTCBFreeList
                  |L4.332|
00014c  3f00              DCB      "?",0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L4.336|
                          DCD      OSRunning

                          AREA ||i.OSTaskDelReq||, CODE, READONLY, ALIGN=2

                  OSTaskDelReq PROC
;;;580    #if OS_TASK_DEL_EN > 0u
;;;581    INT8U  OSTaskDelReq (INT8U prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;582    {
000004  4604              MOV      r4,r0
;;;583        INT8U      stat;
;;;584        OS_TCB    *ptcb;
;;;585    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;586        OS_CPU_SR  cpu_sr = 0u;
000006  2700              MOVS     r7,#0
;;;587    #endif
;;;588    
;;;589    
;;;590    
;;;591        if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
000008  2c3f              CMP      r4,#0x3f
00000a  d102              BNE      |L5.18|
;;;592            return (OS_ERR_TASK_DEL_IDLE);
00000c  203e              MOVS     r0,#0x3e
                  |L5.14|
;;;593        }
;;;594    #if OS_ARG_CHK_EN > 0u
;;;595        if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
;;;596            if (prio != OS_PRIO_SELF) {
;;;597                return (OS_ERR_PRIO_INVALID);
;;;598            }
;;;599        }
;;;600    #endif
;;;601        if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
;;;602            OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
;;;603            stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
;;;604            OS_EXIT_CRITICAL();
;;;605            return (stat);
;;;606        }
;;;607        OS_ENTER_CRITICAL();
;;;608        ptcb = OSTCBPrioTbl[prio];
;;;609        if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
;;;610            OS_EXIT_CRITICAL();
;;;611            return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
;;;612        }
;;;613        if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
;;;614            OS_EXIT_CRITICAL();
;;;615            return (OS_ERR_TASK_DEL);
;;;616        }
;;;617        ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
;;;618        OS_EXIT_CRITICAL();
;;;619        return (OS_ERR_NONE);
;;;620    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L5.18|
000012  2cff              CMP      r4,#0xff              ;601
000014  d10b              BNE      |L5.46|
000016  f7fffffe          BL       OS_CPU_SR_Save
00001a  4607              MOV      r7,r0                 ;602
00001c  4811              LDR      r0,|L5.100|
00001e  6800              LDR      r0,[r0,#0]            ;603  ; OSTCBCur
000020  f8906037          LDRB     r6,[r0,#0x37]         ;603
000024  4638              MOV      r0,r7                 ;604
000026  f7fffffe          BL       OS_CPU_SR_Restore
00002a  4630              MOV      r0,r6                 ;605
00002c  e7ef              B        |L5.14|
                  |L5.46|
00002e  f7fffffe          BL       OS_CPU_SR_Save
000032  4607              MOV      r7,r0                 ;607
000034  480c              LDR      r0,|L5.104|
000036  f8505024          LDR      r5,[r0,r4,LSL #2]     ;608
00003a  b925              CBNZ     r5,|L5.70|
00003c  4638              MOV      r0,r7                 ;610
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2043              MOVS     r0,#0x43              ;611
000044  e7e3              B        |L5.14|
                  |L5.70|
000046  2d01              CMP      r5,#1                 ;613
000048  d104              BNE      |L5.84|
00004a  4638              MOV      r0,r7                 ;614
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  203d              MOVS     r0,#0x3d              ;615
000052  e7dc              B        |L5.14|
                  |L5.84|
000054  203f              MOVS     r0,#0x3f              ;617
000056  f8850037          STRB     r0,[r5,#0x37]         ;617
00005a  4638              MOV      r0,r7                 ;618
00005c  f7fffffe          BL       OS_CPU_SR_Restore
000060  2000              MOVS     r0,#0                 ;619
000062  e7d4              B        |L5.14|
;;;621    #endif
                          ENDP

                  |L5.100|
                          DCD      OSTCBCur
                  |L5.104|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskNameGet||, CODE, READONLY, ALIGN=2

                  OSTaskNameGet PROC
;;;647    #if OS_TASK_NAME_EN > 0u
;;;648    INT8U  OSTaskNameGet (INT8U    prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;649                          INT8U  **pname,
;;;650                          INT8U   *perr)
;;;651    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;652        OS_TCB    *ptcb;
;;;653        INT8U      len;
;;;654    #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
;;;655        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;656    #endif
;;;657    
;;;658    
;;;659    
;;;660    #ifdef OS_SAFETY_CRITICAL
;;;661        if (perr == (INT8U *)0) {
;;;662            OS_SAFETY_CRITICAL_EXCEPTION();
;;;663            return (0u);
;;;664        }
;;;665    #endif
;;;666    
;;;667    #if OS_ARG_CHK_EN > 0u
;;;668        if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
;;;669            if (prio != OS_PRIO_SELF) {
;;;670                *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
;;;671                return (0u);
;;;672            }
;;;673        }
;;;674        if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
;;;675            *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
;;;676            return (0u);
;;;677        }
;;;678    #endif
;;;679        if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
00000e  4819              LDR      r0,|L6.116|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b120              CBZ      r0,|L6.30|
;;;680            *perr = OS_ERR_NAME_GET_ISR;
000014  2011              MOVS     r0,#0x11
000016  7020              STRB     r0,[r4,#0]
;;;681            return (0u);
000018  2000              MOVS     r0,#0
                  |L6.26|
;;;682        }
;;;683        OS_ENTER_CRITICAL();
;;;684        if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
;;;685            prio = OSTCBCur->OSTCBPrio;
;;;686        }
;;;687        ptcb = OSTCBPrioTbl[prio];
;;;688        if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
;;;689            OS_EXIT_CRITICAL();                              /* No                                         */
;;;690            *perr = OS_ERR_TASK_NOT_EXIST;
;;;691            return (0u);
;;;692        }
;;;693        if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
;;;694            OS_EXIT_CRITICAL();                              /* Yes                                        */
;;;695            *perr = OS_ERR_TASK_NOT_EXIST;
;;;696            return (0u);
;;;697        }
;;;698        *pname = ptcb->OSTCBTaskName;
;;;699        len    = OS_StrLen(*pname);
;;;700        OS_EXIT_CRITICAL();
;;;701        *perr  = OS_ERR_NONE;
;;;702        return (len);
;;;703    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L6.30|
00001e  f7fffffe          BL       OS_CPU_SR_Save
000022  4680              MOV      r8,r0                 ;683
000024  2eff              CMP      r6,#0xff              ;684
000026  d103              BNE      |L6.48|
000028  4813              LDR      r0,|L6.120|
00002a  6800              LDR      r0,[r0,#0]            ;685  ; OSTCBCur
00002c  f8906032          LDRB     r6,[r0,#0x32]         ;685
                  |L6.48|
000030  4812              LDR      r0,|L6.124|
000032  f8505026          LDR      r5,[r0,r6,LSL #2]     ;687
000036  b935              CBNZ     r5,|L6.70|
000038  4640              MOV      r0,r8                 ;689
00003a  f7fffffe          BL       OS_CPU_SR_Restore
00003e  2043              MOVS     r0,#0x43              ;690
000040  7020              STRB     r0,[r4,#0]            ;690
000042  2000              MOVS     r0,#0                 ;691
000044  e7e9              B        |L6.26|
                  |L6.70|
000046  2d01              CMP      r5,#1                 ;693
000048  d106              BNE      |L6.88|
00004a  4640              MOV      r0,r8                 ;694
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2043              MOVS     r0,#0x43              ;695
000052  7020              STRB     r0,[r4,#0]            ;695
000054  2000              MOVS     r0,#0                 ;696
000056  e7e0              B        |L6.26|
                  |L6.88|
000058  6ce8              LDR      r0,[r5,#0x4c]         ;698
00005a  6038              STR      r0,[r7,#0]            ;698
00005c  6838              LDR      r0,[r7,#0]            ;699
00005e  f7fffffe          BL       OS_StrLen
000062  4681              MOV      r9,r0                 ;699
000064  4640              MOV      r0,r8                 ;700
000066  f7fffffe          BL       OS_CPU_SR_Restore
00006a  2000              MOVS     r0,#0                 ;701
00006c  7020              STRB     r0,[r4,#0]            ;701
00006e  4648              MOV      r0,r9                 ;702
000070  e7d3              B        |L6.26|
;;;704    #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L6.116|
                          DCD      OSIntNesting
                  |L6.120|
                          DCD      OSTCBCur
                  |L6.124|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskNameSet||, CODE, READONLY, ALIGN=2

                  OSTaskNameSet PROC
;;;729    #if OS_TASK_NAME_EN > 0u
;;;730    void  OSTaskNameSet (INT8U   prio,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;731                         INT8U  *pname,
;;;732                         INT8U  *perr)
;;;733    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;734        OS_TCB    *ptcb;
;;;735    #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
;;;736        OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0800          MOV      r8,#0
;;;737    #endif
;;;738    
;;;739    
;;;740    
;;;741    #ifdef OS_SAFETY_CRITICAL
;;;742        if (perr == (INT8U *)0) {
;;;743            OS_SAFETY_CRITICAL_EXCEPTION();
;;;744            return;
;;;745        }
;;;746    #endif
;;;747    
;;;748    #if OS_ARG_CHK_EN > 0u
;;;749        if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
;;;750            if (prio != OS_PRIO_SELF) {
;;;751                *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
;;;752                return;
;;;753            }
;;;754        }
;;;755        if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
;;;756            *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
;;;757            return;
;;;758        }
;;;759    #endif
;;;760        if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00000e  4815              LDR      r0,|L7.100|
000010  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000012  b118              CBZ      r0,|L7.28|
;;;761            *perr = OS_ERR_NAME_SET_ISR;
000014  2012              MOVS     r0,#0x12
000016  7020              STRB     r0,[r4,#0]
                  |L7.24|
;;;762            return;
;;;763        }
;;;764        OS_ENTER_CRITICAL();
;;;765        if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
;;;766            prio = OSTCBCur->OSTCBPrio;
;;;767        }
;;;768        ptcb = OSTCBPrioTbl[prio];
;;;769        if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
;;;770            OS_EXIT_CRITICAL();                          /* No                                             */
;;;771            *perr = OS_ERR_TASK_NOT_EXIST;
;;;772            return;
;;;773        }
;;;774        if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
;;;775            OS_EXIT_CRITICAL();                          /* Yes                                            */
;;;776            *perr = OS_ERR_TASK_NOT_EXIST;
;;;777            return;
;;;778        }
;;;779        ptcb->OSTCBTaskName = pname;
;;;780        OS_EXIT_CRITICAL();
;;;781        *perr               = OS_ERR_NONE;
;;;782    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L7.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4680              MOV      r8,r0                 ;764
000022  2eff              CMP      r6,#0xff              ;765
000024  d103              BNE      |L7.46|
000026  4810              LDR      r0,|L7.104|
000028  6800              LDR      r0,[r0,#0]            ;766  ; OSTCBCur
00002a  f8906032          LDRB     r6,[r0,#0x32]         ;766
                  |L7.46|
00002e  480f              LDR      r0,|L7.108|
000030  f8505026          LDR      r5,[r0,r6,LSL #2]     ;768
000034  b92d              CBNZ     r5,|L7.66|
000036  4640              MOV      r0,r8                 ;770
000038  f7fffffe          BL       OS_CPU_SR_Restore
00003c  2043              MOVS     r0,#0x43              ;771
00003e  7020              STRB     r0,[r4,#0]            ;771
000040  e7ea              B        |L7.24|
                  |L7.66|
000042  2d01              CMP      r5,#1                 ;774
000044  d105              BNE      |L7.82|
000046  4640              MOV      r0,r8                 ;775
000048  f7fffffe          BL       OS_CPU_SR_Restore
00004c  2043              MOVS     r0,#0x43              ;776
00004e  7020              STRB     r0,[r4,#0]            ;776
000050  e7e2              B        |L7.24|
                  |L7.82|
000052  64ef              STR      r7,[r5,#0x4c]         ;779
000054  4640              MOV      r0,r8                 ;780
000056  f7fffffe          BL       OS_CPU_SR_Restore
00005a  2000              MOVS     r0,#0                 ;781
00005c  7020              STRB     r0,[r4,#0]            ;781
00005e  bf00              NOP      
000060  e7da              B        |L7.24|
;;;783    #endif
                          ENDP

000062  0000              DCW      0x0000
                  |L7.100|
                          DCD      OSIntNesting
                  |L7.104|
                          DCD      OSTCBCur
                  |L7.108|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskQuery||, CODE, READONLY, ALIGN=2

                  OSTaskQuery PROC
;;;1033   #if OS_TASK_QUERY_EN > 0u
;;;1034   INT8U  OSTaskQuery (INT8U    prio,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1035                       OS_TCB  *p_task_data)
;;;1036   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;1037       OS_TCB    *ptcb;
;;;1038   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1039       OS_CPU_SR  cpu_sr = 0u;
000008  2700              MOVS     r7,#0
;;;1040   #endif
;;;1041   
;;;1042   
;;;1043   
;;;1044   #if OS_ARG_CHK_EN > 0u
;;;1045       if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
;;;1046           if (prio != OS_PRIO_SELF) {
;;;1047               return (OS_ERR_PRIO_INVALID);
;;;1048           }
;;;1049       }
;;;1050       if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
;;;1051           return (OS_ERR_PDATA_NULL);
;;;1052       }
;;;1053   #endif
;;;1054       OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4607              MOV      r7,r0
;;;1055       if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
000010  2dff              CMP      r5,#0xff
000012  d103              BNE      |L8.28|
;;;1056           prio = OSTCBCur->OSTCBPrio;
000014  480f              LDR      r0,|L8.84|
000016  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000018  f8905032          LDRB     r5,[r0,#0x32]
                  |L8.28|
;;;1057       }
;;;1058       ptcb = OSTCBPrioTbl[prio];
00001c  480e              LDR      r0,|L8.88|
00001e  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1059       if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
000022  b92c              CBNZ     r4,|L8.48|
;;;1060           OS_EXIT_CRITICAL();
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       OS_CPU_SR_Restore
;;;1061           return (OS_ERR_PRIO);
00002a  2029              MOVS     r0,#0x29
                  |L8.44|
;;;1062       }
;;;1063       if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
;;;1064           OS_EXIT_CRITICAL();
;;;1065           return (OS_ERR_TASK_NOT_EXIST);
;;;1066       }
;;;1067                                                    /* Copy TCB into user storage area                    */
;;;1068       OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
;;;1069       OS_EXIT_CRITICAL();
;;;1070       return (OS_ERR_NONE);
;;;1071   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L8.48|
000030  2c01              CMP      r4,#1                 ;1063
000032  d104              BNE      |L8.62|
000034  4638              MOV      r0,r7                 ;1064
000036  f7fffffe          BL       OS_CPU_SR_Restore
00003a  2043              MOVS     r0,#0x43              ;1065
00003c  e7f6              B        |L8.44|
                  |L8.62|
00003e  2254              MOVS     r2,#0x54              ;1068
000040  4621              MOV      r1,r4                 ;1068
000042  4630              MOV      r0,r6                 ;1068
000044  f7fffffe          BL       OS_MemCopy
000048  4638              MOV      r0,r7                 ;1069
00004a  f7fffffe          BL       OS_CPU_SR_Restore
00004e  2000              MOVS     r0,#0                 ;1070
000050  e7ec              B        |L8.44|
;;;1072   #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L8.84|
                          DCD      OSTCBCur
                  |L8.88|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1100   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1101   INT32U  OSTaskRegGet (INT8U   prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1102                         INT8U   id,
;;;1103                         INT8U  *perr)
;;;1104   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1105   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1106       OS_CPU_SR  cpu_sr = 0u;
00000a  f04f0900          MOV      r9,#0
;;;1107   #endif
;;;1108       INT32U     value;
;;;1109       OS_TCB    *ptcb;
;;;1110   
;;;1111   
;;;1112   
;;;1113   #ifdef OS_SAFETY_CRITICAL
;;;1114       if (perr == (INT8U *)0) {
;;;1115           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1116           return (0u);
;;;1117       }
;;;1118   #endif
;;;1119   
;;;1120   #if OS_ARG_CHK_EN > 0u
;;;1121       if (prio >= OS_LOWEST_PRIO) {
;;;1122           if (prio != OS_PRIO_SELF) {
;;;1123               *perr = OS_ERR_PRIO_INVALID;
;;;1124               return (0u);
;;;1125           }
;;;1126       }
;;;1127       if (id >= OS_TASK_REG_TBL_SIZE) {
;;;1128           *perr = OS_ERR_ID_INVALID;
;;;1129           return (0u);
;;;1130       }
;;;1131   #endif
;;;1132       OS_ENTER_CRITICAL();
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  4681              MOV      r9,r0
;;;1133       if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
000014  2cff              CMP      r4,#0xff
000016  d102              BNE      |L9.30|
;;;1134           ptcb = OSTCBCur;
000018  4808              LDR      r0,|L9.60|
00001a  6805              LDR      r5,[r0,#0]  ; OSTCBCur
00001c  e002              B        |L9.36|
                  |L9.30|
;;;1135       } else {
;;;1136           ptcb = OSTCBPrioTbl[prio];
00001e  4808              LDR      r0,|L9.64|
000020  f8505024          LDR      r5,[r0,r4,LSL #2]
                  |L9.36|
;;;1137       }
;;;1138       value = ptcb->OSTCBRegTbl[id];
000024  f1050050          ADD      r0,r5,#0x50
000028  f8508026          LDR      r8,[r0,r6,LSL #2]
;;;1139       OS_EXIT_CRITICAL();
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1140       *perr = OS_ERR_NONE;
000032  2000              MOVS     r0,#0
000034  7038              STRB     r0,[r7,#0]
;;;1141       return (value);
000036  4640              MOV      r0,r8
;;;1142   }
000038  e8bd87f0          POP      {r4-r10,pc}
;;;1143   #endif
                          ENDP

                  |L9.60|
                          DCD      OSTCBCur
                  |L9.64|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskRegGetID||, CODE, READONLY, ALIGN=2

                  OSTaskRegGetID PROC
;;;1163   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1164   INT8U  OSTaskRegGetID (INT8U  *perr)
000000  b570              PUSH     {r4-r6,lr}
;;;1165   {
000002  4604              MOV      r4,r0
;;;1166   #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
;;;1167       OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;1168   #endif
;;;1169       INT8U      id;
;;;1170   
;;;1171   
;;;1172   #ifdef OS_SAFETY_CRITICAL
;;;1173       if (perr == (INT8U *)0) {
;;;1174           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1175           return ((INT8U)OS_TASK_REG_TBL_SIZE);
;;;1176       }
;;;1177   #endif
;;;1178   
;;;1179       OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4606              MOV      r6,r0
;;;1180       if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00000c  480b              LDR      r0,|L10.60|
00000e  7800              LDRB     r0,[r0,#0]  ; OSTaskRegNextAvailID
000010  2801              CMP      r0,#1
000012  db06              BLT      |L10.34|
;;;1181          *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
000014  2096              MOVS     r0,#0x96
000016  7020              STRB     r0,[r4,#0]
;;;1182           OS_EXIT_CRITICAL();
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       OS_CPU_SR_Restore
;;;1183           return ((INT8U)OS_TASK_REG_TBL_SIZE);
00001e  2001              MOVS     r0,#1
                  |L10.32|
;;;1184       }
;;;1185        
;;;1186       id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
;;;1187       OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
;;;1188       OS_EXIT_CRITICAL();
;;;1189      *perr = OS_ERR_NONE;
;;;1190       return (id);
;;;1191   }
000020  bd70              POP      {r4-r6,pc}
                  |L10.34|
000022  4806              LDR      r0,|L10.60|
000024  7805              LDRB     r5,[r0,#0]            ;1186  ; OSTaskRegNextAvailID
000026  7800              LDRB     r0,[r0,#0]            ;1187  ; OSTaskRegNextAvailID
000028  1c40              ADDS     r0,r0,#1              ;1187
00002a  4904              LDR      r1,|L10.60|
00002c  7008              STRB     r0,[r1,#0]            ;1187
00002e  4630              MOV      r0,r6                 ;1188
000030  f7fffffe          BL       OS_CPU_SR_Restore
000034  2000              MOVS     r0,#0                 ;1189
000036  7020              STRB     r0,[r4,#0]            ;1189
000038  4628              MOV      r0,r5                 ;1190
00003a  e7f1              B        |L10.32|
;;;1192   #endif
                          ENDP

                  |L10.60|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1223   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1224   void  OSTaskRegSet (INT8U    prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1225                       INT8U    id,
;;;1226                       INT32U   value,
;;;1227                       INT8U   *perr)
;;;1228   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1229   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1230       OS_CPU_SR  cpu_sr = 0u;
00000c  f04f0900          MOV      r9,#0
;;;1231   #endif
;;;1232       OS_TCB    *ptcb;
;;;1233   
;;;1234   
;;;1235   #ifdef OS_SAFETY_CRITICAL
;;;1236       if (perr == (INT8U *)0) {
;;;1237           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1238           return;
;;;1239       }
;;;1240   #endif
;;;1241   
;;;1242   #if OS_ARG_CHK_EN > 0u
;;;1243       if (prio >= OS_LOWEST_PRIO) {
;;;1244           if (prio != OS_PRIO_SELF) {
;;;1245               *perr = OS_ERR_PRIO_INVALID;
;;;1246               return;
;;;1247           }
;;;1248       }
;;;1249       if (id >= OS_TASK_REG_TBL_SIZE) {
;;;1250           *perr = OS_ERR_ID_INVALID;
;;;1251           return;
;;;1252       }
;;;1253   #endif
;;;1254       OS_ENTER_CRITICAL();
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  4681              MOV      r9,r0
;;;1255       if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
000016  2cff              CMP      r4,#0xff
000018  d102              BNE      |L11.32|
;;;1256           ptcb = OSTCBCur;
00001a  4809              LDR      r0,|L11.64|
00001c  6805              LDR      r5,[r0,#0]  ; OSTCBCur
00001e  e002              B        |L11.38|
                  |L11.32|
;;;1257       } else {
;;;1258           ptcb = OSTCBPrioTbl[prio];
000020  4808              LDR      r0,|L11.68|
000022  f8505024          LDR      r5,[r0,r4,LSL #2]
                  |L11.38|
;;;1259       }
;;;1260       ptcb->OSTCBRegTbl[id] = value;
000026  f1050050          ADD      r0,r5,#0x50
00002a  f8407026          STR      r7,[r0,r6,LSL #2]
;;;1261       OS_EXIT_CRITICAL();
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       OS_CPU_SR_Restore
;;;1262       *perr                 = OS_ERR_NONE;
000034  2000              MOVS     r0,#0
000036  f8880000          STRB     r0,[r8,#0]
;;;1263   }
00003a  e8bd87f0          POP      {r4-r10,pc}
;;;1264   #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      OSTCBCur
                  |L11.68|
                          DCD      OSTCBPrioTbl

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=2

                  OSTaskResume PROC
;;;804    #if OS_TASK_SUSPEND_EN > 0u
;;;805    INT8U  OSTaskResume (INT8U prio)
000000  b570              PUSH     {r4-r6,lr}
;;;806    {
000002  4605              MOV      r5,r0
;;;807        OS_TCB    *ptcb;
;;;808    #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
;;;809        OS_CPU_SR  cpu_sr = 0u;
000004  2600              MOVS     r6,#0
;;;810    #endif
;;;811    
;;;812    
;;;813    
;;;814    #if OS_ARG_CHK_EN > 0u
;;;815        if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
;;;816            return (OS_ERR_PRIO_INVALID);
;;;817        }
;;;818    #endif
;;;819        OS_ENTER_CRITICAL();
000006  f7fffffe          BL       OS_CPU_SR_Save
00000a  4606              MOV      r6,r0
;;;820        ptcb = OSTCBPrioTbl[prio];
00000c  4823              LDR      r0,|L12.156|
00000e  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;821        if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
000012  b924              CBNZ     r4,|L12.30|
;;;822            OS_EXIT_CRITICAL();
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       OS_CPU_SR_Restore
;;;823            return (OS_ERR_TASK_RESUME_PRIO);
00001a  2046              MOVS     r0,#0x46
                  |L12.28|
;;;824        }
;;;825        if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
;;;826            OS_EXIT_CRITICAL();
;;;827            return (OS_ERR_TASK_NOT_EXIST);
;;;828        }
;;;829        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
;;;830            ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
;;;831            if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
;;;832                if (ptcb->OSTCBDly == 0u) {
;;;833                    OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
;;;834                    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;835                    OS_EXIT_CRITICAL();
;;;836                    if (OSRunning == OS_TRUE) {
;;;837                        OS_Sched();                               /* Find new highest priority task        */
;;;838                    }
;;;839                } else {
;;;840                    OS_EXIT_CRITICAL();
;;;841                }
;;;842            } else {                                              /* Must be pending on event              */
;;;843                OS_EXIT_CRITICAL();
;;;844            }
;;;845            return (OS_ERR_NONE);
;;;846        }
;;;847        OS_EXIT_CRITICAL();
;;;848        return (OS_ERR_TASK_NOT_SUSPENDED);
;;;849    }
00001c  bd70              POP      {r4-r6,pc}
                  |L12.30|
00001e  2c01              CMP      r4,#1                 ;825
000020  d104              BNE      |L12.44|
000022  4630              MOV      r0,r6                 ;826
000024  f7fffffe          BL       OS_CPU_SR_Restore
000028  2043              MOVS     r0,#0x43              ;827
00002a  e7f7              B        |L12.28|
                  |L12.44|
00002c  f8940030          LDRB     r0,[r4,#0x30]         ;829
000030  f0000008          AND      r0,r0,#8              ;829
000034  b360              CBZ      r0,|L12.144|
000036  f8140f30          LDRB     r0,[r4,#0x30]!        ;830
00003a  f00000f7          AND      r0,r0,#0xf7           ;830
00003e  7020              STRB     r0,[r4,#0]            ;830
000040  f8140930          LDRB     r0,[r4],#-0x30        ;831
000044  b9f8              CBNZ     r0,|L12.134|
000046  6ae0              LDR      r0,[r4,#0x2c]         ;832
000048  b9c8              CBNZ     r0,|L12.126|
00004a  3434              ADDS     r4,r4,#0x34           ;833
00004c  78a0              LDRB     r0,[r4,#2]            ;833
00004e  4914              LDR      r1,|L12.160|
000050  7809              LDRB     r1,[r1,#0]            ;833  ; OSRdyGrp
000052  4308              ORRS     r0,r0,r1              ;833
000054  4912              LDR      r1,|L12.160|
000056  7008              STRB     r0,[r1,#0]            ;833
000058  7820              LDRB     r0,[r4,#0]            ;834
00005a  4912              LDR      r1,|L12.164|
00005c  5c08              LDRB     r0,[r1,r0]            ;834
00005e  7861              LDRB     r1,[r4,#1]            ;834
000060  4308              ORRS     r0,r0,r1              ;834
000062  f8141934          LDRB     r1,[r4],#-0x34        ;834
000066  4a0f              LDR      r2,|L12.164|
000068  5450              STRB     r0,[r2,r1]            ;834
00006a  4630              MOV      r0,r6                 ;835
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  480d              LDR      r0,|L12.168|
000072  7800              LDRB     r0,[r0,#0]            ;836  ; OSRunning
000074  2801              CMP      r0,#1                 ;836
000076  d109              BNE      |L12.140|
000078  f7fffffe          BL       OS_Sched
00007c  e006              B        |L12.140|
                  |L12.126|
00007e  4630              MOV      r0,r6                 ;840
000080  f7fffffe          BL       OS_CPU_SR_Restore
000084  e002              B        |L12.140|
                  |L12.134|
000086  4630              MOV      r0,r6                 ;843
000088  f7fffffe          BL       OS_CPU_SR_Restore
                  |L12.140|
00008c  2000              MOVS     r0,#0                 ;845
00008e  e7c5              B        |L12.28|
                  |L12.144|
000090  4630              MOV      r0,r6                 ;847
000092  f7fffffe          BL       OS_CPU_SR_Restore
000096  2044              MOVS     r0,#0x44              ;848
000098  e7c0              B        |L12.28|
;;;850    #endif
                          ENDP

00009a  0000              DCW      0x0000
                  |L12.156|
                          DCD      OSTCBPrioTbl
                  |L12.160|
                          DCD      OSRdyGrp
                  |L12.164|
                          DCD      OSRdyTbl
                  |L12.168|
                          DCD      OSRunning

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  OSTaskStkChk PROC
;;;871    #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;872    INT8U  OSTaskStkChk (INT8U         prio,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;873                         OS_STK_DATA  *p_stk_data)
;;;874    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;875        OS_TCB    *ptcb;
;;;876        OS_STK    *pchk;
;;;877        INT32U     nfree;
;;;878        INT32U     size;
;;;879    #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;880        OS_CPU_SR  cpu_sr = 0u;
000008  f04f0a00          MOV      r10,#0
;;;881    #endif
;;;882    
;;;883    
;;;884    
;;;885    #if OS_ARG_CHK_EN > 0u
;;;886        if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
;;;887            if (prio != OS_PRIO_SELF) {
;;;888                return (OS_ERR_PRIO_INVALID);
;;;889            }
;;;890        }
;;;891        if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
;;;892            return (OS_ERR_PDATA_NULL);
;;;893        }
;;;894    #endif
;;;895        p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
00000c  2000              MOVS     r0,#0
00000e  6020              STR      r0,[r4,#0]
;;;896        p_stk_data->OSUsed = 0u;
000010  6060              STR      r0,[r4,#4]
;;;897        OS_ENTER_CRITICAL();
000012  f7fffffe          BL       OS_CPU_SR_Save
000016  4682              MOV      r10,r0
;;;898        if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
000018  2eff              CMP      r6,#0xff
00001a  d103              BNE      |L13.36|
;;;899            prio = OSTCBCur->OSTCBPrio;
00001c  481c              LDR      r0,|L13.144|
00001e  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000020  f8906032          LDRB     r6,[r0,#0x32]
                  |L13.36|
;;;900        }
;;;901        ptcb = OSTCBPrioTbl[prio];
000024  481b              LDR      r0,|L13.148|
000026  f8505026          LDR      r5,[r0,r6,LSL #2]
;;;902        if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
00002a  b92d              CBNZ     r5,|L13.56|
;;;903            OS_EXIT_CRITICAL();
00002c  4650              MOV      r0,r10
00002e  f7fffffe          BL       OS_CPU_SR_Restore
;;;904            return (OS_ERR_TASK_NOT_EXIST);
000032  2043              MOVS     r0,#0x43
                  |L13.52|
;;;905        }
;;;906        if (ptcb == OS_TCB_RESERVED) {
;;;907            OS_EXIT_CRITICAL();
;;;908            return (OS_ERR_TASK_NOT_EXIST);
;;;909        }
;;;910        if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
;;;911            OS_EXIT_CRITICAL();
;;;912            return (OS_ERR_TASK_OPT);
;;;913        }
;;;914        nfree = 0u;
;;;915        size  = ptcb->OSTCBStkSize;
;;;916        pchk  = ptcb->OSTCBStkBottom;
;;;917        OS_EXIT_CRITICAL();
;;;918    #if OS_STK_GROWTH == 1u
;;;919        while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
;;;920            nfree++;
;;;921        }
;;;922    #else
;;;923        while (*pchk-- == (OS_STK)0) {
;;;924            nfree++;
;;;925        }
;;;926    #endif
;;;927        p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
;;;928        p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
;;;929    
;;;930    #if 1
;;;931    	printf("current prio: %d, free size: %d, used size: %d\r\n",prio,p_stk_data->OSFree*4,p_stk_data->OSUsed*4);
;;;932    #endif
;;;933    	return (OS_ERR_NONE);
;;;934    }
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L13.56|
000038  2d01              CMP      r5,#1                 ;906
00003a  d104              BNE      |L13.70|
00003c  4650              MOV      r0,r10                ;907
00003e  f7fffffe          BL       OS_CPU_SR_Restore
000042  2043              MOVS     r0,#0x43              ;908
000044  e7f6              B        |L13.52|
                  |L13.70|
000046  7c28              LDRB     r0,[r5,#0x10]         ;910
000048  f0000001          AND      r0,r0,#1              ;910
00004c  b920              CBNZ     r0,|L13.88|
00004e  4650              MOV      r0,r10                ;911
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  2045              MOVS     r0,#0x45              ;912
000056  e7ed              B        |L13.52|
                  |L13.88|
000058  2700              MOVS     r7,#0                 ;914
00005a  f8d5900c          LDR      r9,[r5,#0xc]          ;915
00005e  f8d58008          LDR      r8,[r5,#8]            ;916
000062  4650              MOV      r0,r10                ;917
000064  f7fffffe          BL       OS_CPU_SR_Restore
000068  e000              B        |L13.108|
                  |L13.106|
00006a  1c7f              ADDS     r7,r7,#1              ;920
                  |L13.108|
00006c  f8581b04          LDR      r1,[r8],#4            ;919
000070  2900              CMP      r1,#0                 ;919
000072  d0fa              BEQ      |L13.106|
000074  6027              STR      r7,[r4,#0]            ;927
000076  eba90007          SUB      r0,r9,r7              ;928
00007a  6060              STR      r0,[r4,#4]            ;928
00007c  6860              LDR      r0,[r4,#4]            ;931
00007e  0083              LSLS     r3,r0,#2              ;931
000080  6820              LDR      r0,[r4,#0]            ;931
000082  0082              LSLS     r2,r0,#2              ;931
000084  4631              MOV      r1,r6                 ;931
000086  a004              ADR      r0,|L13.152|
000088  f7fffffe          BL       __2printf
00008c  2000              MOVS     r0,#0                 ;933
00008e  e7d1              B        |L13.52|
;;;935    #endif
                          ENDP

                  |L13.144|
                          DCD      OSTCBCur
                  |L13.148|
                          DCD      OSTCBPrioTbl
                  |L13.152|
000098  63757272          DCB      "current prio: %d, free size: %d, used size: %d\r\n",0
00009c  656e7420
0000a0  7072696f
0000a4  3a202564
0000a8  2c206672
0000ac  65652073
0000b0  697a653a
0000b4  2025642c
0000b8  20757365
0000bc  64207369
0000c0  7a653a20
0000c4  25640d0a
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;960    #if OS_TASK_SUSPEND_EN > 0u
;;;961    INT8U  OSTaskSuspend (INT8U prio)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;962    {
000004  4605              MOV      r5,r0
;;;963        BOOLEAN    self;
;;;964        OS_TCB    *ptcb;
;;;965        INT8U      y;
;;;966    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;967        OS_CPU_SR  cpu_sr = 0u;
000006  f04f0800          MOV      r8,#0
;;;968    #endif
;;;969    
;;;970    
;;;971    
;;;972    #if OS_ARG_CHK_EN > 0u
;;;973        if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
;;;974            return (OS_ERR_TASK_SUSPEND_IDLE);
;;;975        }
;;;976        if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
;;;977            if (prio != OS_PRIO_SELF) {
;;;978                return (OS_ERR_PRIO_INVALID);
;;;979            }
;;;980        }
;;;981    #endif
;;;982        OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
00000e  4680              MOV      r8,r0
;;;983        if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
000010  2dff              CMP      r5,#0xff
000012  d105              BNE      |L14.32|
;;;984            prio = OSTCBCur->OSTCBPrio;
000014  4820              LDR      r0,|L14.152|
000016  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000018  f8905032          LDRB     r5,[r0,#0x32]
;;;985            self = OS_TRUE;
00001c  2601              MOVS     r6,#1
00001e  e008              B        |L14.50|
                  |L14.32|
;;;986        } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
000020  481d              LDR      r0,|L14.152|
000022  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000024  f8900032          LDRB     r0,[r0,#0x32]
000028  42a8              CMP      r0,r5
00002a  d101              BNE      |L14.48|
;;;987            self = OS_TRUE;
00002c  2601              MOVS     r6,#1
00002e  e000              B        |L14.50|
                  |L14.48|
;;;988        } else {
;;;989            self = OS_FALSE;                                        /* No suspending another task          */
000030  2600              MOVS     r6,#0
                  |L14.50|
;;;990        }
;;;991        ptcb = OSTCBPrioTbl[prio];
000032  481a              LDR      r0,|L14.156|
000034  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;992        if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
000038  b92c              CBNZ     r4,|L14.70|
;;;993            OS_EXIT_CRITICAL();
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       OS_CPU_SR_Restore
;;;994            return (OS_ERR_TASK_SUSPEND_PRIO);
000040  2048              MOVS     r0,#0x48
                  |L14.66|
;;;995        }
;;;996        if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
;;;997            OS_EXIT_CRITICAL();
;;;998            return (OS_ERR_TASK_NOT_EXIST);
;;;999        }
;;;1000       y            = ptcb->OSTCBY;
;;;1001       OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
;;;1002       if (OSRdyTbl[y] == 0u) {
;;;1003           OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
;;;1004       }
;;;1005       ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
;;;1006       OS_EXIT_CRITICAL();
;;;1007       if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
;;;1008           OS_Sched();                                             /* Find new highest priority task      */
;;;1009       }
;;;1010       return (OS_ERR_NONE);
;;;1011   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L14.70|
000046  2c01              CMP      r4,#1                 ;996
000048  d104              BNE      |L14.84|
00004a  4640              MOV      r0,r8                 ;997
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2043              MOVS     r0,#0x43              ;998
000052  e7f6              B        |L14.66|
                  |L14.84|
000054  f8947034          LDRB     r7,[r4,#0x34]         ;1000
000058  4811              LDR      r0,|L14.160|
00005a  5dc0              LDRB     r0,[r0,r7]            ;1001
00005c  f8941035          LDRB     r1,[r4,#0x35]         ;1001
000060  4388              BICS     r0,r0,r1              ;1001
000062  490f              LDR      r1,|L14.160|
000064  55c8              STRB     r0,[r1,r7]            ;1001
000066  4608              MOV      r0,r1                 ;1002
000068  5dc0              LDRB     r0,[r0,r7]            ;1002
00006a  b930              CBNZ     r0,|L14.122|
00006c  f8941036          LDRB     r1,[r4,#0x36]         ;1003
000070  480c              LDR      r0,|L14.164|
000072  7800              LDRB     r0,[r0,#0]            ;1003  ; OSRdyGrp
000074  4388              BICS     r0,r0,r1              ;1003
000076  490b              LDR      r1,|L14.164|
000078  7008              STRB     r0,[r1,#0]            ;1003
                  |L14.122|
00007a  f8940030          LDRB     r0,[r4,#0x30]         ;1005
00007e  f0400008          ORR      r0,r0,#8              ;1005
000082  f8840030          STRB     r0,[r4,#0x30]         ;1005
000086  4640              MOV      r0,r8                 ;1006
000088  f7fffffe          BL       OS_CPU_SR_Restore
00008c  2e01              CMP      r6,#1                 ;1007
00008e  d101              BNE      |L14.148|
000090  f7fffffe          BL       OS_Sched
                  |L14.148|
000094  2000              MOVS     r0,#0                 ;1010
000096  e7d4              B        |L14.66|
;;;1012   #endif
                          ENDP

                  |L14.152|
                          DCD      OSTCBCur
                  |L14.156|
                          DCD      OSTCBPrioTbl
                  |L14.160|
                          DCD      OSRdyTbl
                  |L14.164|
                          DCD      OSRdyGrp

                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;1281   
;;;1282   void  OS_TaskReturn (void)
000000  b510              PUSH     {r4,lr}
;;;1283   {
;;;1284       OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
000002  4804              LDR      r0,|L15.20|
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCur
000006  f7fffffe          BL       OSTaskReturnHook
;;;1285   
;;;1286   #if OS_TASK_DEL_EN > 0u
;;;1287       (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
00000a  20ff              MOVS     r0,#0xff
00000c  f7fffffe          BL       OSTaskDel
;;;1288   #else
;;;1289       for (;;) {
;;;1290           OSTimeDly(OS_TICKS_PER_SEC);
;;;1291       }
;;;1292   #endif
;;;1293   }
000010  bd10              POP      {r4,pc}
;;;1294   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      OSTCBCur

                          AREA ||i.OS_TaskStkClr||, CODE, READONLY, ALIGN=1

                  OS_TaskStkClr PROC
;;;1318   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1319   void  OS_TaskStkClr (OS_STK  *pbos,
000000  f0020301          AND      r3,r2,#1
;;;1320                        INT32U   size,
;;;1321                        INT16U   opt)
;;;1322   {
;;;1323       if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
000004  b143              CBZ      r3,|L16.24|
;;;1324           if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
000006  f0020302          AND      r3,r2,#2
00000a  b12b              CBZ      r3,|L16.24|
;;;1325   #if OS_STK_GROWTH == 1u
;;;1326               while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
00000c  e002              B        |L16.20|
                  |L16.14|
;;;1327                   size--;
00000e  1e49              SUBS     r1,r1,#1
;;;1328                   *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
000010  2300              MOVS     r3,#0
000012  c008              STM      r0!,{r3}
                  |L16.20|
000014  2900              CMP      r1,#0                 ;1326
000016  d1fa              BNE      |L16.14|
                  |L16.24|
;;;1329               }
;;;1330   #else
;;;1331               while (size > 0u) {                        /* Stack grows from LOW to HIGH memory          */
;;;1332                   size--;
;;;1333                   *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
;;;1334               }
;;;1335   #endif
;;;1336           }
;;;1337       }
;;;1338   }
000018  4770              BX       lr
;;;1339   
                          ENDP

